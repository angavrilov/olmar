// gnu.ast
// extension to cc.ast to support GNU language extensions

// sm: this contains both the representation language and the
// annotations used by the type checker, unlike the cc.ast
// vs. cc_tcheck.ast split, since there seemed little profit in that
// split for this file

verbatim {
  #define GNU_EXTENSION         // this extension module is active

  #include <limits.h>           // INT_MIN
}


// types denoted with 'typeof' keyword
new class ASTTypeof {
  // same as we do for statements
  public ASTTypeof *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(ASTTypeof *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  // yield the ASTTypeof selected by ambiguity resolution; the
  // type is in its 'type' member
  public ASTTypeof *tcheck(Env &env, DeclFlags dflags);
  public void mid_tcheck(Env &env, DeclFlags &dflags);
  pure_virtual Type *itcheck(Env &env, DeclFlags dflags);

  // dsw: I had to move this here to deal with the mid_tcheck design
  // pattern that is used to resolve ambiguities.
  public Type *type;

  -> TS_typeof_expr(Expression expr);

  -> TS_typeof_type(ASTTypeId atype);
}


class TypeSpecifier {
  -> TS_typeof(ASTTypeof atype);
}


class Expression {
  -> E_compoundLit(ASTTypeId stype, IN_compound init);

  -> E___builtin_constant_p(SourceLoc loc, Expression expr);

  -> E_alignofType(ASTTypeId atype);

  -> E_statement(S_compound s);
}


class Initializer {                    
  // a designator (list of fields/subscripts) in front of an
  // undesignated initializer
  -> IN_designated(FakeList<Designator> *designator_list,
                   Initializer init);
}

class Designator {
  // FakeList link; use setNext
  public Designator *next;  ctor next=NULL;
  public void setNext(Designator *newNext);

  // dsw: I seem to need all of this ambiguity stuff in order to use
  // genericSetNext

  // ambiguity representation
  public Designator *ambiguity; ctor ambiguity=NULL;
  public void addAmbiguity(Designator *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  pure_virtual void print(PrintEnv &env);

  -> FieldDesignator(StringRef id);

  -> SubscriptDesignator(Expression idx_expr, // taken from D_array
                         Expression /*nullable*/ idx_expr2)
  {
    public int idx_computed;  ctor idx_computed  = INT_MIN; // index computed at compile time
    public int idx_computed2; ctor idx_computed2 = INT_MIN; // index range end computed at compile time
  }
}


