// gnu.ast
// extension to cc.ast to support GNU language extensions

// sm: this contains both the representation language and the
// annotations used by the type checker, unlike the cc.ast
// vs. cc_tcheck.ast split, since there seemed little profit in that
// split for this file

verbatim {
  #define GNU_EXTENSION         // this extension module is active

  #include <limits.h>           // INT_MIN
}


// types denoted with 'typeof' keyword
new class ASTTypeof {
  // same as we do for statements
  public ASTTypeof *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(ASTTypeof *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  // yield the ASTTypeof selected by ambiguity resolution; the
  // type is in its 'type' member
  public ASTTypeof *tcheck(Env &env, DeclFlags dflags);
  public void mid_tcheck(Env &env, DeclFlags &dflags);
  pure_virtual Type *itcheck(Env &env, DeclFlags dflags);

  // dsw: I had to move this here to deal with the mid_tcheck design
  // pattern that is used to resolve ambiguities.
  public Type *type;

  // dsw: I'm assuming that ASTTypeof should terminate the top of the
  // Expression tree, but I don't feel absolutely sure about it.
  -> TS_typeof_expr(FullExpression expr);

  -> TS_typeof_type(ASTTypeId atype);
}


class TypeSpecifier {
  -> TS_typeof(ASTTypeof atype);
}


// additional contexts in the GNU extensions
enum DeclaratorContext {
                          // inside ASTTypeId
  DC_TS_TYPEOF_TYPE,      //   TS_typeof_type::atype
  DC_E_COMPOUNDLIT,       //   E_compoundLit::stype
  DC_E_ALIGNOFTYPE,       //   E_alignofType::atype
  DC_E_BUILTIN_VA_ARG,    //   E___builtin_va_arg::atype
}


class Statement {
  // nested function definition
  -> S_function(Function f);
}  

class Expression {
  -> E_compoundLit(ASTTypeId stype, IN_compound init) {
       // help for dealing with expressions being tchecked more than once
       public bool tcheckedType = false;
     }

  -> E___builtin_constant_p(SourceLoc loc, Expression expr);

  -> E___builtin_va_arg(SourceLoc loc, Expression expr, ASTTypeId atype);

  -> E_alignofType(ASTTypeId atype);

  -> E_statement(S_compound s);
}


class Initializer {                    
  // a designator (list of fields/subscripts) in front of an
  // undesignated initializer
  -> IN_designated(FakeList<Designator> *designator_list,
                   Initializer init);
}

class Designator (SourceLoc loc) {
  // FakeList link; use setNext
  public Designator *next;  ctor next=NULL;
  public void setNext(Designator *newNext);

  // dsw: I seem to need all of this ambiguity stuff in order to use
  // genericSetNext

  // ambiguity representation
  public Designator *ambiguity; ctor ambiguity=NULL;
  public void addAmbiguity(Designator *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  pure_virtual void print(PrintEnv &env);

  -> FieldDesignator(StringRef id);

  -> SubscriptDesignator(Expression idx_expr, // taken from D_array
                         Expression /*nullable*/ idx_expr2)
  {
    public int idx_computed  = INT_MIN; // index computed at compile time
    public int idx_computed2 = INT_MIN; // index range end computed at compile time
  }
}


