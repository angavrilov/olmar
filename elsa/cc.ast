// cc.ast            see license.txt for copyright and terms of use
// C++ abstract syntax
// see also cc.ast.html

// note: wherever ASTList or FakeList is used, its elements are listed
// in the order they appear lexically in the input file, i.e. left to
// right and then top to bottom

// How do I decide between ASTList and FakeList?  Creating ASTLists
// can be done with left recursion, which saves stack space, whereas
// FakeLists require right recursion.  But, ASTLists cannot safely
// be yielded as semantic values if there's any chance they'll be
// yielded more than once.
//
// So, I use FakeList everywhere I can accept the stack growth.  The
// only places I cannot accept this growth are places where it is
// relatively common for the list to have >100 elements.  Those
// places are:
//   - toplevel forms (and namespace toplevels, when I add them)
//   - statement lists in compound statements
//   - class/struct members
//   - compound initializers
//
// In these places where I use ASTList, I encapsulate it in another
// class if necessary to avoid yielding it as a semantic value.

// included in generated header
verbatim {
  #include "cc_flags.h"         // CVFlags, DeclFlags, etc. (r)
}

// use a new astgen feature: make a visitor!
option visitor ASTVisitor;


// ---------------- file -------------
// an entire file (with included stuff) of toplevel forms; I use
// an ASTList here because I want to use left recursion, and
// there's never a multiple-yield problem with toplevel forms
class TranslationUnit (ASTList<TopForm> topForms);

// a toplevel form
class TopForm (SourceLoc loc) {
  // includes function prototypes
  -> TF_decl(Declaration decl);

  // functions with bodies
  -> TF_func(Function f);

  // template functions or template classes
  -> TF_template(TemplateDeclaration td);

  // linkage specification enclosing a bunch of forms, e.g.
  // extern "C" { /*...*/ }
  -> TF_linkage(StringRef linkageType, TranslationUnit forms);

  // linkage spec with one form and no braces; it turns out this has
  // different semantics [cppstd 7.5 para 7]
  -> TF_one_linkage(StringRef linkageType, TopForm form);

  // assembly directive at toplevel
  -> TF_asm(E_stringLit text);
}


// ----------------------- function -------------------------
// a function definition (toplevel or class member)
class Function (
  DeclFlags dflags,             // static, extern, etc.

  TypeSpecifier retspec,        // type specifier for return value

  Declarator nameAndParams,     // 1. remainder of return value type
                                // 2. name of function
                                // 3. names/types of parameters

  FakeList<MemberInit> *inits,  // (for ctors only) member initialization list

  S_compound body,              // body of function

  FakeList<Handler> *handlers   // handlers for ctor "try" block
);

class MemberInit (
  PQName name,                   // name of member or base class
  FakeList<ICExpression> *args   // arguments to its constructor
) {
  // standard way to make it possible to include something
  // in a FakeList; this line is repeated below in several places
  public MemberInit *next;  ctor next=NULL;     // FakeList link
}


// --------------- types and declarators ---------------
// variable declaration or definition, or function declaration
class Declaration (
  enum DeclFlags dflags,               // typedef, virtual, extern, etc.
  TypeSpecifier spec,                  // e.g. "int"
  FakeList<Declarator> *decllist       // e.g. "x=3, y"
);


// just one complete type; appears in parameter decls and in casts; the
// main difference between an ASTTypeId and a Declaration is that the
// former can have only one declarator, while the latter can have several
class ASTTypeId (
  TypeSpecifier spec,        // "int"
  Declarator decl            // this will be abstract sometimes (e.g. casts)
) {
  // FakeList link; use setNext
  public ASTTypeId *next;  ctor next=NULL;
  public void setNext(ASTTypeId *newNext);

  // ambiguity representation
  public ASTTypeId *ambiguity; ctor ambiguity=NULL;
  public void addAmbiguity(ASTTypeId *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }
}

// a name with optional class qualifiers (PQ: "possibly qualified");
// if the first qualifier's 'qualifier' name is NULL, then it means
// there was a leading "::" symbol; each level of qualification has a
// 'loc' because each level is a remote reference to some entity, and
// that lookup might fail
class PQName(SourceLoc loc) {
  public bool hasQualifiers() const { return isPQ_qualifier(); };

  public string qualifierString() const;
  public string toString() const;
  public friend stringBuilder& operator<< (stringBuilder &sb, PQName const &obj);
  public friend ostream& operator<< (ostream &os, PQName const &obj) { return os << obj.toString(); };

  // retrieve a StringRef for the underlying name, be it a PQ_name or
  // a PQ_operator
  pure_virtual StringRef getName() const;

  // get the PQName at the bottom of any qualifiers
  public PQName const *getUnqualifiedNameC() const;
  public PQName *getUnqualifiedName()
    { return const_cast<PQName*>(getUnqualifiedNameC()); };


  // outer qualifier applied to some inner PQName, plus an optional
  // list of template arguments to the qualifier
  -> PQ_qualifier(StringRef /*nullable*/qualifier, 
                  FakeList<TemplateArgument> *targs,
                  PQName rest);

  // final name, when it's an ordinary identifier
  // NOTE: 'name' here is *never* NULL--instead, I use NULL
  // PQName pointers in abstract declarators
  -> PQ_name(StringRef name);

  // "operator" names; 'o' has the full info, while 'fakeName' is
  // for getName(), which is sometimes used for string maps
  -> PQ_operator(OperatorName o, StringRef fakeName);

  // template instances: a template function or class name, plus
  // some template arguments
  -> PQ_template(StringRef name, FakeList<TemplateArgument> *args);
}


// a name of an "atomic" type--one to which type constructors
// (e.g. '*') can be applied, but which itself is not syntactically
// built with type constructors (typedef'd types may have been built
// with type constructors when the name was defined, but a
// TypeSpecifier refers only to the name)
class TypeSpecifier(SourceLoc loc) {
  public enum CVFlags cv;  ctor cv=CV_NONE;
  custom clone { ret->cv = cv; }

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // a typedef'd name (typedef might be implicit, as for classes);
  // if 'typenamedUsed' is true, then the user said "typename", so
  // we don't regard an error as disambiguating
  -> TS_name(PQName name, bool typenameUsed);

  -> TS_simple(SimpleTypeId id);           // int or char or float or ..

  -> TS_elaborated(                        // "class Foo"
       TypeIntr keyword,
       PQName name
     );

  // class/struct/union definition
  -> TS_classSpec(                         // "class { ... }"
       TypeIntr keyword,                     // "class", "struct", "union"

       // 'name' is the user-provided name, if any.
       // Why is this a PQName instead of just a StringRef?
       //   - it could be a template specialization, and therefore
       //     has template arguments
       //   - it could be a definition or specialization of a class
       //     declared in another namespace
       // See cppstd 14.5.4 para 6 for an example of both at once.
       PQName /*nullable*/ name,

       FakeList<BaseClassSpec> *bases,       // base classes
       MemberList members                    // field and methods of the class
     );

  -> TS_enumSpec(                          // "enum { ... }"
       StringRef /*nullable*/ name,          // name of enum, if any
       FakeList<Enumerator> *elts            // elements of the enumeration
     );
}

// base class specification
class BaseClassSpec (
  bool isVirtual,                       // true for virtual base classes
  AccessKeyword access,                 // public/protected/private
  PQName name                           // name of base class
) {
  public BaseClassSpec *next;  ctor next=NULL;     // FakeList link
}

// a binding of a name to a constant value
class Enumerator (
  SourceLoc loc,                        // location
  StringRef name,                       // name of this constant
  Expression /*nullable*/ expr          // constant expr, or NULL for "next"
) {
  public Enumerator *next;  ctor next=NULL;     // FakeList link
}


// list of class members; this is encapsulated so I can use
// ASTList without yielding ASTLists in cc.gr
class MemberList (ASTList<Member> list);

// member of a class
class Member (SourceLoc loc) {
  -> MR_decl(Declaration d);            // data members or functions w/o bodies
  -> MR_func(Function f);               // function with body
  -> MR_access(AccessKeyword k);        // section header
  -> MR_publish(PQName name);           // publish a superclass member
}


// Syntactically, a Declarator introduces a name of a declared thing,
// and also optionally adds type constructors to the base type of the
// specifier.  It may have an initializing expression, depending on
// the context.
class Declarator (
  IDeclarator decl,                    // syntax of type designation
  Initializer init                     // (nullable) optional data initializer
) {
  // FakeList link; use 'setNext' to set 'next'
  public Declarator *next;  ctor next=NULL;
  public void setNext(Declarator *newNext);

  // ambiguity representation
  public Declarator *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(Declarator *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  // dig down and find the name being declared; may return NULL
  public PQName const *getDeclaratorId() const;
}


// inner declarator; things *recursively* buried inside declarators;
// cannot have initializers; the internal structure is not analyzed
// once typechecking determines what type is denoted;
// type constructors are encoded as a (possibly empty) list of pointer
// constructors, then maybe a function or array type, recursively
class IDeclarator(SourceLoc loc) {
  // dig down and find the name being declared; may return NULL
  pure_virtual PQName const *getDeclaratorId() const;

  // skip any toplevel grouping operators
  public IDeclarator *skipGroups();

  // "x" (NULL means abstract declarator or anonymous parameter);
  // this is used for ctors and dtors as well as ordinary names
  // (dtor names start with "~"); it's also used for operator names
  -> D_name(PQName /*nullable*/ name);

  // "*x" (as in "int *x")
  -> D_pointer(bool isPtr,  // true for "*", false for "&"
               CVFlags cv,  // optional qualifiers applied to ptr/ref type
               IDeclarator base);

  // "f(int)"
  -> D_func(IDeclarator base,                       // D_name of function, typically
            FakeList<ASTTypeId> *params,            // params with optional default values
            CVFlags cv,                             // optional "const" for member functions
            ExceptionSpec /*nullable*/ exnSpec);    // throwable exceptions

  // "a[5]" or "b[]"
  -> D_array(IDeclarator base, Expression /*nullable*/ size);

  // "c : 2"
  //
  // I use a PQName here instead of a StringRef for uniformity
  // (so every IDeclarator ends with a PQName); there are never
  // qualifiers on a bitfield name
  -> D_bitfield(PQName /*nullable*/ name, Expression bits);

  // "X::*p"
  // I don't unify this with D_pointer because ptr-to-member requires
  // an extra field (nestedName), and ptr-to-member is rare
  -> D_ptrToMember(PQName nestedName, CVFlags cv, IDeclarator base);

  // declarator grouping operator: it's semantically irrelevant
  // (i.e. equivalent to just 'base' alone), but plays a role in
  // disambiguation
  -> D_grouping(IDeclarator base);
}

// specification of what a function can throw; if an ExceptionSpec
// pointer is NULL, it means there is no specification, i.e. anything
// can be thrown
class ExceptionSpec (
  FakeList<ASTTypeId> *types       // list of allowable types; might be empty (NULL)
);

// names for operator and conversion functions
class OperatorName {
  // render the operator as a string, for use with string-based maps
  pure_virtual char const *getOperatorName() const;

  // operator new & delete (see note at end about SpecialDeclarator)
  -> ON_newDel(bool isNew, bool isArray);

  // binary operator; since the declarator parser won't
  // know whether "+" and "-" are being overloaded as unary
  // or binary (since it won't count arguments or know
  // whether it's in a class context), "+" and "-" are always
  // classified as ON_binary even when in fact unary; op
  // will never be BIN_DOT_STAR nor BIN_ASSIGN
  -> ON_binary(BinaryOp op);

  // unary operator; only "!" and "~" are classified this way
  -> ON_unary(UnaryOp op);

  // ++ or --; since declarator parser doesn't know about
  // the arguments, this is always EFF_PREINC or EFF_PREDEC
  // even when in fact the "post" version is being overloaded
  -> ON_effect(EffectOp op);

  // assignment; compound if op != BIN_ASSIGN
  -> ON_assign(BinaryOp op);

  // remaining misc ops not captured above
  -> ON_overload(OverloadableOp op);


  // conversion operator to convert to 'type'; type will always have an
  // abstract declarator, with only pointer-type constructors (if any)
  -> ON_conversion(ASTTypeId type);
}


// ------------------- statements -----------------
class Statement (SourceLoc loc) {
  // represent ambiguous statements by forming a linked list of alternatives
  public Statement * const ambiguity;
  ctor const_cast<Statement*&>(ambiguity) = NULL;
  public void addAmbiguity(Statement *alt);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  public string lineColString() const;      // e.g. "4:5"
  public string kindLocString() const;      // e.g. "S_if@4:5"

  -> S_skip();      // nop; used whenever optional Statement is not present
  -> S_label(StringRef name, Statement s);
  -> S_case(Expression expr, Statement s);
  -> S_default(Statement s);
  -> S_expr(Expression expr);       // expression evaluated for side effect
  -> S_compound(ASTList<Statement> stmts);        // using ASTList for performance, I never yield it in cc.gr
  -> S_if(Condition cond, Statement thenBranch, Statement elseBranch);
  -> S_switch(Condition cond, Statement branches);
  -> S_while(Condition cond, Statement body);
  -> S_doWhile(Statement body, Expression expr);  // note: 'expr' is not a Condition
  -> S_for(Statement init, Condition cond,
           Expression after, Statement body);
  -> S_break();
  -> S_continue();
  -> S_return(Expression /*nullable*/ expr);
  -> S_goto(StringRef target);
  -> S_decl(Declaration decl);
  -> S_try(Statement body, FakeList<Handler> *handlers);
  -> S_asm(E_stringLit text);
}

// condition expression in a control-flow statement; it's allowed
// to declare a variable that will hold the condition's value for
// the duration of the substatement(s)
class Condition {
  -> CN_expr(Expression expr);      // simple expression
  -> CN_decl(ASTTypeId typeId);     // type, name, & initializer (must all be present)
}

// exception handler
class Handler (                     
  // type of exception objects this handler catches; note that it
  // might be ST_ELLIPSIS, which corresponds to the "..." syntax
  ASTTypeId typeId,
                                    
  // code to run when handler catches an exception
  Statement body
) {
  public Handler *next;  ctor next=NULL;      // FakeList link
  
  // test whether this is the "..." handler; in this case, at the
  // moment, the type checker will make a type with ST_ELLIPSIS in
  // it, but ideally an analysis should not rely on this, and instead
  // check and handle 'isEllipsis' directly without looking further
  // at 'typeId' (because ST_ELLIPSIS is a hack)
  public bool isEllipsis() const;
}


// ----------------- expressions -----------------
// C expressions
class Expression {
  // NOTE: we never make lists of Expressions, only of ICExpressions

  // same as we do for statements
  public Expression *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(Expression *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  -> E_boolLit(bool b);
  
  // most of the literals are handled by simply storing the textual
  // representation the user typed in, including delimiters like
  // quotes; the tcheck pass could interpret those if desired (and
  // does in some cases); concatenation of string literals is handled
  // by making a continuation list
  -> E_intLit(StringRef text);
  -> E_floatLit(StringRef text);
  -> E_stringLit(StringRef text, E_stringLit continuation = NULL);
  -> E_charLit(StringRef text);

  // variable reference; 'name' might be "this"
  // 5/19/03: 'loc' field removed because 'name' has a location
  -> E_variable(PQName name);

  -> E_funCall(Expression func, FakeList<ICExpression> *args);

  // call to constructor as an expression; the expression's overall
  // type says which type is being constructed
  -> E_constructor(TypeSpecifier spec, FakeList<ICExpression> *args);

  // field within an object; as a special case, fieldName might begin
  // with "~", meaning we're naming the destructor
  -> E_fieldAcc(Expression obj, PQName fieldName);

  -> E_sizeof(Expression expr);

  -> E_unary(UnaryOp op, Expression expr);
  -> E_effect(EffectOp op, Expression expr);
  -> E_binary(Expression e1, BinaryOp op, Expression e2);

  -> E_addrOf(Expression expr);
  -> E_deref(Expression ptr);

  -> E_cast(ASTTypeId ctype, Expression expr);
  -> E_cond(Expression cond, Expression th, Expression el);
  //-> E_gnuCond(Expression cond, Expression el);
  -> E_comma(Expression e1, Expression e2);
  -> E_sizeofType(ASTTypeId atype);

  // this is a simple assignment if op==BIN_ASSIGN, otherwise it's an
  // incremental assignment, like a += 3 (e.g. for op=BIN_PLUS)
  -> E_assign(Expression target, BinaryOp op, Expression src);

  -> E_new(bool colonColon,                      // true if "::" preceeds "new"
           FakeList<ICExpression> *placementArgs,// arguments to placement-new (empty/NULL if no placement syntax)
           ASTTypeId atype,                      // type to allocate
           ICExpressionListOpt ctorArgs);        // arguments to type's constructor (NULL if no ctor call syntax)

  -> E_delete(bool colonColon,                   // true if "::" preceeds "delete"
              bool array,                        // true if "[]" follows "delete"
              Expression expr);                  // address of obj to deallocate

  -> E_throw(Expression /*nullable*/ expr);

  -> E_keywordCast(CastKeyword key,              // dynamic_cast, static_cast, etc.
                   ASTTypeId ctype,              // type to cast to
                   Expression expr);             // expression being cast

  -> E_typeidExpr(Expression expr);
  -> E_typeidType(ASTTypeId ttype);

  // for syntactic disambiguation of angle brackets; E_grouping
  // is a pair of grouping parentheses
  -> E_grouping(Expression expr);
}


// implicit conversion, then Expression; the type checker will fill
// in which implicit conversion (if any) takes place (cc_tcheck.ast
// adds the 'ic' field); it's basically a level of indirection at
// key places where implicit conversions are possible
class ICExpression(Expression expr) {
  // FakeList link
  public ICExpression *next;  ctor next=NULL;
  public void setNext(ICExpression *newNext);
}


// this is used for cases where there is a difference between a list
// with no elements, and no list at all (the latter is represented by
// a NULL pointer to an ICExpressionListOpt, while the former is a valid
// ICExpressionListOpt with a NULL 'list' field)
class ICExpressionListOpt (
  FakeList<ICExpression> *list
);


// animals which appear after declarations to assign initial values
class Initializer (SourceLoc loc) {
  public Initializer *next;  ctor next=NULL;       // FakeList link

  // simple initializer, like "int x = 3"
  -> IN_expr(Expression e);

  // compound initializer, like "int x[4] = { 1,2,3,4 };
  // using ASTList for performance; some files have initializers
  // with thousands of elements
  -> IN_compound(ASTList<Initializer> inits);

  // constructor initializer, like "int x(3);"
  -> IN_ctor(FakeList<ICExpression> *args);
}


// ------------------- templates -------------------
// wrap some template parameters on a declaration or function
class TemplateDeclaration (
  FakeList<TemplateParameter> *params
) {
  // declare a template function
  -> TD_func(Function f);

  // declare a template function prototype
  -> TD_proto(Declaration d);

  // declare a template class; 'spec' could either be a
  // TS_elaborated (forward decl) or a TS_classSpec (definition)
  -> TD_class(TypeSpecifier spec);
}

// one of the parameters to a template declaration
class TemplateParameter (SourceLoc loc) {
  public TemplateParameter *next;  ctor next=NULL;   // FakeList link

  // type parameter; when present, 'name' is what the template code
  // will use to refer to the actual argument type; when present,
  // 'defaultType' provides a default argument
  -> TP_type(StringRef /*nullable*/ name,
             ASTTypeId /*nullable*/ defaultType);

  // non-type paramters
  -> TP_nontype(ASTTypeId param);
}


// one of the arguments to a template instantiation
class TemplateArgument {
  // FakeList link, same as Expressions
  public TemplateArgument *next;  ctor next=NULL;
  public void setNext(TemplateArgument *newNext);

  // also same as Expressions
  public TemplateArgument *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(TemplateArgument *alternative);
  custom traverse { if (ambiguity) ambiguity->traverse(vis); }

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }

  // return a canonical string for this template argument,
  // such that different arguments get different strings
  pure_virtual string argString() const;

  // type argument, corresponds to a TP_type parameter
  -> TA_type(ASTTypeId type);

  // non-type arguments, corresponds to a TP_nontype parameter
  -> TA_nontype(Expression expr);
}

verbatim {                                                     
  // render template arguments between angle brackets
  string targsToString(FakeList<TemplateArgument> const *list);
}


// --------------------- notes ------------------

/* 
  SpecialDeclarator:

  Why split out the various overloadable operators (c++ spec section
  A.11) into various ON_XXX classes, instead of using just one
  ON_overload?  Well, in any case, code which interprets overloaded
  operator declarators will have to map to/from the other operator
  names, so reusing those names may simplify some of that code.  Also,
  reuse means I get debug printing for free.  Finally, it's easy to
  write a simple is-overload test for SimpleDeclarator, which
  accomplishes everything that aggregating them would.
*/

