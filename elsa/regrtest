#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
skipdiagnose=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
logfile=regrtest.log
rm -f $logfile

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $logfile
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
#
# This isn't really intended for "here's a test that must fail", but
# rather "here's a test that does fail right now, but we want to
# eventually fix it".  The former can be handled using multitest.pl,
# or a similar mechanism for inverting the test sense.
failTest() {
  reason="$1"
  shift
  
  if [ "$reason" = "" ]; then
    echo "failTest $*: must supply a failure reason"
    exit 4
  fi

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] GOOD NEWS: A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------

# flags to pass; $TR_EXTRA is here so I can put additional tracing
# flags into this command from the command line, to test them across
# all my test inputs; by default it expands to "", and hence has no
# effect
TR_FLAGS=doOverload,mustBeUnambiguous$TR_EXTRA
#TR_FLAGS=doOverload,doOperatorOverload,mustBeUnambiguous$TR_EXTRA

# NOTE: I've recently changed the 'trace' module to additionally be
# sensitive to the "TRACE" environment variable, so that's another
# (and more general) way to add flags globally.

# by using shell functions we can make it easy to comment-out
# or change to 'fail' status those tests that are not working at
# some given time
testparse() {
  runTest perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/$1
}
testparse_strict() {
  # this is for tests that include things that should be diagnosed
  # as errors, but (for the moment) require the "strict" flag for
  # that to occur
  runTest perl ./multitest.pl ./ccparse -tr strict,doOperatorOverload,$TR_FLAGS in/$1
}
testparse_KandR() {
  runTest perl ./multitest.pl ./ccparse -tr gnu_kandr_c_lang,doOperatorOverload,$TR_FLAGS in/$1
}
failparse() {
  if [ "$2" = "" ]; then
    echo "failparse $1: failparse takes two arguments"
    exit 4
  fi
  failTest "$2" perl ./multitest.pl ./ccparse -tr shortMTRecDepthLimit,doOperatorOverload,$TR_FLAGS in/$1
}
failparse_strict() {
  failTest "$2" perl ./multitest.pl ./ccparse -tr strict,doOperatorOverload,$TR_FLAGS in/$1
}

# ---- BEGIN: lots of tests ----
# (this block of tests is parsed by another program, so should stick to
# the uniform syntax below)
testparse t0001.cc
testparse t0002.cc
testparse t0003.cc
testparse t0004.cc
testparse t0005.cc
testparse t0006.cc
testparse t0007.cc
testparse t0008.cc
testparse t0009.cc
testparse t0010.cc
testparse t0011.cc
testparse t0012.cc
testparse t0013.cc
testparse t0014.cc
testparse t0014a.cc
testparse t0015.cc
testparse t0016.cc
testparse t0017.cc
testparse t0018.cc
testparse t0019.cc
testparse t0020.cc
testparse t0021.cc
testparse t0022.cc
testparse t0023.cc
testparse t0024.cc
testparse t0025.cc
testparse t0026.cc
testparse t0027.cc
testparse t0028.cc
testparse t0029.cc
testparse t0030.cc
testparse t0030a.cc
testparse t0030b.cc
testparse t0031.cc
testparse t0032.cc
testparse t0033.cc
testparse t0034.cc
testparse t0035.cc
testparse t0036.cc
testparse t0037.cc
testparse t0038.cc
testparse t0039.cc
testparse t0040.cc
testparse t0041.cc
testparse t0042.cc
testparse t0043.cc
testparse t0044.cc
testparse t0045.cc
testparse t0046.cc
testparse t0047.cc
testparse t0048.cc
testparse t0049.cc
testparse t0050.cc
testparse t0051.cc
testparse t0052.cc
testparse t0053.cc
testparse t0054.cc
testparse t0055.cc
testparse t0056.cc
testparse t0057.cc
testparse t0058.cc
testparse t0059.cc
testparse t0060.cc
testparse t0061.cc
testparse t0062.cc
testparse t0063.cc
testparse t0064.cc
testparse t0065.cc
testparse t0066.cc
testparse t0067.cc
testparse t0068.cc
testparse t0069.cc
testparse t0070.cc
testparse t0071.cc
testparse t0072.cc
testparse t0073.cc
testparse t0074.cc
testparse t0075.cc
testparse t0076.cc
testparse t0077.cc
testparse t0078.cc
testparse t0079.cc
testparse t0080.cc
testparse t0081.cc
failparse t0082.cc "grammar hacked to be too restrictive w.r.t. template args"
testparse t0083.cc
testparse t0084.cc
testparse t0085.cc
testparse t0086.cc
testparse t0087.cc
testparse t0088.cc
testparse t0089.cc
testparse t0090.cc
testparse t0091.cc
testparse t0092.cc
testparse t0093.cc
failparse t0094.cc "weird g++ iomanip.h <> syntax"
testparse t0095.cc
testparse t0096.cc
testparse t0097.cc
testparse t0098.cc
testparse t0099.cc
testparse t0100.cc
testparse t0101.cc
testparse t0102.cc
testparse t0103.cc
testparse t0104.cc
testparse t0105.cc
testparse t0106.cc
testparse t0107.cc
testparse t0108.cc
testparse t0108b.cc
testparse t0109.cc
testparse t0110.cc
testparse t0111.cc
testparse t0112.cc
testparse t0113.cc
testparse t0114.cc
testparse t0115.cc
testparse t0116.cc
testparse t0117.cc
testparse t0118.cc
testparse t0119.cc
testparse t0120.cc
testparse t0121.cc
testparse t0122.cc
testparse t0123.cc
testparse t0124.cc
testparse t0125.cc
testparse t0126.cc  # work in progress, so it's ok if it starts failing
testparse t0127.cc
testparse t0128.cc
testparse t0129.cc
testparse t0130.cc
testparse t0131.cc
testparse t0132.cc
testparse t0133.cc
testparse t0134.cc
testparse t0135.cc
testparse t0136.cc
testparse t0137.cc
testparse t0138.cc
testparse t0139.cc
testparse t0140.cc
testparse t0141.cc
testparse t0142.cc
testparse t0143.cc
testparse t0144.cc
testparse t0145.cc
testparse t0146.cc
testparse t0147.cc
testparse t0148.cc
testparse t0149.cc
testparse t0150.cc
testparse t0151.cc
testparse t0152.cc
testparse t0153.cc
testparse t0154.cc
testparse t0155.cc
testparse t0156.cc
testparse t0157.cc
testparse t0158.cc
testparse t0159.cc
testparse t0160.cc
testparse t0161.cc
testparse t0162.cc
testparse t0163.cc
testparse t0164.cc
testparse t0165.cc
testparse t0166.cc
testparse t0167.cc
testparse t0168.cc
testparse t0169.cc
testparse t0170.cc
testparse t0171.cc
testparse t0172.cc
testparse t0173.cc
testparse t0174.cc
testparse t0175.cc
testparse t0176.cc
testparse t0177.cc
testparse t0178.cc
testparse t0179.cc
testparse t0180.cc
testparse t0181.cc
testparse t0182.cc
testparse t0183.cc
testparse t0184.cc
testparse t0185.cc
testparse t0186.cc
testparse t0187.cc
testparse t0188.cc
testparse t0189.cc
testparse t0190.cc
failparse t0191.cc "important: problem with classes nested in template classes"
testparse t0192.cc # used to fail due to "forward template function"
testparse t0193.cc
testparse t0194.cc
testparse t0195.cc
testparse t0196.cc
testparse t0197.cc
testparse t0198.cc
failparse t0199.cc "unimplemented: alpha conv + default arg"
testparse t0200.cc
testparse t0201.cc
testparse t0202.cc
testparse t0203.cc
testparse t0204.cc
testparse t0205.cc
testparse t0206.cc
testparse t0207.cc
testparse t0208.cc
testparse t0209.cc
testparse t0210.cc
testparse t0211.cc
testparse t0212.cc
testparse t0213.cc
testparse t0214.cc
# even g++ won't compile this; I'll bet not legal C++, so no point in testing it
#failparse t0215.cc "(fill in a reason here)"
testparse t0216.cc
testparse t0217.cc
testparse t0218.cc
testparse t0219.cc
testparse t0220.cc
testparse t0221.cc
testparse t0222.cc
testparse t0223.cc
testparse t0224.cc
testparse t0225.cc
testparse t0226.cc
testparse t0227.cc
testparse t0228.cc
# tested below after I can query the gnu flag
#testparse t0228b.cc
testparse t0229.cc
testparse t0230.cc
testparse t0231.cc
testparse t0232.cc
failparse t0233.cc "important: flawed interaction between overloading and instantiation"
testparse t0234.cc
testparse t0235.cc
testparse t0236.cc
testparse t0237.cc
testparse t0238.cc
testparse t0239.cc
testparse t0240.cc
testparse t0241.cc
testparse t0242.cc
testparse t0243.cc
testparse t0244.cc
testparse t0245.cc
testparse t0246.cc
testparse t0247.cc
testparse t0248.cc
testparse t0249.cc
testparse t0250.cc
testparse t0251.cc
testparse t0252.cc
testparse t0253.cc
testparse t0254.cc
testparse t0255.cc
testparse t0256.cc
testparse t0257.cc
testparse_strict t0258.cc
testparse t0259.cc
testparse_strict t0260.cc
testparse t0261.cc
testparse t0262.cc
testparse t0263.cc
testparse t0264.cc
testparse t0265.cc
failparse_strict t0265.cc "<dependent> problem"
testparse t0266.cc
# it's not clear whether t0267.cc is valid C++ or not, no point in testing it here
testparse t0268.cc
testparse t0269.cc
testparse t0270.cc
testparse t0271.cc
testparse t0272.cc
testparse t0273.cc
testparse t0274.cc
testparse t0275.cc
testparse t0276.cc
testparse t0277.cc
testparse t0278.cc
testparse t0279.cc
failparse t0280.cc "overloading + template arg application"

# This test was intended to fail as long as STA_REFERENCE hadn't been
# adequately solved.  However, a recent change has caused this test to
# begin working, even though STA_REFERENCE is still bad.  Since at the
# moment I don't see a quick way to repair the test, I'm just going to
# let it fall silent for now.
testparse t0281.cc

testparse t0282.cc
failparse t0283.cc "no viable candidate (not minimized)"
testparse t0284.cc
testparse t0285.cc
testparse t0286.cc
testparse t0287.cc
failparse t0288.cc "ambiguous function template instantiation (not minimized)"
failparse t0289.cc "repeated using things"
failparse t0290.cc "problem matching definition and decl with <dependent>"
testparse t0291.cc

# another set of tests, generally isolated by Daniel
testparse d0001.cc
testparse d0002.cc
testparse d0003.cc
testparse d0004.cc
testparse d0005.cc
testparse d0006.cc
testparse d0007.cc
testparse d0008.cc
testparse d0009.cc
testparse d0010.cc
testparse d0011.cc
testparse d0012.cc
testparse d0013.cc
testparse d0014.cc
testparse d0015.cc
testparse d0016.cc
testparse d0017.cc
testparse d0018.cc
testparse d0019.cc
testparse d0020.cc
testparse d0021.cc
testparse d0022.cc
testparse d0023.cc
testparse d0024.cc
testparse d0025.cc
testparse d0026.cc
testparse d0027.cc
testparse d0028.cc
testparse d0029.cc
# break
testparse d0032.cc
# break
testparse d0034.cc
testparse d0035.cc
testparse d0036.cc
testparse d0037.cc
testparse d0038.cc
testparse d0039.cc
# d0040.cc and d0041.cc are illegal C++
# d0042.cc through d0045.cc were less cleaned up versions of d0046.cc
testparse d0046.cc
testparse d0046elab.cc
testparse d0047.cc
testparse d0048.cc
testparse d0048elab.cc
testparse d0049.cc
testparse d0050.cc
testparse d0050elab.cc
testparse d0051.cc
testparse d0051elab.cc
testparse d0052.cc
testparse d0053.cc
testparse d0054.cc
testparse d0055.cc
testparse d0056.cc
testparse d0057.cc
testparse d0058.cc
testparse d0059.cc
testparse d0060.cc
testparse d0061.cc

# sm: This is not the intended purpose of 'failparse'!  failparse is
# for things that currently do not work, but are expected to at some
# point in the future.  These two tests are *intended* to fail, which
# is different.  The correct way to do this is to mark certain lines
# with "ERROR(n)".
#
# actually, these aren't valid C++, no point in testing
#failparse d0062.cc "during type matching, recursion depth exceeded the limit"
#failparse d0063.cc "during type matching, recursion depth exceeded the limit"

# the array size is actually there
#  in/d0064.cc:4:37: error: array size must be positive (inst from in/d0064.cc:32:8)
#  testparse d0064.cc
# not sure what this one should do
#  in/d0065.cc:3:34: error: TemplateArgument has no value  ( (I)+ (1))
#  testparse d0065.cc
testparse d0066.cc
testparse d0067.cc
# this one passes, but I'm not sure its right; I think it is
# instantiating the class template A twice since it is a mutant,
# thought perhaps it shouldn't
testparse d0068.cc
testparse d0069.cc
testparse d0070.cc
testparse d0071.cc
testparse d0072.cc
testparse d0073.cc
testparse d0074.cc
testparse d0075.cc
testparse d0079.cc
failparse d0080.cc "important: inheriting from dependent type"
testparse d0084.cc
testparse d0087.cc
testparse d0088.cc
testparse d0089.cc
testparse d0090.cc
testparse d0091.cc
testparse d0097.cc
testparse d0098.cc
testparse d0099.cc
testparse d0100.cc
testparse d0101.cc
testparse d0102.cc
testparse d0103.cc
testparse d0104.cc
testparse d0105.cc
failparse d0106.cc "can't define static member of a specialization of a class template"
failparse d0107.cc "assertion failure in MatchTypes"
failparse d0108.cc "struct member with the same name as the struct"
failparse d0109.cc "'using' same namespace twice causes error"
failparse d0110.cc "class specialization without 'template' prefix?"
failparse d0111.cc "templatized member type not accessible?"
failparse d0112.cc "some template dependent name problem"
failparse d0113.cc "very strange function call situation that gcc 2.96 likes bug elsa not"
failparse d0114.cc "overloading bug"
failparse d0115.cc "cannot find standard namespace"
# ---- END: lots of tests ----


# this hacky variation of t0151.cc *does* work
runTest perl ./multitest.pl ./five-errors -tr doOperatorOverload in/t0151.cc

# examples from C++ standard
#
# a few examples have parts commented-out:
#   7.3.3c.cc: nerfed because member templates aren't implemented
#   7.3.3f.cc: "int i; int i;" is supposed to be allowed
#   7.3.3k.cc: I don't detect a purported ambiguity
#   7.3.4e.cc: major design flaw: cannot return sets from lookup functions
#   (more from before I started maintaining this list)
for fn in in/std/*.cc; do
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS "$fn"
done

# more in another (private) repository, if present
if [ -f ../cppstdex/regrtest_inner ]; then
  source ../cppstdex/regrtest_inner
fi

# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +yes" config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi
                
if $use_gnu; then
  # test gnu extensions
  testparse gnu/g0001.cc
  testparse gnu/g0002.cc
  testparse gnu/g0003.cc
  testparse gnu/g0004.cc
  testparse gnu/g0005.cc
  testparse gnu/g0006.cc
  testparse gnu/g0007.cc
  testparse gnu/g0008.cc
  # g0009.c is a C test
  testparse gnu/g0010.cc
  testparse gnu/g0011.cc
  testparse gnu/g0012.cc
  testparse gnu/g0013.cc
  testparse gnu/g0014.cc

  testparse gnu/t0124.cc
  testparse gnu/t0125.cc
  testparse gnu/t0127.cc
  testparse gnu/t0128.cc
  testparse gnu/t0129.cc
  testparse gnu/t0130.cc
  testparse gnu/t0131.cc
  testparse gnu/t0132.cc

  testparse gnu/d0076.cc
  testparse gnu/d0078.cc
  testparse gnu/d0081.cc
  testparse gnu/d0082.cc
  testparse gnu/d0085.cc
  testparse gnu/d0086.cc
  testparse gnu/d0089.cc
  testparse gnu/d0092.cc
  testparse gnu/d0093.cc
  testparse gnu/d0094.cc

  # test c99 extensions
  for fn in in/c99/*.c; do
    runTest ./ccparse -tr $TR_FLAGS "$fn"
  done

else # tests that only pass when not in gnu mode
  testparse t0228b.cc

fi   # end of 'if $use_gnu; then'

# idempotency checks; known problems:
#   25: Scope operator not being printed before using type.
#   27, 28: Templates not being printed correctly when the template
#           arguments are used within the template.
#   30: scope not printing.
#   34: template arguments to a class, such as "A<T>", get printed as
#       "template <class T> class A" instead
#   35, 36: template <class ...> gets dropped
#   t0033, t0105: trivial whitespace error prob due to elaboration modifying the ast
# note that the 'sed' command includes a literal tab character..

# template modifications broke pretty printing having to do with
# templates
#   26: "template<...>" prefix to function not printing, I think

list=`echo " \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc
  t0021.cc   t0022.cc  t0023.cc  t0024.cc              
             t0029.cc            t0030a.cc  t0030b.cc  t0031.cc  t0032.cc
                                            t0037.cc   t0038.cc  t0039.cc
  t0040.cc   t0041.cc  t0042.cc  t0043.cc
                                            t0100.cc   t0101.cc  t0102.cc
                                 t0106.cc
                                                                 t0123.cc \
  " | fmt -1 | sed 's|^[ 	]*|in/|'`

runTest perl ./idemcheck -d outdir $list

if $use_gnu; then
  #   125: inline assembly not printed
  #   126: attributes not printed
  #   127: typeof not printed
  #   t0130: trivial whitespace error prob due to elaboration modifying the ast
  # note that the 'sed' command includes a literal tab character..
  list=`echo " \
    gnu/t0124.cc
    gnu/t0128.cc
    gnu/t0129.cc
    gnu/t0131.cc
    gnu/t0132.cc
    c99/t0133.c  \
    " | fmt -1 | sed 's|^[ 	]*|in/|'`
  runTest perl ./idemcheck -d outdir $list
fi


# test the parser in C mode
testCparse() {
  runTest perl ./multitest.pl ./ccparse -tr c_lang in/c/$1
}
testCparse t0001.c
testCparse t0002.c
testCparse t0003.c
testCparse t0004.c
testCparse t0005.c
testCparse t0006.c
testCparse t0007.c
testCparse t0008.c


# test GNU C
if $use_gnu; then
  runTest ./ccparse -tr c_lang in/gnu/g0009.c
  runTest ./ccparse -tr c_lang in/gnu/d0083.c
  runTest ./ccparse -tr c_lang in/gnu/t0126.c

  testparse gnu/d0095.c
  failparse gnu/dC0001.c "hex floating-point literals"
  # FIX: I think this is K&R specific, not gnu specific, so should be
  # in a different K&R section
  testparse_KandR gnu/d0096.c

  # attribute tests
  runTest ./ccparse -tr c_lang in/gnu/attr01.c
  runTest ./ccparse -tr c_lang in/gnu/attr02.c
  runTest ./ccparse -tr c_lang in/gnu/d0099.c
                                           
  # asm tests
  runTest ./ccparse -tr c_lang in/gnu/asm01.c

  # tests (primarily for __attribute__) from CIL
  testcil() {
    runTest ./ccparse -tr c_lang in/gnu/cil/$1
  }
  failcil() {
    failTest "$2" ./ccparse -tr c_lang in/gnu/cil/$1
  }

  testcil align1.i
  testcil align2.i
  testcil attr2.i
  testcil attr3.i
  testcil attr4.i
  testcil attr5.i
  testcil attr6.i
  testcil bind-zero.i
  testcil combine_samefn_1.i
  failcil decl1.i "can add volatile later"
  testcil enumattr.i
  testcil globalprob.i
  testcil init8.i
  testcil invalredef.i
  testcil mode_sizes.i
  testcil regparm0.i
  testcil rmtmps-attr.i
  testcil rmtmps2.i
  testcil sockaddr.i
  testcil structattr.i
  testcil structattr2.i
  testcil structattr3.i
  testcil transpunion.i
  failcil typeof1.i "something weird"
  testcil warnings-noreturn.i
fi


# final parser checks against the big files, since they've now become
# my performance measurement files
$MAKE in/big

testnsparse() {
  # don't try operator overload resolution, it doesn't work for them (?)
  runTest ./ccparse -tr $TR_FLAGS "$1"
}
failnsparse() {
  failTest "$2" ./ccparse -tr $TR_FLAGS "$1"
}

# put shorter tests first
testnsparse in/big/nonport.i

testnsparse in/big/nsUnicodeToTeXCMRt1.i
testnsparse in/big/nsAtomTable.i
testnsparse in/big/nsSOAPPropertyBag.i
testnsparse in/big/nsCLiveconnectFactory.i
testnsparse in/big/nsHTMLEditRules.i
testnsparse in/big/nsMsgServiceProvider.i



# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "Successful tests               :    $success"
echo "Failed as expected (known bugs):    $failure"
if [ $skipdiagnose -ne 0 ]; then
  echo "Failure to diagnose errors     :    $skipdiagnose"
fi
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$logfile" ]; then
    cat "$logfile"
  fi
fi

