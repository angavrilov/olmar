#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
skipdiagnose=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
logfile=regrtest.log
rm -f $logfile

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $logfile
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
#
# This isn't really intended for "here's a test that must fail", but
# rather "here's a test that does fail right now, but we want to
# eventually fix it".  The former can be handled using multitest.pl,
# or a similar mechanism for inverting the test sense.
failTest() {
  reason="$1"
  shift
  
  if [ "$reason" = "" ]; then
    echo "failTest $*: must supply a failure reason"
    exit 4
  fi

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] GOOD NEWS: A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------

# flags to pass; $TR_EXTRA is here so I can put additional tracing
# flags into this command from the command line, to test them across
# all my test inputs; by default it expands to "", and hence has no
# effect
TR_FLAGS=mustBeUnambiguous$TR_EXTRA

# NOTE: I've recently changed the 'trace' module to additionally be
# sensitive to the "TRACE" environment variable, so that's another
# (and more general) way to add flags globally.

# by using shell functions we can make it easy to comment-out
# or change to 'fail' status those tests that are not working at
# some given time
testparse() {
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS in/$1
}
testparse_strict() {
  # this is for tests that include things that should be diagnosed
  # as errors, but (for the moment) require the "strict" flag for
  # that to occur
  runTest perl ./multitest.pl ./ccparse -tr strict,$TR_FLAGS in/$1
}

failparse() {
  if [ "$2" = "" ]; then
    echo "failparse $1: failparse takes two arguments"
    exit 4
  fi
  failTest "$2" perl ./multitest.pl ./ccparse -tr shortMTRecDepthLimit,$TR_FLAGS in/$1
}
failparse_strict() {
  failTest "$2" perl ./multitest.pl ./ccparse -tr strict,$TR_FLAGS in/$1
}

# ---- BEGIN: lots of tests ----
# (this block of tests is parsed by another program, so should stick to
# the uniform syntax below)
testparse t0001.cc
testparse t0002.cc
testparse t0003.cc
testparse t0004.cc
testparse t0005.cc
testparse t0006.cc
testparse t0007.cc
testparse t0008.cc
testparse t0009.cc
testparse t0010.cc
testparse t0011.cc
testparse t0012.cc
testparse t0013.cc
testparse t0014.cc
testparse t0014a.cc
testparse t0015.cc
testparse t0016.cc
testparse t0017.cc
testparse t0018.cc
testparse t0019.cc
testparse t0020.cc
testparse t0021.cc
testparse t0022.cc
testparse t0023.cc
testparse t0024.cc
testparse t0025.cc
testparse t0026.cc
testparse t0027.cc
testparse t0028.cc
testparse t0029.cc
testparse t0030.cc
testparse t0030a.cc
testparse t0030b.cc
testparse t0031.cc
testparse t0032.cc
testparse t0033.cc
testparse t0034.cc
testparse t0035.cc
testparse t0036.cc
testparse t0037.cc
testparse t0038.cc
testparse t0039.cc
testparse t0040.cc
testparse t0041.cc
testparse t0042.cc
testparse t0043.cc
testparse t0044.cc
testparse t0045.cc
testparse t0046.cc
testparse t0047.cc
testparse t0048.cc
testparse t0049.cc
testparse t0050.cc
testparse t0051.cc
testparse t0052.cc
testparse t0053.cc
testparse t0054.cc
testparse t0055.cc
testparse t0056.cc
testparse t0057.cc
testparse t0058.cc
testparse t0059.cc
testparse t0060.cc
testparse t0061.cc
testparse t0062.cc
testparse t0063.cc
testparse t0064.cc
testparse t0065.cc
testparse t0066.cc
testparse t0067.cc
testparse t0068.cc
testparse t0069.cc
testparse t0070.cc
testparse t0071.cc
testparse t0072.cc
testparse t0073.cc
testparse t0074.cc
testparse t0075.cc
testparse t0076.cc
testparse t0077.cc
testparse t0078.cc
testparse t0079.cc
testparse t0080.cc
testparse t0081.cc
failparse t0082.cc "grammar hacked to be too restrictive w.r.t. template args"
testparse t0083.cc
testparse t0084.cc
testparse t0085.cc
testparse t0086.cc
testparse t0087.cc
testparse t0088.cc
testparse t0089.cc
testparse t0090.cc
testparse t0091.cc
testparse t0092.cc
testparse t0093.cc
testparse t0094.cc
testparse t0095.cc
testparse t0096.cc
testparse t0097.cc
testparse t0098.cc
testparse t0099.cc
testparse t0100.cc
testparse t0101.cc
testparse t0102.cc
testparse t0103.cc
testparse t0104.cc
testparse t0105.cc
testparse t0106.cc
testparse t0107.cc
testparse t0108.cc
testparse t0108b.cc
testparse t0109.cc
testparse t0110.cc
testparse t0111.cc
testparse t0112.cc
testparse t0113.cc
testparse t0114.cc
testparse t0115.cc
testparse t0116.cc
testparse t0117.cc
testparse t0118.cc
testparse t0119.cc
testparse t0120.cc
testparse t0121.cc
testparse t0122.cc
testparse t0123.cc
testparse t0124.cc
testparse t0125.cc
testparse t0126.cc
testparse t0127.cc
testparse t0128.cc
testparse t0129.cc
testparse t0130.cc
testparse t0131.cc
testparse t0132.cc
testparse t0133.cc
testparse t0134.cc
testparse t0135.cc
testparse t0136.cc
testparse t0137.cc
testparse t0138.cc
testparse t0139.cc
testparse t0140.cc
testparse t0141.cc
testparse t0142.cc
testparse t0143.cc
testparse t0144.cc
testparse t0145.cc
testparse t0146.cc
testparse t0147.cc
testparse t0148.cc
testparse t0149.cc
testparse t0150.cc
testparse t0151.cc
testparse t0152.cc
testparse t0153.cc
testparse t0154.cc
testparse t0155.cc
testparse t0156.cc
testparse t0157.cc
testparse t0158.cc
testparse t0159.cc
testparse t0160.cc
testparse t0161.cc
testparse t0162.cc
testparse t0163.cc
testparse t0164.cc
testparse t0165.cc
testparse t0166.cc
testparse t0167.cc
testparse t0168.cc
testparse t0169.cc
testparse t0170.cc
testparse t0171.cc
testparse t0172.cc
testparse t0173.cc
testparse t0174.cc
testparse t0175.cc
testparse t0176.cc
testparse t0177.cc
testparse t0178.cc
testparse t0179.cc
testparse t0180.cc
testparse t0181.cc
testparse t0182.cc
testparse t0183.cc
testparse t0184.cc
testparse t0185.cc
testparse t0186.cc
testparse t0187.cc
testparse t0188.cc
testparse t0189.cc
testparse t0190.cc
testparse t0191.cc
testparse t0192.cc # used to fail due to "forward template function"
testparse t0193.cc
testparse t0194.cc
testparse t0195.cc
testparse t0196.cc
testparse t0197.cc
testparse t0198.cc
failparse t0199.cc "unimplemented: alpha conv + default arg"
testparse t0200.cc
testparse t0201.cc
testparse t0202.cc
testparse t0203.cc
testparse t0204.cc
testparse t0205.cc
testparse t0206.cc
testparse t0207.cc
testparse t0208.cc
testparse t0209.cc
testparse t0210.cc
testparse t0211.cc
testparse t0212.cc
testparse t0213.cc
testparse t0214.cc
# even g++ won't compile this; I'll bet not legal C++, so no point in testing it
#failparse t0215.cc "(fill in a reason here)"
testparse t0216.cc
testparse t0217.cc
testparse t0218.cc
testparse t0219.cc
testparse t0220.cc
testparse t0221.cc
testparse t0222.cc
testparse t0223.cc
testparse t0224.cc
testparse t0225.cc
testparse t0226.cc
testparse t0227.cc
testparse t0228.cc
# tested below after I can query the gnu flag
#testparse t0228b.cc
testparse t0229.cc
testparse t0230.cc
testparse t0231.cc
testparse t0232.cc
testparse t0233.cc
testparse t0234.cc
testparse t0235.cc
testparse t0236.cc
testparse t0237.cc
testparse t0238.cc
testparse t0239.cc
testparse t0240.cc
testparse t0241.cc
testparse t0242.cc
testparse t0243.cc
testparse t0244.cc
testparse t0245.cc
testparse t0246.cc
testparse t0247.cc
testparse t0248.cc
testparse t0249.cc
testparse t0250.cc
testparse t0251.cc
testparse t0252.cc
testparse t0253.cc
testparse t0254.cc
testparse t0255.cc
testparse t0256.cc
testparse t0257.cc
testparse_strict t0258.cc
testparse t0259.cc
testparse_strict t0260.cc
testparse t0261.cc
testparse t0262.cc
testparse t0263.cc
testparse t0264.cc
testparse t0265.cc
failparse_strict t0265.cc "<dependent> problem"
testparse t0266.cc
# it's not clear whether t0267.cc is valid C++ or not, no point in testing it here
testparse t0268.cc
testparse t0269.cc
testparse t0270.cc
testparse t0271.cc
testparse t0272.cc
testparse t0273.cc
testparse t0274.cc
testparse t0275.cc
testparse t0276.cc
testparse t0277.cc
testparse t0278.cc
testparse t0279.cc
testparse t0280.cc

# This test was intended to fail as long as STA_REFERENCE hadn't been
# adequately solved.  However, a recent change has caused this test to
# begin working, even though STA_REFERENCE is still bad.  Since at the
# moment I don't see a quick way to repair the test, I'm just going to
# let it fall silent for now.
testparse t0281.cc

testparse t0282.cc
testparse t0283.cc
testparse t0284.cc
testparse t0285.cc
testparse t0286.cc
testparse t0287.cc
failparse t0288.cc "ambiguous function template instantiation (not minimized)"
testparse t0289.cc # "repeated using declarations"
failparse t0290.cc "problem matching definition and decl with <dependent>"
testparse t0291.cc
testparse t0292.cc
testparse t0293.cc
testparse t0294.cc
testparse t0295.cc
testparse t0296.cc
testparse t0297.cc
testparse t0298.cc
testparse t0299.cc
testparse t0300.cc
testparse t0301.cc
testparse t0302.cc
testparse t0303.cc
testparse t0304.cc
testparse t0305.cc
testparse t0306.cc
testparse t0307.cc
testparse t0308.cc
testparse t0309.cc
testparse t0310.cc
testparse t0311.cc
testparse t0312.cc
testparse t0313.cc
testparse t0314.cc
testparse t0315.cc
testparse t0316.cc
testparse t0317.cc
testparse t0318.cc
testparse t0319.cc
testparse t0320.cc
testparse t0321.cc
testparse t0322.cc
testparse t0323.cc
testparse t0324.cc
testparse t0325.cc
testparse t0326.cc
testparse t0327.cc
testparse t0328.cc
testparse t0329.cc
failparse t0330.cc "member lookup bug causes failure to diagnose bad input"
testparse t0331.cc
testparse t0332.cc
testparse t0333.cc
testparse t0334.cc
testparse t0335.cc
testparse t0336.cc
testparse t0337.cc
testparse t0338.cc
testparse t0339.cc
testparse t0340.cc
testparse t0341.cc
testparse t0342.cc
testparse t0343.cc
testparse t0344.cc
testparse t0345.cc
testparse t0346.cc
testparse t0347.cc
testparse t0348.cc
testparse t0349.cc
testparse t0350.cc
testparse t0351.cc
failparse t0352.cc "cannot parse; nasty example; gcc-3 cannot handle either"
failparse t0353.cc "cannot parse; even nastier example"
testparse t0354.cc
testparse t0355.cc
testparse t0356.cc
testparse t0357.cc
testparse t0358.cc
testparse t0359.cc
testparse t0360.cc
testparse t0361.cc
testparse t0362.cc
testparse t0363.cc
testparse t0364.cc
testparse t0365.cc
testparse t0366.cc
testparse t0367.cc
testparse t0368.cc
testparse t0369.cc
testparse t0370.cc
testparse t0371.cc
testparse t0372.cc
testparse t0373.cc
testparse t0374.cc
testparse t0375.cc
testparse t0376.cc
testparse t0377.cc
failparse t0378.cc "buggy qualified lookup of ~ name"
failparse t0379.cc "buggy qualified lookup involving a typedef"
testparse t0380.cc
failparse t0381.cc "should not allow elaborated type spec to refer to a typedef"
failparse t0382.cc "fail to pull in enum tag from a using directive"
testparse t0383.cc
testparse t0384.cc
testparse t0385.cc
testparse t0386.cc
testparse t0387.cc
testparse t0388.cc
testparse t0389.cc

# another set of tests, generally isolated by Daniel
testparse d0001.cc
testparse d0002.cc
testparse d0003.cc
testparse d0004.cc
testparse d0005.cc
testparse d0006.cc
testparse d0007.cc
testparse d0008.cc
testparse d0009.cc
testparse d0010.cc
testparse d0011.cc
testparse d0012.cc
testparse d0013.cc
testparse d0014.cc
testparse d0015.cc
testparse d0016.cc
testparse d0017.cc
testparse d0018.cc
testparse d0019.cc
testparse d0020.cc
testparse d0021.cc
testparse d0022.cc
testparse d0023.cc
testparse d0024.cc
testparse d0025.cc
testparse d0026.cc
testparse d0027.cc
testparse d0028.cc
testparse d0029.cc
# break
testparse d0032.cc
# break
testparse d0034.cc
testparse d0035.cc
testparse d0036.cc
testparse d0037.cc
testparse d0038.cc
testparse d0039.cc
# d0040.cc and d0041.cc are illegal C++
# d0042.cc through d0045.cc were less cleaned up versions of d0046.cc
testparse d0046.cc
testparse d0046elab.cc
testparse d0047.cc
testparse d0048.cc
testparse d0048elab.cc
testparse d0049.cc
testparse d0050.cc
testparse d0050elab.cc
testparse d0051.cc
testparse d0051elab.cc
testparse d0052.cc
testparse d0053.cc
testparse d0054.cc
testparse d0055.cc
testparse d0056.cc
testparse d0057.cc
testparse d0058.cc
testparse d0059.cc
testparse d0060.cc
testparse d0061.cc
# these aren't valid C++, no point in testing
#failparse d0062.cc "during type matching, recursion depth exceeded the limit"
#failparse d0063.cc "during type matching, recursion depth exceeded the limit"
testparse d0064.cc
testparse d0065.cc
testparse d0066.cc
testparse d0067.cc
testparse d0068.cc
testparse d0069.cc
testparse d0070.cc
testparse d0071.cc
testparse d0072.cc
testparse d0073.cc
testparse d0074.cc
testparse d0075.cc
testparse d0079.cc
testparse d0080.cc # "inheriting from dependent qualified type"
testparse d0084.cc
testparse_strict d0087.cc
testparse d0088.cc
testparse d0089.cc
testparse d0090.cc
testparse d0091.cc
testparse d0097.cc
testparse d0098.cc
testparse d0099.cc
testparse d0100.cc
testparse d0101.cc
testparse d0102.cc
testparse d0103.cc
testparse d0104.cc
testparse d0105.cc
failparse d0106.cc "gcc-2 bug: missing template <>"
testparse d0107.cc
testparse d0108.cc
testparse d0109.cc # "duplicate 'using' declaration"
failparse d0110.cc "class specialization without 'template' prefix?"
testparse d0111.cc # "failure to use 'typename' when defining static member"
failparse d0112.cc "template dependent name problem"
testparse d0113.cc
failparse d0114.cc "dependent return type prevents associating defn with decl"
# sm: this is invalid input
#failparse d0115.cc "gcc-2 bug: cannot find standard namespace"
testparse d0116.cc
testparse d0117.cc
testparse d0118.cc
testparse d0119.cc
testparse d0120.cc
testparse d0121.cc
# sm: this is invalid C++
#failparse d0123.cc "from the kernel; works in C mode but in C++ mode can't convert void* to function pointer"
testparse d0124.cc
# ---- END: lots of tests ----


# this hacky variation of t0151.cc *does* work
runTest perl ./multitest.pl ./five-errors in/t0151.cc

# examples from C++ standard
#
# a few examples have parts commented-out:
#   7.3.3c.cc: nerfed because member templates aren't implemented
#   7.3.3f.cc: "int i; int i;" is supposed to be allowed
#   7.3.3k.cc: I don't detect a purported ambiguity
#   7.3.4e.cc: major design flaw: cannot return sets from lookup functions
#   (plus more from before I started maintaining this list ...)
rm -f in/std/*.error*.cc
for fn in in/std/*.cc; do
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS "$fn"
done

# more in another (private) repository, if present
if [ -f ../cppstdex/regrtest_inner ]; then
  source ../cppstdex/regrtest_inner
fi

# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +yes" config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi
                
if $use_gnu; then
  # test gnu extensions
  testparse gnu/g0001.cc
  testparse gnu/g0002.cc
  testparse gnu/g0003.cc
  testparse gnu/g0004.cc
  testparse gnu/g0005.cc
  testparse gnu/g0006.cc
  testparse gnu/g0007.cc
  testparse gnu/g0008.cc
  # g0009.c is a C test
  testparse gnu/g0010.cc
  testparse gnu/g0011.cc
  testparse gnu/g0012.cc
  testparse gnu/g0013.cc
  testparse gnu/g0014.cc
  testparse gnu/g0015.cc
  # g0016.cc is documentation, not a test
  testparse gnu/g0017.cc
  testparse gnu/g0018.cc
  testparse gnu/g0019.cc
  # g0020.cc is documentation

  testparse gnu/t0124.cc
  testparse gnu/t0125.cc
  testparse gnu/t0127.cc
  testparse gnu/t0128.cc
  testparse gnu/t0129.cc
  testparse gnu/t0130.cc
  testparse gnu/t0131.cc
  testparse gnu/t0132.cc

  testparse gnu/d0076.cc
  testparse gnu/d0078.cc
  testparse gnu/d0081.cc
  testparse gnu/d0082.cc
  testparse gnu/d0085.cc
  testparse gnu/d0086.cc
  testparse gnu/d0089.cc
  testparse gnu/d0092.cc
  testparse gnu/d0093.cc
  testparse gnu/d0094.cc

  # test c99 extensions
  for fn in in/c99/*.c; do
    runTest ./ccparse -tr c_lang,$TR_FLAGS "$fn"
  done

else # tests that only pass when not in gnu mode
  testparse t0228b.cc

fi   # end of 'if $use_gnu; then'

# idempotency checks; known problems:
#   25: Scope operator not being printed before using type.
#   27, 28: Templates not being printed correctly when the template
#           arguments are used within the template.
#   30: scope not printing.
#   34: template arguments to a class, such as "A<T>", get printed as
#       "template <class T> class A" instead
#   35, 36: template <class ...> gets dropped
#   t0033, t0105: trivial whitespace error prob due to elaboration modifying the ast
# note that the 'sed' command includes a literal tab character..

# template modifications broke pretty printing having to do with
# templates
#   26: "template<...>" prefix to function not printing, I think

list=`echo " \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc
  t0021.cc   t0022.cc  t0023.cc  t0024.cc              
             t0029.cc            t0030a.cc  t0030b.cc  t0031.cc  t0032.cc
                                            t0037.cc   t0038.cc  t0039.cc
  t0040.cc   t0041.cc  t0042.cc  t0043.cc
                                            t0100.cc   t0101.cc  t0102.cc
                                 t0106.cc
                                                                 t0123.cc \
  " | fmt -1 | sed 's|^[ 	]*|in/|'`

runTest perl ./idemcheck -d outdir $list

if $use_gnu; then
  #   125: inline assembly not printed
  #   126: attributes not printed
  #   127: typeof not printed
  #   t0130: trivial whitespace error prob due to elaboration modifying the ast
  # note that the 'sed' command includes a literal tab character..
  list=`echo " \
    gnu/t0124.cc
    gnu/t0128.cc
    gnu/t0129.cc
    gnu/t0131.cc
    gnu/t0132.cc
    c99/t0133.c  \
    " | fmt -1 | sed 's|^[ 	]*|in/|'`
  runTest perl ./idemcheck -d outdir $list
fi


# test the parser in C mode
testCparse() {
  runTest perl ./multitest.pl ./ccparse -tr c_lang in/$1
}
failCparse() {
  if [ "$2" = "" ]; then
    echo "failparse $1: failparse takes two arguments"
    exit 4
  fi
  failTest "$2" perl ./multitest.pl ./ccparse -tr c_lang,shortMTRecDepthLimit,$TR_FLAGS in/$1
}
testCparse c/t0001.c
testCparse c/t0002.c
testCparse c/t0003.c
testCparse c/t0004.c
testCparse c/t0005.c
testCparse c/t0006.c
testCparse c/t0007.c
testCparse c/t0008.c
testCparse c/t0009.c
testCparse c/t0010.c
testCparse c/t0011.c
testCparse c/t0012.c
testCparse c/t0013.c
testCparse c/t0014.c
testCparse c/t0015.c
testCparse c/t0016.c
testCparse c/t0017.c
testCparse c/t0018.c
testCparse gnu/d0096.c
testCparse c/dC0010.c #"f(u8 register) doesn't parse"
testCparse c/dC0011.c #"((size_t) &((struct scsi_cmnd *)0)->q) doesn't const eval"
testCparse c/dC0012.c
testCparse c/dC0013.c #"in C, a member with the same name as a type doesn't shadow the type"
testCparse gnu/d0122.c
testCparse c/d0124b.c


# is K&R built?
use_kandr=false
if egrep "USE_KANDR: +yes" config.summary >/dev/null; then
  use_kandr=true
  echo "K&R extensions are enabled"
else
  echo "K&R extensions are not enabled"
fi

if $use_kandr; then
  # test the parser in C + K&R mode
  testKANDRparse() {
    runTest perl ./multitest.pl ./ccparse -tr gnu_kandr_c_lang in/$1
  }
  testKANDRparse kandr/t0001.c
  testKANDRparse kandr/t0002.c
  testKANDRparse kandr/t0003.c
  testKANDRparse kandr/t0004.c
fi


# test GNU C
if $use_gnu; then
  testCparse gnu/g0009.c
  testCparse gnu/d0083.c
  testCparse gnu/t0126.c
  testCparse gnu/d0095.c
  testCparse gnu/c0001.c

  testCparse gnu/dC0001.c # hex floating-point literals
  testCparse gnu/dC0002.c # arrays of no length are assumed to have one element
  testCparse gnu/dC0003.c # noInnerClasses: use a struct then define it but inside another
  testCparse gnu/dC0004.c # can take address of const E_compoundLit
  testCparse gnu/dC0005.c # extern inline functions
  testCparse gnu/dC0006.c # more places where 0-length arrays are allowed
  testCparse gnu/dC0007.c # case 1 ... 3:
  testCparse gnu/dC0008.c # int a[] = { [1] 0 }; struct A a = { .x 8 };
  testCparse gnu/dC0009.c # UCHAR8 SampleResolution:2 __attribute__ ((packed));
  testCparse gnu/dC0014.c # "'u32 long off' doesn't parse"
  testCparse gnu/dC0015.c # function scope structs can contain arrays of dynamic size
  testCparse gnu/dC0016.c

  # attribute tests
  testCparse gnu/attr01.c
  testCparse gnu/attr02.c
  testCparse gnu/d0099.c

  # asm tests
  testCparse gnu/asm01.c

  # tests (primarily for __attribute__) from CIL
  testcil() {
    runTest ./ccparse -tr c_lang in/gnu/cil/$1
  }
  failcil() {
    failTest "$2" ./ccparse -tr c_lang in/gnu/cil/$1
  }

  testcil align1.i
  testcil align2.i
  testcil attr2.i
  testcil attr3.i
  testcil attr4.i
  testcil attr5.i
  testcil attr6.i
  testcil bind-zero.i
  testcil combine_samefn_1.i
  failcil decl1.i "can add volatile later"
  testcil enumattr.i
  testcil globalprob.i
  testcil init8.i
  testcil invalredef.i
  testcil mode_sizes.i
  testcil regparm0.i
  testcil rmtmps-attr.i
  testcil rmtmps2.i
  testcil sockaddr.i
  testcil structattr.i
  testcil structattr2.i
  testcil structattr3.i
  testcil transpunion.i
  failcil typeof1.i "__alignof__ applied to object instead of type"
  testcil warnings-noreturn.i
fi


# msvc
runTest ./ccparse -tr msvcBugs in/msvc/m0001.cc


# final parser checks against the big files, since they've now become
# my performance measurement files
if $MAKE in/big; then

testnsparse() {
  runTest ./ccparse -tr $TR_FLAGS "$1"
}
failnsparse() {
  failTest "$2" ./ccparse -tr $TR_FLAGS "$1"
}

# put shorter tests first
testnsparse in/big/nonport.i

testnsparse in/big/nsUnicodeToTeXCMRt1.i
testnsparse in/big/nsAtomTable.i
testnsparse in/big/nsSOAPPropertyBag.i
testnsparse in/big/nsCLiveconnectFactory.i
testnsparse in/big/nsHTMLEditRules.i
testnsparse in/big/nsMsgServiceProvider.i

else
  # Even though my in/big/gz/nsAtomTable.i.gz has the right md5sum,
  # I can't convince gunzip to uncompress it under cygwin with text
  # mounts (which it should be ignoring since it's getting the file
  # contents via pipe, and ought to use O_BINARY anyway).
  echo "Skipping large file tests because could not uncompress them."
  echo "This may be due to a buggy cygwin gunzip."
fi

# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "use_kandr: $use_kandr"
echo "Successful tests               :    $success"
echo "Failed as expected (known bugs):    $failure"
if [ $skipdiagnose -ne 0 ]; then
  echo "Fail to diag. cppstdex errors  :    $skipdiagnose"
fi
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$logfile" ]; then
    cat "$logfile"
  fi
fi

