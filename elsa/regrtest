#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
log=regrtest.log
rm -f $log

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $log
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
#
# This isn't really intended for "here's a test that must fail", but
# rather "here's a test that does fail right now, but we want to
# eventually fix it".  The former can be handled using multitest.pl,
# or a similar mechanism for inverting the test sense.
failTest() {
  reason="$1"
  shift
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------

# flags to pass; $TR_EXTRA is here so I can put additional tracing
# flags into this command from the command line, to test them across
# all my test inputs; by default it expands to "", and hence has no
# effect
TR_FLAGS=doOverload,mustBeUnambiguous$TR_EXTRA
#TR_FLAGS=doOverload,doOperatorOverload,mustBeUnambiguous$TR_EXTRA

# NOTE: I've recently changed the 'trace' module to additionally be
# sensitive to the "TRACE" environment variable, so that's another
# (and more general) way to add flags globally.

# by using shell functions we can make it easy to comment-out
# or change to 'fail' status those tests that are not working at
# some given time  
testparse() {
  runTest perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/$1
}
failparse() {
  failTest "$2" perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/$1
}

testparse t0001.cc
testparse t0002.cc
testparse t0003.cc
testparse t0004.cc
testparse t0005.cc
testparse t0006.cc
testparse t0007.cc
testparse t0008.cc
testparse t0009.cc
testparse t0010.cc
testparse t0011.cc
testparse t0012.cc
testparse t0013.cc
testparse t0014.cc
testparse t0014a.cc
testparse t0015.cc
testparse t0016.cc
testparse t0017.cc
testparse t0018.cc
testparse t0019.cc
testparse t0020.cc
testparse t0021.cc
testparse t0022.cc
testparse t0023.cc
testparse t0024.cc
testparse t0025.cc
testparse t0026.cc
testparse t0027.cc
testparse t0028.cc
testparse t0029.cc
testparse t0030.cc
testparse t0030a.cc
testparse t0030b.cc
testparse t0031.cc
testparse t0032.cc
testparse t0033.cc
testparse t0034.cc
testparse t0035.cc
testparse t0036.cc
testparse t0037.cc
testparse t0038.cc
testparse t0039.cc
testparse t0040.cc
testparse t0041.cc
testparse t0042.cc
testparse t0043.cc
testparse t0044.cc
testparse t0045.cc
testparse t0046.cc
testparse t0047.cc
testparse t0048.cc
testparse t0049.cc
testparse t0050.cc
testparse t0051.cc
testparse t0052.cc
testparse t0053.cc
testparse t0054.cc
testparse t0055.cc
testparse t0056.cc
testparse t0057.cc
testparse t0058.cc
testparse t0059.cc
testparse t0060.cc
testparse t0061.cc
testparse t0062.cc
testparse t0063.cc
testparse t0064.cc
testparse t0065.cc
testparse t0066.cc
testparse t0067.cc
testparse t0068.cc
testparse t0069.cc
testparse t0070.cc
testparse t0071.cc
testparse t0072.cc
testparse t0073.cc
testparse t0074.cc
testparse t0075.cc
testparse t0076.cc
testparse t0077.cc
testparse t0078.cc
testparse t0079.cc
testparse t0080.cc
testparse t0081.cc
testparse t0082.cc
testparse t0083.cc
testparse t0084.cc
testparse t0085.cc
testparse t0086.cc
testparse t0087.cc
testparse t0088.cc
testparse t0089.cc
testparse t0090.cc
testparse t0091.cc
testparse t0092.cc
testparse t0093.cc
failparse t0094.cc 'weird g++ iomanip.h <> syntax'
testparse t0095.cc
testparse t0096.cc
testparse t0097.cc
testparse t0098.cc
testparse t0099.cc
testparse t0100.cc
testparse t0101.cc
testparse t0102.cc
testparse t0103.cc
testparse t0104.cc
testparse t0105.cc
testparse t0106.cc
testparse t0107.cc
testparse t0108.cc
testparse t0109.cc
testparse t0110.cc
testparse t0111.cc
testparse t0112.cc
testparse t0113.cc
testparse t0114.cc
testparse t0115.cc
testparse t0116.cc
testparse t0117.cc
testparse t0118.cc
testparse t0119.cc
testparse t0120.cc
testparse t0121.cc
testparse t0122.cc
testparse t0123.cc
testparse t0124.cc
testparse t0125.cc
testparse t0126.cc  # work in progress, so it's ok if it starts failing
testparse t0127.cc
testparse t0128.cc
testparse t0129.cc
testparse t0130.cc
testparse t0131.cc
testparse t0132.cc
testparse t0133.cc
testparse t0134.cc
testparse t0135.cc
testparse t0136.cc
testparse t0137.cc
testparse t0138.cc
testparse t0139.cc
testparse t0140.cc
testparse t0141.cc
testparse t0142.cc
testparse t0143.cc
testparse t0144.cc
testparse t0145.cc
testparse t0146.cc
testparse t0147.cc
testparse t0148.cc
testparse t0149.cc
testparse t0150.cc
failparse t0151.cc "known bug"
failparse t0152.cc "known bug"
testparse t0153.cc
testparse t0154.cc
testparse t0155.cc
testparse t0156.cc
testparse t0157.cc
testparse t0158.cc
testparse t0159.cc
testparse t0160.cc
testparse t0161.cc
testparse t0162.cc
testparse t0163.cc
testparse t0164.cc
testparse t0165.cc
testparse t0166.cc
testparse t0167.cc
testparse t0168.cc

# known bugs

# this one works in all respects, except every valid use yields
# "error: left side of ->* must be a pointer, not `struct Ap'"
failTest "need to insert conversion functions" \
  perl ./multitest.pl ./ccparse -tr doOperatorOverload in/t0151.cc

# this hacky variation *does* work
runTest perl ./multitest.pl ./five-errors -tr doOperatorOverload in/t0151.cc

failTest "need overload resolution with templates" \
  perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/t0152.cc


# another set of tests, generally isolated by Daniel
testparse d0001.cc
testparse d0002.cc
testparse d0003.cc
testparse d0004.cc
testparse d0005.cc
testparse d0006.cc
testparse d0007.cc
testparse d0008.cc
testparse d0009.cc
testparse d0010.cc
testparse d0011.cc
testparse d0012.cc
testparse d0013.cc
testparse d0014.cc
testparse d0015.cc
testparse d0016.cc
testparse d0017.cc
testparse d0018.cc
testparse d0019.cc
testparse d0020.cc
testparse d0021.cc
testparse d0022.cc
testparse d0023.cc
testparse d0024.cc
testparse d0025.cc
testparse d0026.cc
testparse d0027.cc
testparse d0028.cc
testparse d0029.cc
# break
testparse d0032.cc
# break
testparse d0034.cc
testparse d0035.cc
testparse d0036.cc
testparse d0037.cc
testparse d0038.cc
testparse d0039.cc
# break
testparse d0048.cc
testparse d0048elab.cc

# examples from C++ standard
#
# a few examples have parts commented-out:
#   7.3.3c.cc: nerfed because member templates aren't implemented
#   7.3.3f.cc: "int i; int i;" is supposed to be allowed
#   7.3.3k.cc: I don't detect a purported ambiguity
#   7.3.4e.cc: major design flaw: cannot return sets from lookup functions
#   (more from before I started maintaining this list)
for fn in in/std/*.cc; do
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS "$fn"
done

# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +yes" config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi
                
if $use_gnu; then
  # test gnu extensions
  for fn in in/gnu/*.c?; do
    runTest ./ccparse -tr $TR_FLAGS "$fn"
  done

  # test c99 extensions
  for fn in in/c99/*.c; do
    runTest ./ccparse -tr $TR_FLAGS "$fn"
  done
fi

# idempotency checks; known problems:
#   25: Scope operator not being printed before using type.
#   27, 28: Templates not being printed correctly when the template
#           arguments are used within the template.
#   30: scope not printing.
#   34: template arguments to a class, such as "A<T>", get printed as
#       "template <class T> class A" instead
#   35, 36: template <class ...> gets dropped
# note that the 'sed' command includes a literal tab character..
list=`echo " \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc
  t0021.cc   t0022.cc  t0023.cc  t0024.cc              t0026.cc
             t0029.cc            t0030a.cc  t0030b.cc  t0031.cc  t0032.cc
  t0033.cc                                  t0037.cc   t0038.cc  t0039.cc
  t0040.cc   t0041.cc  t0042.cc  t0043.cc
                                            t0100.cc   t0101.cc  t0102.cc
                       t0105.cc  t0106.cc
                                                                 t0123.cc \
  " | fmt -1 | sed 's|^[ 	]*|in/|'`

runTest perl ./idemcheck -d outdir $list

if $use_gnu; then
  #   125: inline assembly not printed
  #   126: attributes not printed
  #   127: typeof not printed
  # note that the 'sed' command includes a literal tab character..
  list=`echo " \
    gnu/t0124.cc
    gnu/t0128.cc
    gnu/t0129.cc
    gnu/t0130.cc
    gnu/t0131.cc
    gnu/t0132.cc
    c99/t0133.c \
    " | fmt -1 | sed 's|^[ 	]*|in/|'`
  runTest perl ./idemcheck -d outdir $list
fi


# test the parser in C mode
for fn in \
  t0001.c t0002.c t0003.c t0004.c t0005.c \
    ; do
  runTest ./ccparse -tr c_lang in/c/$fn
done


# final parser checks against the big files, since they've now become
# my performance measurement files
$MAKE in/big

testnsparse() {
  # don't try operator overload resolution, it doesn't work for them (?)
  runTest ./ccparse -tr $TR_FLAGS "$1"
}
failnsparse() {
  failTest "$2" ./ccparse -tr $TR_FLAGS "$1"
}

testnsparse in/big/nsAtomTable.i
testnsparse in/big/nsSOAPPropertyBag.i
testnsparse in/big/nsCLiveconnectFactory.i
testnsparse in/big/nsHTMLEditRules.i
testnsparse in/big/nsMsgServiceProvider.i
testnsparse in/big/nsUnicodeToTeXCMRt1.i

testnsparse in/big/nonport.i



# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "Successful tests:      $success"
echo "Failed as expected:    $failure"    
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$log" ]; then
    cat "$log"
  fi
fi

