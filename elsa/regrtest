#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
log=regrtest.log
rm -f $log

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $log
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
#
# This isn't really intended for "here's a test that must fail", but
# rather "here's a test that does fail right now, but we want to
# eventually fix it".  The former can be handled using multitest.pl,
# or a similar mechanism for inverting the test sense.
failTest() {
  reason="$1"
  shift
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------

# flags to pass; $TR_EXTRA is here so I can put additional tracing
# flags into this command from the command line, to test them across
# all my test inputs; by default it expands to "", and hence has no
# effect
TR_FLAGS=doOverload,mustBeUnambiguous$TR_EXTRA
#TR_FLAGS=doOverload,doOperatorOverload,mustBeUnambiguous$TR_EXTRA

# Arg, unlike in make, there is no "+=" in shell
T=
T="$T t0001.cc"
T="$T t0002.cc"
T="$T t0003.cc"
T="$T t0004.cc"
T="$T t0005.cc"
T="$T t0006.cc"
T="$T t0007.cc"
T="$T t0008.cc"
T="$T t0009.cc"
T="$T t0010.cc"
T="$T t0011.cc"
T="$T t0012.cc"
T="$T t0013.cc"
T="$T t0014.cc"
T="$T t0014a.cc"
T="$T t0015.cc"
T="$T t0016.cc"
T="$T t0017.cc"
T="$T t0018.cc"
T="$T t0019.cc"
T="$T t0020.cc"
T="$T t0021.cc"
T="$T t0022.cc"
T="$T t0023.cc"
T="$T t0024.cc"
T="$T t0025.cc"
T="$T t0026.cc"
T="$T t0027.cc"
T="$T t0028.cc"
T="$T t0029.cc"
T="$T t0030.cc"
T="$T t0030a.cc"
T="$T t0030b.cc"
T="$T t0031.cc"
T="$T t0032.cc"
T="$T t0033.cc"
T="$T t0034.cc"
T="$T t0035.cc"
T="$T t0036.cc"
T="$T t0037.cc"

# This one is very strange.  First, the function f and method foo()
# are irrelevant; remove them.  Note that there is no way to seperate
# StringDict and Iter such that one is before the other.  Now, note
# that if you do any of the following, the test passes: Change
# getIter() to return void or an Iter reference.  Change the Iter ctor
# to have no arguments and make "StringDict &dict" a member of class
# Iter.  Change the Iter ctor to just be a normal method.

# Also, it fails in a different way if StringDict is passed as a
# parameter by value instead of by reference.

# T="$T t0038.cc"

T="$T t0039.cc"
T="$T t0040.cc"
T="$T t0041.cc"
T="$T t0042.cc"
T="$T t0043.cc"
T="$T t0044.cc"
T="$T t0045.cc"
T="$T t0046.cc"

# I didn't even look at this one.
#   UNEXPECTED: ambiguities remain after type checking!
#T="$T t0047.cc"

T="$T t0048.cc"
T="$T t0049.cc"
T="$T t0050.cc"
T="$T t0051.cc"
T="$T t0052.cc"
T="$T t0053.cc"

# I must have messed up putting in the template arguments to a PQName somewhere.
#  in/t0054.cc:17:5: error: too few template arguments to `A' (and partial specialization is not implemented)
#  in/t0054.cc:19:11: error: class `A' is a template, you have to supply template arguments
# T="$T t0054.cc"

T="$T t0055.cc"
T="$T t0056.cc"
T="$T t0057.cc"
T="$T t0058.cc"

# using an E_constructor with a typedefed type doesn't work.  Turn it
# into a cast.
# T="$T t0059.cc"

T="$T t0060.cc"
T="$T t0061.cc"

#  in/t0062.cc:34:14: error: no viable candidate for function call
#  in/t0062.cc:34:14: error: ::Foo:: has no member called `~Foo'
#  in/t0062.cc:34:14: error: there is no variable called `::Foo::~Foo'
#  in/t0062.cc:39:14: error: no viable candidate for function call
#  in/t0062.cc:39:14: error: ::Foo:: has no member called `~Foo'
#  in/t0062.cc:39:14: error: there is no variable called `::Foo::~Foo'
# T="$T t0062.cc"

T="$T t0063.cc"
T="$T t0064.cc"
T="$T t0065.cc"
T="$T t0066.cc"
T="$T t0067.cc"
T="$T t0068.cc"
T="$T t0069.cc"
T="$T t0070.cc"
T="$T t0071.cc"
T="$T t0072.cc"
T="$T t0073.cc"
T="$T t0074.cc"
T="$T t0075.cc"
T="$T t0076.cc"
T="$T t0077.cc"

#  in/t0078.cc:7:5: error: variable name `::Foo::hash' used as if it were a type
#  in/t0078.cc:7:5: error: cannot find scope name `hash'
#  in/t0078.cc:7:5: error: there is no variable called `::Foo::hash::~hash'
# T="$T t0078.cc"

T="$T t0079.cc"

#  Exception thrown: Assertion failed: isCompoundType(), file cc_type.cc line 43
# T="$T t0080.cc"

T="$T t0081.cc"
T="$T t0082.cc"
T="$T t0083.cc"
T="$T t0084.cc"
T="$T t0085.cc"
T="$T t0086.cc"
T="$T t0087.cc"
T="$T t0088.cc"
T="$T t0089.cc"
T="$T t0090.cc"
T="$T t0091.cc"
T="$T t0092.cc"
T="$T t0093.cc"
#   0094: weird g++ iomanip.h "<>" syntax
# T="$T t0094.cc"
T="$T t0095.cc"
T="$T t0096.cc"
T="$T t0097.cc"
T="$T t0098.cc"
T="$T t0099.cc"
T="$T t0100.cc"
T="$T t0101.cc"
T="$T t0102.cc"
T="$T t0103.cc"
T="$T t0104.cc"
T="$T t0105.cc"

#  Exception thrown: Assertion failed: isCompoundType(), file cc_type.cc line 43
#  child died with signal ABRT
# T="$T t0106.cc"

T="$T t0107.cc"
T="$T t0108.cc"
T="$T t0109.cc"
T="$T t0110.cc"
T="$T t0111.cc"
T="$T t0112.cc"
T="$T t0113.cc"
T="$T t0114.cc"
T="$T t0115.cc"
T="$T t0116.cc"
T="$T t0117.cc"
#  in/t0118.cc:139:5: error: no viable candidate for function call
#  in/t0118.cc:200:5: error: no viable candidate for function call
#  in/t0118.cc:210:5: error: no viable candidate for function call
#  in/t0118.cc:216:6: error: no viable candidate for function call
# T="$T t0118.cc"
T="$T t0119.cc"
#  child died with signal SEGV
#  T="$T t0120.cc"
T="$T t0121.cc"
T="$T t0122.cc"
T="$T t0123.cc"
T="$T t0124.cc"
T="$T t0125.cc"
#   0126: work in progress
# T="$T t0126.cc"
#  child died with signal SEGV
#  T="$T t0127.cc"
T="$T t0128.cc"
T="$T t0129.cc"
T="$T t0130.cc"
T="$T t0131.cc"
T="$T t0132.cc"
T="$T t0133.cc"
T="$T t0134.cc"
T="$T t0135.cc"
#  child died with signal SEGV
#  T="$T t0136.cc"
#  child died with signal SEGV
#  T="$T t0137.cc"
T="$T t0138.cc"
#  child died with signal SEGV
#  T="$T t0139.cc"
T="$T t0140.cc"
#  child died with signal SEGV
#  T="$T t0141.cc"
T="$T t0142.cc"
#  child died with signal SEGV
#  T="$T t0143.cc"
#  child died with signal SEGV
#  T="$T t0144.cc"

# just skipping as many are dying with segfaults
#  T="$T t0145.cc"
#  T="$T t0146.cc"
#  T="$T t0147.cc"
#  T="$T t0148.cc"
#  T="$T t0149.cc"
#  T="$T t0150.cc"

#   0151,0152: known bugs
# T="$T t0151.cc"
# T="$T t0152.cc"
T="$T t0153.cc"
T="$T t0154.cc"
T="$T t0155.cc"
for fn in $T; do
  # $TR_EXTRA is here so I can put additional tracing flags into this
  # command from the command line, to test them across all my test inputs;
  # by default it expands to "", and hence has no effect
  runTest perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/$fn
done

# known bugs

# this one works in all respects, except every valid use yields
# "error: left side of ->* must be a pointer, not `struct Ap'"
failTest "need to insert conversion functions" \
  perl ./multitest.pl ./ccparse -tr doOperatorOverload in/t0151.cc

# this hacky variation *does* work
runTest perl ./multitest.pl ./five-errors -tr doOperatorOverload in/t0151.cc

failTest "need overload resolution with templates" \
  perl ./multitest.pl ./ccparse -tr doOperatorOverload,$TR_FLAGS in/t0152.cc


# another set of tests, generally isolated by Daniel
for fn in                                      \
  d0001.cc d0002.cc d0003.cc d0004.cc d0005.cc \
  d0006.cc d0007.cc d0008.cc d0009.cc d0010.cc \
  d0011.cc d0012.cc d0013.cc d0014.cc d0015.cc \
  d0016.cc d0017.cc                            \
    ; do
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS in/$fn
done


# FIX turn this off.
echo; echo; echo "**************** Exiting early ****************"; echo
exit 0;


# examples from C++ standard
for fn in in/std/*.cc; do
  runTest perl ./multitest.pl ./ccparse -tr $TR_FLAGS "$fn"
done

# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +yes" config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi
                
if $use_gnu; then
  # test gnu extensions
  for fn in in/gnu/*.c?; do
    runTest ./ccparse -tr $TR_FLAGS "$fn"
  done

  # test c99 extensions
  for fn in in/c99/*.c; do
    runTest ./ccparse -tr $TR_FLAGS "$fn"
  done
fi

# idempotency checks; known problems:
#   25: Scope operator not being printed before using type.
#   27, 28: Templates not being printed correctly when the template
#           arguments are used within the template.
#   30: scope not printing.
#   35, 36: template <class ...> gets dropped
# note that the 'sed' command includes a literal tab character..
list=`echo " \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc
  t0021.cc   t0022.cc  t0023.cc  t0024.cc              t0026.cc
             t0029.cc            t0030a.cc  t0030b.cc  t0031.cc  t0032.cc
  t0033.cc   t0034.cc                       t0037.cc   t0038.cc  t0039.cc
  t0040.cc   t0041.cc  t0042.cc  t0043.cc
                                            t0100.cc   t0101.cc  t0102.cc
                       t0105.cc  t0106.cc
                                                                 t0123.cc \
  " | fmt -1 | sed 's|^[ 	]*|in/|'`
runTest perl ./idemcheck -d outdir $list

if $use_gnu; then
  #   125: inline assembly not printed
  #   126: attributes not printed
  #   127: typeof not printed
  # note that the 'sed' command includes a literal tab character..
  list=`echo " \
    gnu/t0124.cc
    gnu/t0128.cc
    gnu/t0129.cc
    gnu/t0130.cc
    gnu/t0131.cc
    gnu/t0132.cc
    c99/t0133.c \
    " | fmt -1 | sed 's|^[ 	]*|in/|'`
  runTest perl ./idemcheck -d outdir $list
fi


# test the parser in C mode
for fn in                                                                   \
  t0001.c t0002.c t0003.c t0004.c                                           \
    ; do
  runTest ./ccparse -tr c_lang in/c/$fn
done


# final parser checks against the big files, since they've now become
# my performance measurement files
$MAKE in/big
for fn in in/big/*.i; do
  runTest ./ccparse -tr $TR_FLAGS "$fn"
done


# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "Successful tests:      $success"
echo "Failed as expected:    $failure"    
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$log" ]; then
    cat "$log"
  fi
fi

