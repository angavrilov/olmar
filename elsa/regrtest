#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# allow 'gmake' or whatever to be used instead of 'make'
MAKE=${MAKE:-make}

# clear the logfile
log=regrtest.log
rm -f $log

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $log
}


# run a single test, and bail if it fails
runTest() {
  if runTestInternal "$@"; then
    true
  else
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    ("$@")
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=`expr $unexFailure + 1`
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=`expr $success + 1`
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit `expr 1 - $success`
    fi
  fi

  curtest=`expr $curtest + 1`
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
failTest() {
  reason="$1"
  shift
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=`expr $unexSuccess + 1`
      echo ""
      log  "[$curtest] A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=`expr $failure + 1`
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit `expr 1 - $failure`
    fi
  fi

  curtest=`expr $curtest + 1`
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ---------- test C++ parser ------------
# the gaps below are for the tests which don't work
#   0094: weird g++ iomanip.h "<>" syntax
for fn in                                                                 \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc \
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc \
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc \
  t0021.cc   t0022.cc  t0023.cc  t0024.cc   t0025.cc   t0026.cc  t0027.cc \
  t0028.cc   t0029.cc  t0030.cc  t0030a.cc  t0030b.cc  t0031.cc  t0032.cc \
  t0033.cc   t0034.cc  t0035.cc  t0036.cc   t0037.cc   t0038.cc  t0039.cc \
  t0040.cc   t0041.cc  t0042.cc  t0043.cc   t0044.cc   t0045.cc  t0046.cc \
  t0047.cc   t0048.cc  t0049.cc  t0050.cc   t0051.cc   t0052.cc  t0053.cc \
  t0054.cc   t0055.cc  t0056.cc  t0057.cc   t0058.cc   t0059.cc  t0060.cc \
  t0061.cc   t0062.cc  t0063.cc  t0064.cc   t0065.cc   t0066.cc  t0067.cc \
  t0068.cc   t0069.cc  t0070.cc  t0071.cc   t0072.cc   t0073.cc  t0074.cc \
  t0075.cc   t0076.cc  t0077.cc  t0078.cc   t0079.cc   t0080.cc  t0081.cc \
  t0082.cc   t0083.cc  t0084.cc  t0085.cc   t0086.cc   t0087.cc  t0088.cc \
  t0089.cc   t0090.cc  t0091.cc  t0092.cc   t0093.cc             t0095.cc \
  t0096.cc   t0097.cc  t0098.cc  t0099.cc   t0100.cc   t0101.cc  t0102.cc \
  t0103.cc   t0104.cc  t0105.cc  t0106.cc   t0107.cc   t0108.cc  t0109.cc \
  t0110.cc   t0111.cc  t0112.cc  t0113.cc   t0114.cc   t0115.cc  t0116.cc \
  t0117.cc   t0118.cc  t0119.cc  t0120.cc   t0121.cc   t0122.cc  t0123.cc \
  t0124.cc   t0125.cc            t0127.cc   t0128.cc                      \
    ; do
  # $TR_EXTRA is here so I can put additional tracing flags into this
  # command from the command line, to test them across all my test inputs;
  # by default it expands to "", and hence has no effect
  runTest perl ./multitest.pl ./ccparse -tr doOverload,mustBeUnambiguous$TR_EXTRA in/$fn
done

# another set of tests, generally isolated by Daniel
for fn in                                                                 \
  d0001.cc                                                                \
    ; do
  runTest perl ./multitest.pl ./ccparse -tr doOverload,mustBeUnambiguous$TR_EXTRA in/$fn
done

# examples from C++ standard
for fn in in/std/*.cc; do
  runTest perl ./multitest.pl ./ccparse -tr doOverload "$fn"
done

# is the gnu extension built?
use_gnu=false
if egrep "USE_GNU: +yes" config.summary >/dev/null; then
  use_gnu=true
  echo "gnu extensions are enabled"
else
  echo "gnu extensions are not enabled"
fi
                
if $use_gnu; then
  # test gnu extensions
  for fn in in/gnu/*.c?; do
    runTest ./ccparse -tr doOverload "$fn"
  done

  # test c99 extensions
  for fn in in/c99/*.c; do
    runTest ./ccparse "$fn"
  done
fi

# idempotency checks; known problems:
#   25: Scope operator not being printed before using type.
#   27, 28: Templates not being printed correctly when the template
#           arguments are used within the template.
#   30: scope not printing.
#   35, 36: template <class ...> gets dropped
# note that the 'sed' command includes a literal tab character..
list=`echo " \
  t0001.cc   t0002.cc  t0003.cc  t0004.cc   t0005.cc   t0006.cc  t0007.cc
  t0008.cc   t0009.cc  t0010.cc  t0011.cc   t0012.cc   t0013.cc  t0014.cc
  t0014a.cc  t0015.cc  t0016.cc  t0017.cc   t0018.cc   t0019.cc  t0020.cc
  t0021.cc   t0022.cc  t0023.cc  t0024.cc              t0026.cc
             t0029.cc            t0030a.cc  t0030b.cc  t0031.cc  t0032.cc
  t0033.cc   t0034.cc                       t0037.cc   t0038.cc  t0039.cc
  t0040.cc   t0041.cc  t0042.cc  t0043.cc
                                            t0100.cc   t0101.cc  t0102.cc
                       t0105.cc  t0106.cc
                                                                 t0123.cc \
  " | fmt -1 | sed 's|^[ 	]*|in/|'`
runTest perl ./idemcheck -d outdir $list

if $use_gnu; then
  #   125: inline assembly not printed
  #   126: attributes not printed
  #   127: typeof not printed
  # note that the 'sed' command includes a literal tab character..
  list=`echo " \
    gnu/t0124.cc
    gnu/t0128.cc
    gnu/t0129.cc
    gnu/t0130.cc
    gnu/t0131.cc
    gnu/t0132.cc
    c99/t0133.c \
    " | fmt -1 | sed 's|^[ 	]*|in/|'`
  runTest perl ./idemcheck -d outdir $list
fi


# test the parser in C mode
for fn in                                                                   \
  t0001.c t0002.c t0003.c t0004.c                                           \
    ; do
  runTest ./ccparse -tr c_lang in/c/$fn
done


# final parser checks against the big files, since they've now become
# my performance measurement files
$MAKE in/big
for fn in in/big/*.i; do
  runTest ./ccparse -tr doOverload "$fn"
done


# final arithmetic to report result
echo ""
echo "use_gnu: $use_gnu"
echo "Successful tests:      $success"
echo "Failed as expected:    $failure"    
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$log" ]; then
    cat "$log"
  fi
fi

