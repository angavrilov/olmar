lookup.txt

This is my attempt to document what the lookup rules of C++ are (in a
more digested, concise form than the standard itself, but with liberal
references to the standard), and how Elsa implements them.  Initially
the document just covers a few special cases that I have investigated
carefully, but ideally it will grow to cover all the cases of name
lookup in C++.

The main difference between the account here and that in the standard
is that this document will attempt to provide a complete narrative
from start to finish (i.e., temporally coherent) of how lookup happens
for a given syntax/context, whereas the standard is organized by
language feature and so often scatters relevant details in many
places.

One reference worth mentioning: Brian Malloy has done some
investigation of how to implement lookup in C++, and his papers are
at http://www.cs.clemson.edu/~malloy/projects/keystone/keystone.html.
My analysis is independent, however.



There are four kinds of scope chaining mechanisms:
  1. syntactic nesting for the current scope (Env::scopes)
  2. syntactic nesting for non-current scopes (Scope::parentScope)
  3. namespace 'using' directives (Scope::usingEdges)
  4. base classes (CompoundType::bases)

Env is responsible for internally following chains 1 and 2; they are
(only) used for unqualified lookup.  Scope is responsible for
following chains 3 and 4; Env delegates to Scope as necessary.
Consequently, using Scope::lookup disables use of chains 1 and 2.
LF_IGNORE_USING disables chain 3.  LF_INNER_ONLY disables all four
chains.  Currently, nothing disables chain 4 by itself.





-----------------------------------------------------------
How does name lookup for function all syntax (E_funCall) work?

Note that context-specific name lookup only occurs if the 'func' is an
E_variable or an E_fieldAcc.  Both contain a PQName, here called 'name'.

At an E_funCall, we have the following information:
  - func
    - receiver object expression (if is E_fieldAcc)
    - qualifiers (optional)
    - StringRef name (name->getName())
    - template arguments (optional), 'targs'
  - function (expression) arguments, 'eargs'

Lookup is split across E_funCall::inner1_tcheck and
E_funCall::inner2_tcheck.  This split is for performance reasons, and
forces a certain partition of the work (see comments in
Expression::tcheck for more details).

inner1's main job is to map the 'name' to an initial set of Variable 
object pointers.  The set includes all overloaded instances from all
relevant namespaces (i.e., those found via 'using' directives).

  * Do an ordinary (as opposed to argument dependent) lookup of the
    name, using the receiver object type, the qualifiers, and the
    StringRef name.  Lookup is as specified in 10.2 if E_fieldAcc, or
    3.4 if E_variable.

  * If template arguments are present but the lookup did not find any
    template functions, issue an error.

The result of the inner1 lookup is carried in the 'candidates' list.

inner2's job is to pick up where inner1 left off, and use the
remaining information in the E_funCall to pick exactly the right
Variable for the function call site, doing template instantiation and
overload resolution as necessary.  It does these steps:

  * It regards the set computed by inner1 (and stored in 'candidates') 
    as denoting an initial candidate set (possibly empty).

  * If no receiver object and no qualifiers are present, augment the
    candidate set by using argument dependent lookup (3.4.2).

  * Refine/filter the candidate set; for each candidate:

    - If template arguments are explicitly present, but the candidate
      is not a template, remove it.

    - If the candidate is a template, bind the 'targs' (if present) to
      template parameters (14.8.1), and then do template argument
      deduction (using the 'eargs') to determine the remaining template
      parameters (14.8.2, 14.8.2.1).  If any incompatibility is found,
      or not all template arguments have been determined, remove the
      candidate.  Otherwise, replace the candidate with its (fully
      concrete) instantiation Variable.

  * Use 'eargs' to do overload resolution (13.3) to select the best
    candidate from the refined candidate set.


-------------------------------------------------------
Scope::lookup: How does lookup within a Scope work?

Lookup within a scope has input:
  - StringRef name     : name of symbol to look up
  - Env env            : for error reporting (if not LF_SUPPRESS_ERROR)
  - LookupFlags flags  : lookup modifiers
And has output:
  - LookupSet &set     : set of entities referred to by 'name'

First, Scope::variables or Scope::typeTags is queried, depending
on LF_QUERY_TAGS.  If this yields a hit, the resulting variable's
overload set (if any) is expanded and placed in a temporary 'set'.

If LF_INNER_ONLY, return what we have.

Next, if this Scope is a namespace, and LF_IGNORE_USING is not
specified, the 'using' directive edges are considered, as per 7.3.4
and 3.4.3.2, adding to 'set':

  (TODO: explain this process)

If 'set' is not empty, return.

Finally, if this Scope is a class, its base classes are searched
according to 10.2:

  - For each of the base class subobject, we search for 'name' in the
    scope corresponding to the subobject's class (Scope::lookup with
    LF_INNER_ONLY).

  - If we find entities v1 and v2 with the given name:
    - If v1 hides v2 (v2's subobject is an ancestor of v1's
      subobject), or vice versa, ignore the hidden entity (10.2p6).
    - If v1 and v2 are the same entity (just in different subobjects),
      we can regard them as the same if the entity is static, a type,
      or an enumerator (10.2p5).









EOF
