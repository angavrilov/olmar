<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <title>C++ Entities and Relationships</title>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
  <style type="text/css">
    H1 { font-size: 150% }
    H2 { font-size: 125% }
    H3 { font-size: 100% }
    P.title { font-size: 175%; font-weight: bold }
    P.remark { font-size: 125%; color: red }
    SPAN.todo { font-weight: bold }
    SPAN.program { font-family: monospace }
    SPAN.variable { font-family: monospace }
    a.toc:link { text-decoration: none }
    a.toc:visited { text-decoration: none }
  </style>
</head>
<body>

<center>
<p class="title">C++ Entities and Relationships</p>
</center>

<p>
This page contains data model diagrams useful for understanding the
C++ language.  They show the various concepts in C++ static
(compile-time) semantics, and their interrelationships. 

<p>
One use of these data models is to help understand the C++ Standard
document.  It collects together the essential notions in the language,
what components they have, how they are related, etc.  The data model
is intended to be sufficiently complete that it could serve as the
basis for a formal definition of the static semantics.

<p>
Another use is to understand the Elsa implementation.  Not surprisingly,
many concepts in the data models correspond to prominent classes in
the Elsa implementation.  However, the correspondence is not exact;
in some cases, there are deviations due to known bugs in Elsa, while in
others Elsa simply uses an implementation technique that may obscure
a given concept.  Nevertheless, the intent is that Elsa should use a
data model that could (in principle) be mapped back and forth to the
model presented here.

<p>
That the names used in these diagrams do not correspond exactly with
either the terminology in the standard (which is often unnecessarily
vague) nor that used in Elsa (which makes fewer distinctions, for
example among kinds of Variables).  However, there is an overall
attempt at terminological consistency.


<h1>Notation</h1>

<p>
The following diagrams use a notation that it is a mixture of
traditional Entity-Relationship diagrams and UML, with some of my
own ideas thrown in:
<ul>
<li>Entities are shown in boxes.  A dashed box indicates an entity that
    with attributes and/or relationships that are elided from the
    diagram.
<li>Attributes are in ellipses.  Dashed ellipses similarly indicate
    elided detail.
<li>Relationships are thin lines connecting entities.  Either or both
    ends of a relationship may be named.  Each endpoint of the relationship
    indicates a <em>cardinality</em>, which is the number times that a
    single instance of the entity may participate in the relationship:
    <ul>
    <li>Name with no annotation: cardinality is one.
    <li>Name with "?" annotation: zero or one.
    <li>Name with "*" annotation: any number, including zero.
    <li>Name with "[]" annotation: relation tuples are <em>ordered</em>,
        forming a <em>sequence</em>; cardinality is anything.
    <li>Unnamed arrowhead: cardinality is anything.  The notation is meant
        to suggest a pointer, where the referent typically does not want or
        need to know that something is pointing at it.
    </ul>
<li>Attributes can be given "?", "*" and "[]" annotations, with similar
    meanings as for relationships.  In fact, attribute notation is used
    interchangeably with relationship notation where convenient.
<li>Specialization (often conceptualized as inheritance) is indicated
    by thick lines connecting entities, with triangular split points.
    A solid triangle indicates <em>total</em> specialization (meaning
    the superclass is abstract) while an open triangle indicates
    <em>partial</em> specialization.  Color is used to emphasize
    important specialization hierarchies.
    <ul>
    <li>What is the difference between a partial specialization and
        an optional ("?") attribute or relationship?  The former cannot
        change during the entity's lifetime, while the latter can.
    </ul>
</ul>


<h1>Diagram 1: Scopes, Variables and Types</h1>

<p>
The following diagram
(xfig sources: <a href="er.fig">er.fig</a>,
postscript: <a href="er.ps">er.ps</a>)
shows the essential static semantic concepts, such as scopes,
variables and types.  It omits templates, and it omits executable
AST fragments like statements and expressions.

<p>
<center><img src="er.png" alt="C++ Static Semantics ER diagram"></center>

<p>
(TODO: Give detailed explanations for each entity.)


<h1>Diagram 2: Templates</h1>

<p>
This diagram
(xfig sources: <a href="template_er.fig">template_er.fig</a>,
postscript: <a href="template_er.ps">template_er.ps</a>)
is an extension of the previous diagram, showing all the
new and extended concepts needed to represent templates.

<p>
<center><img src="template_er.png" alt="C++ Templates diagram"></center>

<p>
(TODO: Give detailed explanations for each entity.)





&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
<center>This space left intentionally blank.</center>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>





</body>
</html>
