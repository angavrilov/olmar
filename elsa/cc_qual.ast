// cc_qual.ast            see license.txt for copyright and terms of use
// extension module to cc.ast for C++ Cqual

verbatim {
#ifdef CC_QUAL
  #include "cc_qual/cc_qualifiers.h"
#else
  #include "cc_qualifiers_dummy.h"
#endif

  #include "exc.h"              // xBase
  #include "sobjlist.h"         // SObjList

  class QualEnv;                // cc_qual.h
//    class FlattenEnv;          // cc_flatten.h
}


class TranslationUnit {
  // ccqual
  public void qual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
}

class TopForm {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Function {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Declaration {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class ASTTypeId {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class PQName {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TypeSpecifier {
  public Qualifiers *q;

  // this function is called from all of the derived-class ctors; we
  // can't call it from the parent ctor because the derived vtable
  // (and data) isn't available yet
  protected void makeQualifiers() {
    //q = new Qualifiers((name?name->getName():"__null_TypeSpecifier"), loc);
    q = new Qualifiers(getTypeName(), loc, 1 /*default to global*/, NULL);
  };

  // get the unqualified name in the specifier; it's not a StringRef
  // because TS_simple and anonymous types return a pointer to static
  // data (lifetime is still StringRef-like)
  pure_virtual char const *getTypeName() const;

  pure_virtual void qual(QualEnv &env);
  //  pure_virtual void flatten(FlattenEnv &env);

  -> TS_name             { ctor makeQualifiers(); }
  -> TS_simple           { ctor makeQualifiers(); }
  -> TS_elaborated       { ctor makeQualifiers(); }
  -> TS_classSpec        { ctor makeQualifiers(); }
  -> TS_enumSpec         { ctor makeQualifiers(); }
}

class BaseClassSpec {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Member {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Enumerator {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Declarator {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class IDeclarator {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);

  // declarator name; replaces the PQName that had been in the superclass
  public string declaratorName;

  -> D_name
  {
     ctor { declaratorName = (name? name->getName() : "__anonymous"); };
  }

  -> D_pointer(QualifierLiterals *ql)
  {
     public Qualifiers *q;
     ctor { declaratorName = stringc << base->declaratorName << (isPtr? "_p" : "_r");
            q = new Qualifiers(declaratorName, loc, 1 /*default to global*/, NULL, ql); };
//       ctor { q = new Qualifiers("anonymous_pointer", loc, 1 /*default to global*/, NULL, ql); };
  }

  -> D_func(QualifierLiterals *ql)
  {
     public Qualifiers *q;
     ctor { declaratorName = stringc << base->declaratorName << "_func";
            q = new Qualifiers(declaratorName, loc, 1 /*default to global*/, NULL, ql); };
//       ctor {q = new Qualifiers("anonymous_function", loc, 1 /*default to global*/, NULL, ql);};
  }

  -> D_array
  {
     ctor { declaratorName = stringc << base->declaratorName << "_array"; };
  }
  
  -> D_bitfield
  {
     ctor { declaratorName = (name? name->getName() : "__anonymous"); };
  }
  
  -> D_grouping
  {
     ctor { declaratorName = base->declaratorName; };
  }
}

class ExceptionSpec {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Statement {
  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class Condition {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Handler {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Expression {
  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class Initializer {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TemplateDeclaration {
  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class TemplateParameter {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TemplateArgument {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}
