// cc_qual.ast            see license.txt for copyright and terms of use
// extension module to cc.ast for C++ Cqual

verbatim {
#ifdef CC_QUAL
  #include "cc_qual/cc_qualifiers.h"
#else
  #include "cc_qualifiers_dummy.h"
#endif

  #include "exc.h"              // xBase
  #include "sobjlist.h"         // SObjList

  class QualEnv;                // cc_qual.h
  class Type_Q;                 // qual_type.h
  class Variable;               // variable.h
//    class FlattenEnv;          // cc_flatten.h

  // thrown to tell the caller that templates are present
  // and this analysis doesn't work with them
  class XNotSupported : public xBase {
  public:
    XNotSupported(char const *what)
      : xBase(stringc << "Not supported: " << what) {}
    XNotSupported(XNotSupported const &obj) : xBase(obj) {}
  };
}


class TranslationUnit {
  // ccqual
  public void qual(QualEnv &env);

//    public void flatten(FlattenEnv &env);

  // invoke the C++Qual-aware type checker, which will annotate
  // the tree with the Type_Qs etc. declared below; may
  // throw XHasTemplates
  public void qualTcheck(SObjList<Variable> &madeUpVariables);
}

class TopForm {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Function {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Declaration {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class ASTTypeId {
  public Type_Q *getType_Q();

  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class PQName {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TypeSpecifier {
  // Type_Q denoted by this specifier
  public Type_Q *qtype;  ctor qtype=NULL;

  public Qualifiers *q;
//    ctor { q = new Qualifiers((name?name->getName():"__null_TypeSpecifier"), loc); };
  ctor { q = new Qualifiers((name ? strdup(name->getName()) : "anonymous_TypeSpecifier"),
                            loc, 1 /*default to global*/, NULL); };

  pure_virtual void qual(QualEnv &env);
  //  pure_virtual void flatten(FlattenEnv &env);
}

class BaseClassSpec {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Member {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Enumerator {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Declarator {
  public Type_Q *qtype;  ctor qtype=NULL;

  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);

  // given the specifier's type, push that over the declarator
  // syntax to arrive at a final type; store that in 'qtype'
  public void qualTcheck(Type_Q *typeSoFar);
}

class IDeclarator {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);

  // compute the type denoted by this declarator fragment,
  // and store it in the 'dtor' pointer's 'qtype' field;
  // 'typeSoFar' is the type denoted by the specifier and
  // any other surrounding declarator fragments
  //pure_virtual void qualTcheck(Declarator *dtor, Type_Q *typeSoFar);

  -> D_pointer(QualifierLiterals *ql)
  {
     public Qualifiers *q;
     ctor { q = new Qualifiers((name?strdup(name->getName()):"__null_pointer"), loc, 1 /*default to global*/, NULL, ql); };
//       ctor { q = new Qualifiers("anonymous_pointer", loc, 1 /*default to global*/, NULL, ql); };
  }

  -> D_func(QualifierLiterals *ql)
  {
     public Qualifiers *q;
     ctor {q = new Qualifiers((name?strdup(name->getName()):"__null_function"), loc, 1 /*default to global*/, NULL, ql);};
//       ctor {q = new Qualifiers("anonymous_function", loc, 1 /*default to global*/, NULL, ql);};
  }
}

class ExceptionSpec {
  public void qual(QualEnv &env);
//    public void flatten(FlattenEnv &env);
}

class Statement {
  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class Condition {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Handler {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class Expression {
  public Type_Q *qtype;  ctor qtype=NULL;

  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class Initializer {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TemplateDeclaration {
  public void qual(QualEnv &env);
  pure_virtual void iqual(QualEnv &env);

//    public void flatten(FlattenEnv &env);
//    pure_virtual void iflatten(FlattenEnv &env);
}

class TemplateParameter {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}

class TemplateArgument {
  pure_virtual void qual(QualEnv &env);
//    pure_virtual void flatten(FlattenEnv &env);
}
