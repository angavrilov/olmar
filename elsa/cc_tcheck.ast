// cc_tcheck.ast            see license.txt for copyright and terms of use
// extension module for cc.ast that defines the entry points
// for the type checker, and the annotations it produces

// the implementation for the functions declared here is in
// cc_tcheck.cc and cc_ast_aux.cc


// extension modules' first "verbatim" section goes after
// the initial verbatims from the base, but before any
// of the classes from the base
verbatim {
  #include "variable.h"      // Variable
  #include "cc_type.h"       // Type, FunctonType, CompoundType
  #include "implconv.h"      // CompressedImplicitConversion

  class Env;                 // cc_env.h
}


class TranslationUnit {
  // This is the type checker entry point at the top level.  It
  // writes error messages (if any) into 'env' and annotations
  // directly into the AST fields declared below.
  //
  // Most of the AST classes have their own 'tcheck' or similar
  // function, though the exact calling convention (params, etc.)
  // varies.
  //
  // Some classes have an 'itcheck' (internal type check) for the
  // subclasses, meaning the superclass 'tcheck' does some common
  // processing and then delegates to the per-subclass 'itcheck.
  public void tcheck(Env &env);
}


class TopForm {
  pure_virtual void tcheck(Env &env);
}


class Function {
  // since 'nameAndParams->var' might refer to a previous declaration,
  // and therefore might have differently-named parameters, I'll add
  // another field specifically for a version of the FunctionType
  // which has the parameters for *this* definition
  public FunctionType *funcType;
  ctor funcType = NULL;

  // since the body of the function (if a class member) may refer
  // to the 'this' Variable, I need to write it down so client
  // analyses can find it
  public Variable *thisVar;  ctor thisVar=NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // if 'checkBody' is false, we treat this like it was just
  // a prototype for the function
  public void tcheck(Env &env, bool checkBody);

  private CompoundType *verifyIsCtor(Env &env, char const *context);
  private void tcheck_memberInits(Env &env);
  private void tcheck_handlers(Env &env);
}


class MemberInit {
  // if this is initializing a data member, tcheck will set this
  public Variable *member;  ctor member=NULL;

  // if it's a base class ctor call, tcheck will set this instead
  public CompoundType *base;  ctor base=NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }
}


class Declaration {                                   
  // adds declared variables to env; 'isMember' means that this
  // declaration appears just inside a class body
  public void tcheck(Env &env, bool isMember = false);
}


class ASTTypeId {
  // tcheck params for ASTTypeId
  public struct Tcheck {
    // when non-NULL, we're in an E_new, and this points to an
    // Expression* which should be set to the expression which denotes
    // the number of elements for new[] to allocate
    Expression **newSizeExpr;

    // when true, this ASTTypeId denotes a parameter; this knowledge
    // is used for disambiguation
    bool isParameter;

    // additional declflags to attach to the resulting Variable
    DeclFlags dflags;

  public:
    Tcheck() : newSizeExpr(NULL), isParameter(false), dflags(DF_NONE) {}
  };

  // the return value is the ASTTypeId* to store in place of the
  // one used to invoke the function, to resolve ambiguities
  public ASTTypeId *tcheck(Env &env, Tcheck &tc);
  public void mid_tcheck(Env &env, Tcheck &tc);

  public Type *getType() const;      // can use after calling 'tcheck'
}


class PQName {
  // typecheck the template arguments buried in this PQName
  pure_virtual void tcheck(Env &env);
}


class TypeSpecifier {
  // yield the type named by the specifier; this type may of course
  // get refined when the declarator is considered
  public Type *tcheck(Env &env, DeclFlags dflags);
  pure_virtual Type *itcheck(Env &env, DeclFlags dflags);

  // since several of the type specifiers use names, and names are
  // scoped, but we don't want later analyses to have to know about
  // scopes, for those specifiers that use names cc_tcheck writes down
  // which type it refers to

  -> TS_name {
       // typedef Variable this name refers to
       public Variable *var;  ctor var=NULL;
     }

  -> TS_elaborated {
       public NamedAtomicType *atype;  ctor atype=NULL;
     }

  -> TS_classSpec {
       public CompoundType *ctype;  ctor ctype=NULL;
       public void tcheckIntoCompound(
         Env &env, DeclFlags dflags, CompoundType *ct,
         bool inTemplate, CompoundType *containingClass);
       private void tcheckFunctionBodies(Env &env);
     }

  -> TS_enumSpec {
       public EnumType *etype;  ctor etype=NULL;
     }
}


class BaseClassSpec {
  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // the type named by the 'name'
  public CompoundType *type;  ctor type=NULL;
}


class Member {
  pure_virtual void tcheck(Env &env);
}


class Enumerator {
  public Variable *var;                 // (serf) introduction record
  ctor var=NULL;

  // when the enumerator values are computed, I store them here
  // so I can see them in the AST printout; I only print this
  // value if 'var' is non-NULL (i.e. the enumerator has been
  // tcheck'd so the value has been determined)
  public int enumValue;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // we pass both the base 'enum' and the Type wrapped around it,
  // since both are needed and it's slightly expensive to compute
  // one from the other for each enumerator
  public void tcheck(Env &env, EnumType *parentEnum, Type *parentType);
}


class Declarator {
  public Variable *var;                // (serf) computed information: name, type, etc.
  ctor var=NULL;
  public Type *type;
  ctor type=NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // this class contains the data passed into and out of the
  // declarator checking functions
  public struct Tcheck {
    // the bottom-most IDeclarator (D_name or D_bitfield) creates
    // or looks up a Variable, and sets this to point at it
    Variable *var;

    // on the way in, this is the type computed so far; initially
    // it's just the type specifier but additional declarators will
    // layer additional type constructors on top of it and replace
    // the pointer here with a pointer to the constructed type; at
    // the end it is the fully-constructed type
    //
    // however, it need not be the same type as var->type at the
    // end, because var->type might be a function type from a
    // prototype (with the prototype's parameter names) while this
    // field will be the constructed type with its own names
    Type *type;

    // these are the declflags attached to the outer declaration
    DeclFlags dflags;

    // in a new[] declarator, when we hit the final [size], stash
    // the size's AST node pointer here; then E_new can collect it
    Expression *size_E_new;

    // if this is non-NULL, then it points at the D_func responsible
    // for creating 'type, a FunctionType; this is used to determine
    // the cv flags of the implicit 'this' parameter of member functions
    D_func *funcSyntax;

    // syntactic context
    enum Context {
      CTX_ORDINARY  = 0x0,     // no particular context
      CTX_E_NEW     = 0x1,     // inside an E_new
      CTX_PARAM     = 0x2,     // in a parameter declarator
      CTX_GROUPING  = 0x4,     // in a grouping declarator, without inner pointer constructor
      //CTX_MEMBER    = 0x8,     // toplevel member declarator
    } context;

  public:
    Tcheck(Type *t, DeclFlags d)
      : var(NULL), type(t), dflags(d),
        size_E_new(NULL), funcSyntax(NULL),
        context(CTX_ORDINARY) {}
    Tcheck(Tcheck const &obj)
      : var(obj.var), type(obj.type), dflags(obj.dflags),
        size_E_new(obj.size_E_new), funcSyntax(obj.funcSyntax),
        context(obj.context) {}

    Tcheck& operator= (Tcheck const &obj) {
      var = obj.var;
      type = obj.type;
      dflags = obj.dflags;
      size_E_new = obj.size_E_new;
      context = obj.context;
      funcSyntax = funcSyntax;
      return *this;
    }

    // manipulate context
    void setInGrouping()    { context = (Context)(context | CTX_GROUPING); }
    void clearInGrouping()  { context = (Context)(context & ~CTX_GROUPING); }
    
    // TODO: delete these, and their call sites
    void setMember()        { /*context = (Context)(context | CTX_MEMBER);*/ }
    void clearMember()      { /*context = (Context)(context & ~CTX_MEMBER);*/ }
  };

  // determine the type denoted by the combination of 'dt.type' and
  // the type constructors in this declarator, then make a Variable
  // which has that type and store it in 'dt.var'; if this declarator
  // refers to something that is *already* declared (like a function
  // with a prior prototype), the 'var' field will be shared among the
  // various declarations; if not, put it into the environment
  //
  // the return value specifies which of possibly ambiguous
  // alternatives was selected
  public /*no_ignore*/ Declarator *tcheck(Env &env, Tcheck &dt);
  public void mid_tcheck(Env &env, Tcheck &dt);
}


class IDeclarator {
  // write down the type denoted by this type constructor, in
  // conjunction with the constructors that surround it, and the
  // type specifier
  public Type *type;  ctor type=NULL;

  // external interface; add the type constructor represented by this
  // IDeclarator to 'dt.type' and then make a Variable to represent
  // it; put the variable into the environment if appropriate
  pure_virtual void tcheck(Env &env, Declarator::Tcheck &dt);

  -> D_func {
       // I want to know which D_funcs are members of classes (whether
       // static or not), but it's not sufficient to just check my
       // environment context since I get confused by pointers to
       // functions.. so I set this to true in MR_decl::tcheck and
       // MR_func::tcheck
       public bool isMember;  ctor isMember=false;
     }

  -> D_array {
       // client analyses find it difficult to know whether this
       // D_array means "array" or "new[] size", so I'm going to
       // write down in cc_tcheck which one this is
       public bool isNewSize;  ctor isNewSize=false;
     }
}


class ExceptionSpec {
  public FunctionType::ExnSpec *tcheck(Env &env);
}


class Statement {
  // typecheck, and return which Statement is selected from among
  // syntactically ambiguous choices
  public /*no_ignore*/ Statement *tcheck(Env &env);

  public void mid_tcheck(Env &env, int &) { itcheck(env); };
  pure_virtual void itcheck(Env &env);
}


class Condition {
  pure_virtual void tcheck(Env &env);
}


class Handler {
  public void tcheck(Env &env);
}


class Expression {
  // type check and yield the type of the expression; this type
  // gets automatically stored in the 'type' field; the return
  // value specifies which of possibly ambiguous alternatives
  // was selected for retention
  public void tcheck(Env &env, Expression *&ptr);
  public void mid_tcheck(Env &env, Expression *&replacement);

  // per-type checker; return type this expression eval's to; if
  // this Expression would like to rewrite itself, then it can put
  // the new Expression into 'replacement' and the parent AST node
  // will be updated accordingly; the caller should always put the
  // receiver object pointer into 'replacement' initially
  pure_virtual Type *itcheck(Env &env, Expression *&replacement);

  // type computed for this expression; might be a SimpleType for
  // ST_ERROR, in which case a subsequent attempt to typecheck the
  // same expression should stop and look for an ambiguous alt.
  public Type *type;
  ctor type=NULL;
  custom clone { ret->type = type; }

  // const-eval; will add an error message to the environment if this
  // expression is not a constant (and also return false); can only
  // call this after tchecking
  public bool constEval(Env &env, int &result) const;
  
  // version that puts the message, if any, in 'msg'; note that it
  // might not actually put anything in 'msg' even for a false return
  public bool constEval(string &msg, int &result) const;

  // return true if this expression has any greater-than operators
  // that are not buried under an E_grouping
  public bool hasUnparenthesizedGT() const;

  // return what kind of special expression this is, if any
  public SpecialExpr getSpecial() const;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // interpretations of literals
  -> E_intLit      { public unsigned long i;  ctor i=0; }
  -> E_floatLit    { public double d;         ctor d=0; }
  -> E_stringLit   { /* TODO: put a DataBlock here */ }
  -> E_charLit     { public unsigned int c;   ctor c=0; }

  -> E_variable {
       public Variable *var;      // (serf) binding introduction of this name
       ctor var=NULL;
       custom clone { ret->var = var; }
     }

  // these two kinds have their tcheck further split into two stages
  // so I can use a more specialized disambiguation procedure; the
  // first stage is sufficient to disambiguate between thet two
  -> E_funCall {
       public void inner1_itcheck(Env &env);
       public Type *inner2_itcheck(Env &env);
     }
  -> E_constructor {
       public void inner1_itcheck(Env &env);
       public Type *inner2_itcheck(Env &env);
     }

  -> E_fieldAcc {
       public Variable *field;
       ctor field=NULL;
       custom clone { ret->field = field; }
     }

  -> E_sizeof {
       public int size;     // size of the type of expr
       ctor size=-1;
       custom clone { ret->size = size; }
     }

  -> E_sizeofType {
       public int size;     // size of the type
       ctor size=-1;
       custom clone { ret->size = size; }
     }

  // Q: should I manually clone all the annotation fields?  Do I
  // need them all?  Should I make a new mechanism in astgen to do
  // this automatically?

  -> E_new {
       // if this is non-NULL, it's the number of elements to allocate via new[]
       public Expression /*nullable serf*/ *arraySize;
       ctor arraySize=NULL;
     }
}


class ICExpression {
  // implicit conversion; stored in compressed form
  public CompressedImplicitConversion cic;

  public void tcheck(Env &env);

  // might be convenient
  public Type *getType() { return expr->type; };

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }
}


class Initializer {
  // check that the initializer is well-typed, given the type of
  // the thing it initializes
  pure_virtual void tcheck(Env &env, Type *type);

  -> IN_ctor() {
       public Variable *cfunc;      // constructor function being called
       ctor cfunc=NULL;
       custom clone { ret->cfunc = cfunc; }
     }
}


class TemplateDeclaration {
  public void tcheck(Env &env);
  pure_virtual void itcheck(Env &env);

  -> TD_class {
       public Type *type;  ctor type=NULL;     // defined type

       public void printExtras(ostream &os, int indent) const;
       custom debugPrint { printExtras(os, indent); }
     }
}


class TemplateParameter {
  pure_virtual void tcheck(Env &env, TemplateParams *tparams);
  
  -> TP_type {
       // stand-in for the type used when checking the body; it's
       // always a CVAtomic wrapped around a TypeVariable
       public CVAtomicType *type;  ctor type=NULL;
     }
}


class TemplateArgument {
  // same scheme as for Statement
  public /*no_ignore*/ TemplateArgument *tcheck(Env &env);
  public void mid_tcheck(Env &env, int &) { itcheck(env); };
  pure_virtual void itcheck(Env &env);
  
  // semantically resolved argument; the tcheck pass resolves
  // the argument if it can (and if it can't, then this won't
  // be usable to instantiate a template)
  public STemplateArgument sarg;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }
}
