// cc_tcheck.ast            see license.txt for copyright and terms of use
// extension module for cc.ast that defines the entry points
// for the type checker, and the annotations it produces

// the implementation for the functions declared here is in
// cc_tcheck.cc and cc_ast_aux.cc


// extension modules' first "verbatim" section goes after
// the initial verbatims from the base, but before any
// of the classes from the base
verbatim {
  #include "variable.h"      // Variable
  #include "cc_type.h"       // Type, FunctonType, CompoundType
  #include "template.h"      // STemplateArgument

  class Env;                 // cc_env.h
}


class TranslationUnit {
  // This is the type checker entry point at the top level.  It
  // writes error messages (if any) into 'env' and annotations
  // directly into the AST fields declared below.
  //
  // Most of the AST classes have their own 'tcheck' or similar
  // function, though the exact calling convention (params, etc.)
  // varies.
  //
  // Some classes have an 'itcheck' (internal type check) for the
  // subclasses, meaning the superclass 'tcheck' does some common
  // processing and then delegates to the per-subclass 'itcheck.
  public void tcheck(Env &env);
}


class TopForm {
  public /*no_ignore*/ TopForm *tcheck(Env &env);
  pure_virtual void itcheck(Env &env);
}


class Function {
  // has this function been typechecked with checkBody=true?
  public bool hasBodyBeenTChecked = false;

  // since 'nameAndParams->var' might refer to a previous declaration,
  // and therefore might have differently-named parameters, I'll add
  // another field specifically for a version of the FunctionType
  // which has the parameters for *this* definition
  public FunctionType *funcType = NULL;

  // since the body of the function (if a class member) may refer
  // to the receiver object, I need to write it down so client
  // analyses can find it
  //
  // 7/29/04: combined this with the old 'ctorReceiver'
  public Variable *receiver = NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // if 'checkBody' is false, we treat this like it was just
  // a prototype for the function; if 'instV' is not NULL, then
  // force the declarator 'nameAndParams' to refer to it instead
  // of using the usual lookup/creation mechanism
  public void tcheck(Env &env, bool checkBody, Variable *instV = NULL);
  
  // this is where we end up if 'checkBody' is true
  public void tcheckBody(Env &env);

  private CompoundType *verifyIsCtor(Env &env, char const *context);
  private void tcheck_memberInits(Env &env);
  private void tcheck_handlers(Env &env);
}


class MemberInit {
  // if this is initializing a data member, tcheck will set this
  public Variable *member = NULL;

  // if it's a base class ctor call, tcheck will set this instead
  public CompoundType *base = NULL;

  // the constructor used to initialize the member or subobject
  // (can't call it "ctor".. that's an astgen keyword.. doh)
  public Variable *ctorVar = NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  custom clone {
    ret->member = member;
    ret->base = base;
    ret->ctorVar = ctorVar;
  }

  public void tcheck(Env &env, CompoundType *enclosing);
}


class Declaration {                                   
  public void tcheck(Env &env, DeclaratorContext context);
}


class ASTTypeId {
  // tcheck params for ASTTypeId
  public struct Tcheck {
    // when non-NULL, we're in an E_new, and this points to an
    // Expression* which should be set to the expression which denotes
    // the number of elements for new[] to allocate
    Expression **newSizeExpr;

    // additional declflags to attach to the resulting Variable;
    // when this includes DF_PARAMETER, it's a function parameter,
    // which knowledge can be applied towards disambiguation
    DeclFlags dflags;
    
    // syntactic context
    DeclaratorContext context;

  public:
    Tcheck(DeclFlags df, DeclaratorContext dc)
      : newSizeExpr(NULL), dflags(df), context(dc) {}
  };

  // the return value is the ASTTypeId* to store in place of the
  // one used to invoke the function, to resolve ambiguities
  public ASTTypeId *tcheck(Env &env, Tcheck &tc);
  public void mid_tcheck(Env &env, Tcheck &tc);

  public Type *getType() const;      // can use after calling 'tcheck'
}


class PQName {
  // typecheck the template arguments buried in this PQName
  //
  // 8/01/04: Go all the way to looking up the scopes denoted by the
  // qualifiers.  'scope' is the scope denoted by the qualifiers seen
  // so far, or NULL to mean "current scope", and 'lflags' might be
  // LF_DECLARATOR if this PQName is the name of a declarator.
  pure_virtual void tcheck(Env &env, Scope *scope = NULL, 
                           LookupFlags lflags = LF_NONE);

  -> PQ_qualifier {
       // record the scope denoted by this qualifier; name the
       // associated variable instead of the scope directly so we can
       // use 'dependentVar' when the denoted scope is dependent on a
       // template parameter
       public Variable *denotedScopeVar = NULL;
       custom debugPrint {
         ind(os, indent) << "denotedScopeVar: " << refersTo(denotedScopeVar) << "\n";
       }
     }
}


class TypeSpecifier {
  // yield the type named by the specifier; this type may of course
  // get refined when the declarator is considered
  public Type *tcheck(Env &env, DeclFlags dflags);
  pure_virtual Type *itcheck(Env &env, DeclFlags dflags);

  // since several of the type specifiers use names, and names are
  // scoped, but we don't want later analyses to have to know about
  // scopes, for those specifiers that use names cc_tcheck writes down
  // which type it refers to

  -> TS_name {
       // typedef Variable this name refers to
       public Variable *var = NULL;
     }

  -> TS_elaborated {
       public NamedAtomicType *atype = NULL;
     }

  -> TS_classSpec {
       public CompoundType *ctype = NULL;
       public void tcheckIntoCompound(
         Env &env, DeclFlags dflags, CompoundType *ct,
         bool checkMethodBodies);
       private void tcheckFunctionBodies(Env &env);
     }

  -> TS_enumSpec {
       public EnumType *etype = NULL;
     }
}


class BaseClassSpec {
  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // the type named by the 'name'
  public CompoundType *type = NULL;
}


class Member {
  pure_virtual void tcheck(Env &env);
}


class Enumerator {
  public Variable *var;                 // (serf) introduction record
  ctor var=NULL;

  // when the enumerator values are computed, I store them here
  // so I can see them in the AST printout; I only print this
  // value if 'var' is non-NULL (i.e. the enumerator has been
  // tcheck'd so the value has been determined)
  public int enumValue;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // we pass both the base 'enum' and the Type wrapped around it,
  // since both are needed and it's slightly expensive to compute
  // one from the other for each enumerator
  public void tcheck(Env &env, EnumType *parentEnum, Type *parentType);
}


// The "Declarator" AST node appears in many different contexts in the
// AST, and visitor-based analyses often need to do quite different
// things depending on which context a declarator appears in.  So,
// this enumeration lists all the possible contexts.
enum DeclaratorContext {
  DC_UNKNOWN,             // dummy value; nothing should have this after tcheck

  DC_FUNCTION,            // Function::nameAndParams
                          // inside Declaration
  DC_TF_DECL,             //   TF_decl::decl
  DC_MR_DECL,             //   MR_decl::d
  DC_S_DECL,              //   S_decl::decl
  DC_TD_PROTO,            //   TD_proto::d
                          // inside ASTTypeId
  DC_D_FUNC,              //   D_func::params
  DC_EXCEPTIONSPEC,       //   ExceptionSpec::types
  DC_ON_CONVERSION,       //   ON_conversion::type
  DC_CN_DECL,             //   CN_decl::typeId
  DC_HANDLER,             //   Handler::typeId
  DC_E_CAST,              //   E_cast::ctype
  DC_E_SIZEOFTYPE,        //   E_sizeofType::atype
  DC_E_NEW,               //   E_new::atype (new)
  DC_E_KEYWORDCAST,       //   E_keywordCast::ctype
  DC_E_TYPEIDTYPE,        //   E_typeidType::ttype
  DC_TP_TYPE,             //   TP_type::defaultType
  DC_TP_NONTYPE,          //   TP_nontype::param
  DC_TA_TYPE,             //   TA_type::type
};


class Declarator {
  // entity declared by this declarator
  public Variable *var = NULL;          // (serf) computed information: name, type, etc.

  // This field need not be identical to 'var->type'; the 'type' here
  // comes directly from the declartor syntax, but 'var' might refer
  // to a previous declaration (e.g. two protoypes of the same
  // function), and hence 'var->type' might differ in details like
  // parameter names.  Otherwise, nominally, 'var->type' and 'type'
  // denote equivalent types.
  public Type *type = NULL;

  // syntactic context; sometimes useful to visitors
  public DeclaratorContext context = DC_UNKNOWN;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // this class contains the data passed into and out of the
  // declarator checking functions
  public struct Tcheck {
    // Normally, a declarator creates a Variable and inserts it
    // into the environment.  If this field is non-NULL, then the
    // declarator simply uses the supplied Variable instead.
    // Either way, the Variable* is then stored in Declarator::var.
    Variable *existingVar;

    // on the way in, this is the type computed so far; initially
    // it's just the type specifier but additional declarators will
    // layer additional type constructors on top of it and replace
    // the pointer here with a pointer to the constructed type; at
    // the end it is the fully-constructed type
    Type *type;

    // these are the declflags attached to the outer declaration
    DeclFlags dflags;

    // in a new[] declarator, when we hit the final [size], stash
    // the size's AST node pointer here; then E_new can collect it
    Expression *size_E_new;

    // if this is non-NULL, then it points at the D_func responsible
    // for creating 'type', a FunctionType; this is used to determine
    // the cv flags of the implicit 'this' parameter of member functions
    D_func *funcSyntax;

    // syntactic context
    DeclaratorContext context;

  public:
    Tcheck(Type *t, DeclFlags d, DeclaratorContext dc)
      : existingVar (NULL)
      , type        (t)
      , dflags      (d)
      , size_E_new  (NULL)
      , funcSyntax  (NULL)
      , context     (dc)
    {}
    Tcheck(Tcheck const &obj)
      : existingVar (obj.existingVar)
      , type        (obj.type)
      , dflags      (obj.dflags)
      , size_E_new  (obj.size_E_new)
      , funcSyntax  (obj.funcSyntax)
      , context     (obj.context)
    {}
    Tcheck& operator= (Tcheck const &obj) {
      existingVar = obj.existingVar;
      type        = obj.type;
      dflags      = obj.dflags;
      size_E_new  = obj.size_E_new;
      funcSyntax  = obj.funcSyntax;
      context     = obj.context;
      return *this;
    }

    bool hasFlag(DeclFlags f) const { return !!(dflags &f); }
  };

  // determine the type denoted by the combination of 'dt.type' and
  // the type constructors in this declarator, then make a Variable
  // that has that type; if this declarator refers to something that
  // is *already* declared (like a function with a prior prototype),
  // the 'var' field will be shared among the various declarations; if
  // not, put it into the environment
  //
  // the return value specifies which of possibly ambiguous
  // alternatives was selected
  public /*no_ignore*/ Declarator *tcheck(Env &env, Tcheck &dt);
  public void mid_tcheck(Env &env, Tcheck &dt);
  public void tcheck_init(Env &env);
}


class IDeclarator {
  // 8/11/04: There used to be a 'type' field here, but I decided that
  // analyses probably have no need to know about the types denoted by
  // IDeclarators, only that denoted by the full Declarator, which is
  // stored in Declarator::type.

  // external interface; add the type constructor represented by this
  // IDeclarator to 'dt.type'
  pure_virtual void tcheck(Env &env, Declarator::Tcheck &dt);

  // returns true if there is a D_grouping that does not have
  // any D_pointer or D_ptrToMember inside it
  public bool hasInnerGrouping() const;

  -> D_func {
       // I want to know which D_funcs are members of classes (whether
       // static or not), but it's not sufficient to just check my
       // environment context since I get confused by pointers to
       // functions.. so I set this to true in MR_decl::tcheck and
       // MR_func::tcheck
       public bool isMember = false;
     }

  -> D_array {
       // client analyses find it difficult to know whether this
       // D_array means "array" or "new[] size", so I'm going to
       // write down in cc_tcheck which one this is
       public bool isNewSize = false;
     }
}


class ExceptionSpec {
  public FunctionType::ExnSpec *tcheck(Env &env);
}


class OperatorName {
  public void tcheck(Env &env);
}


class Statement {
  // typecheck, and return which Statement is selected from among
  // syntactically ambiguous choices
  public /*no_ignore*/ Statement *tcheck(Env &env);

  public void mid_tcheck(Env &env, int &);
  pure_virtual void itcheck(Env &env);

  -> S_case {
       // the case label must be an integer; this its value
       public int labelVal = 0;
     }
}


class Condition {
  // typecheck, and return which Condition is selected from among
  // syntactically ambiguous choices
  public /*no_ignore*/ Condition *tcheck(Env &env);
  public void mid_tcheck(Env &env, int &) { itcheck(env); };
  pure_virtual void itcheck(Env &env);
}


class Handler {
  public void tcheck(Env &env);
}


class Expression {
  // type check and yield the type of the expression; this type
  // gets automatically stored in the 'type' field; the return
  // value specifies which of possibly ambiguous alternatives
  // was selected for retention
  public void tcheck(Env &env, Expression *&ptr);
  public void mid_tcheck(Env &env, Expression *&replacement);

  // per-type checker; return type this expression eval's to; if
  // this Expression would like to rewrite itself, then it can put
  // the new Expression into 'replacement' and the parent AST node
  // will be updated accordingly; the caller should always put the
  // receiver object pointer into 'replacement' initially
  //
  // the "_x" is for grepping value; think of it as standing for 'eXpression'
  pure_virtual Type *itcheck_x(Env &env, Expression *&replacement);

  // type computed for this expression; might be a SimpleType for
  // ST_ERROR, in which case a subsequent attempt to typecheck the
  // same expression should stop and look for an ambiguous alt.
  public Type *type = NULL;
  custom clone { ret->type = type; }

  // make the API for getting the type identical to that of FullExpression
  public Type *getType() { return type; };

  // const-eval; will add an error message to the environment if this
  // expression is not a constant (and also return false); can only
  // call this after tchecking
  public bool constEval(Env &env, int &result) const;
  
  // version that puts the message, if any, in 'msg'; note that it
  // might not actually put anything in 'msg' even for a false return
  public bool constEval(string &msg, int &result) const;
  public virtual bool extConstEval(string &msg, int &result) const;

  // return true if this expression has any greater-than operators
  // that are not buried under an E_grouping
  public bool hasUnparenthesizedGT() const;
  public virtual bool extHasUnparenthesizedGT() const;

  // return what kind of special expression this is, if any
  public SpecialExpr getSpecial() const;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // interpretations of literals
  -> E_intLit      { public unsigned long i = 0; }
  -> E_floatLit    { public double d = 0; }
  -> E_stringLit   { /* TODO: put a DataBlock here */ }
  -> E_charLit     { public unsigned int c = 0; }

  -> E_this {                              
       // the receiver parameter to which this 'this' refers; NOTE
       // that 'receiver' is a *reference* whereas E_this is a
       // *pointer* (it's like taking the address of 'receiver')
       public Variable *receiver = NULL;
       custom clone { ret->receiver = receiver; }
     }

  -> E_variable {
       public Variable *var = NULL;      // (serf) binding introduction of this name
       public Type *itcheck_var(Env &env, LookupFlags flags);
       custom clone { ret->var = var; }
     }

  // these two kinds have their tcheck further split into two stages
  // so I can use a more specialized disambiguation procedure; the
  // first stage is sufficient to disambiguate between the two
  -> E_funCall {
       public void inner1_itcheck(Env &env);
       public Type *inner2_itcheck(Env &env);
     }
  -> E_constructor {
       public void inner1_itcheck(Env &env);
       public Type *inner2_itcheck(Env &env, Expression *&replacement);

       // the constructor function being called
       public Variable *ctorVar = NULL;
       custom clone { ret->ctorVar = ctorVar; }
     }

  -> E_fieldAcc {
       public Variable *field = NULL;
       public Type *itcheck_fieldAcc(Env &env, LookupFlags flags);
       custom clone { ret->field = field; }
     }

  -> E_sizeof {
       public int size = -1;     // size of the type of expr
       custom clone { ret->size = size; }
     }

  -> E_sizeofType {
       public int size = -1;     // size of the type
       custom clone { ret->size = size; }
     }

  // Q: should I manually clone all the annotation fields?  Do I
  // need them all?  Should I make a new mechanism in astgen to do
  // this automatically?

  -> E_new {
       // if this is non-NULL, it's the number of elements to allocate via new[]
       public Expression /*nullable serf*/ *arraySize = NULL;

       // constructor being called to initialize the storage
       public Variable *ctorVar = NULL;
       custom debugPrint { ind(os,indent) << "ctorVar: " << refersTo(ctorVar) << "\n"; }
       custom clone { ret->ctorVar = ctorVar; }
     }
}


class FullExpression {
  public void tcheck(Env &env);

  // duplicate the API of Expression and delegate all the calls down
  // to the Expression *expr member
  public Type *getType() const
    { return expr->type; };
  public bool constEval(Env &env, int &result) const
    { return expr->constEval(env, result); };
  public bool constEval(string &msg, int &result) const
    { return expr->constEval(msg, result); };
}


class ArgExpression {
  // repeat some of Expression's interface so I can avoid adding
  // lots of annoying "expr->expr" clutter
  public Type *getType() const
    { return expr->type; };
  public bool constEval(Env &env, int &result) const
    { return expr->constEval(env, result); };
  public bool constEval(string &msg, int &result) const
    { return expr->constEval(msg, result); };
  public bool hasUnparenthesizedGT() const
    { return expr->hasUnparenthesizedGT(); };
  public SpecialExpr getSpecial() const
    { return expr->getSpecial(); };

  public ArgExpression *tcheck(Env &env);
  public void mid_tcheck(Env &env, int &);
}


class Initializer {
  // check that the initializer is well-typed, given the type of
  // the thing it initializes
  pure_virtual void tcheck(Env &env, Type *type);

  -> IN_ctor() {
       public Variable *ctorVar = NULL;      // constructor function being called
       custom clone { ret->ctorVar = ctorVar; }
     }
}


class TemplateDeclaration {
  public void tcheck(Env &env);
  pure_virtual void itcheck(Env &env);

  -> TD_class {
       public Type *type = NULL;     // defined type

       public void printExtras(ostream &os, int indent) const;
       custom debugPrint { printExtras(os, indent); }
     }
}


class TemplateParameter {
  pure_virtual void tcheck(Env &env, SObjList<Variable> &tparams);
  
  -> TP_type {
       // stand-in for the type used when checking the body; it's
       // always a CVAtomic wrapped around a TypeVariable
       public CVAtomicType *type = NULL;
     }
}


class TemplateArgument {
  // same scheme as for Statement
  public /*no_ignore*/ TemplateArgument *tcheck(Env &env);
  public void mid_tcheck(Env &env, int &) { itcheck(env); };
  pure_virtual void itcheck(Env &env);
  
  // semantically resolved argument; the tcheck pass resolves
  // the argument if it can (and if it can't, then this won't
  // be usable to instantiate a template)
  public STemplateArgument sarg;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }
}


class NamespaceDecl {
  pure_virtual void tcheck(Env &env);
}


// EOF
