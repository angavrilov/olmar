// cc_elaborate.ast            see license.txt for copyright and terms of use
// extension to cc.ast defining data for an elaboration pass

// The concept of semantic elaboration is that we provide, for many
// constructs in the language, equivalent alternative formulations in
// terms of a smaller set of primitive operations.  Then, an analysis
// can ignore the elaborated constructs' specified semantics, instead
// using the elaboration annotation to understand them.
//
// Of course, an analysis is free to ignore the elaboration if the
// original construct maps more naturally into its analysis domain.

verbatim {
  #include "cc_elaborate.h"      // FullExpressionAnnot
}


class Function {
  // NOTE!: If this function is a ctor, then the semantics is as if we
  // have this line in the code before the MemberInit-s:
  //   this = &retval;
}


class MemberInit {
  // A single MemberInit seems very much like a single expression to
  // me, since it is a ctor call and an IN_ctor is also
  public FullExpressionAnnot annot;

  // a MemberInit calls a ctor
  public Statement *ctorStatement; ctor ctorStatement=NULL;
}


class Declarator {
  // each declarator has a construction statement, that does its
  // initialization, and a destruction statement, that calls any
  // needed destructors; the latter is to be evaluated when this
  // declarator goes out of scope
  public Statement *ctorStatement = NULL;
  public Statement *dtorStatement = NULL;

  public void elaborateCDtors(Env &env);
}


class IDeclarator {
  -> D_func {
//         // elaborate the parameters
//         public void elaborateParameterCDtors(Env &env);
  }
}


class FullExpression {
  public FullExpressionAnnot annot;
}


class Expression {
  -> E_funCall {
    // Pass by value (for class-valued objects) is elaborated by saying there
    // is another function parameter, the 'return object'.  At the call site,
    // we specify an object (reference) that will be bound to that parameter,
    // and the function implementation is expected to write to that object.
    public Expression *retObj = NULL;
  }

  -> E_constructor {        
    // did we manufacture it? needed during elaboration
    public bool artificial = false;

    // similar to E_funCall; object being constructed
    public Expression *retObj = NULL;

    // The variable being ctored; NULL means it is for a temporary
    // and a Declaration for that temporary should be created
    // during typechecking.
    // dsw: this comment copied from E_variable; is it still
    // relevant??: (serf) binding introduction of this name
    public Variable *var = NULL;
    custom clone { ret->var = var; } // dsw: do I need this?
  }
  
  -> E_new {
    // this statement implements the 'new' operation in terms of more
    // primitive concepts like allocation and calling the constructor;
    // after elaboration, and analysis can just ignore the E_new and
    // look at the 'ctorStatement' instead
    public Statement *ctorStatement = NULL;

    // I need a place to put the variable being ctored because
    // E_constructor needs to point at a variable; copied comment
    // from Declarator::var:
    // (serf) computed information: name, type, etc.
    public Variable *var = NULL;
  }

  -> E_delete {
    // this implementes destruction and deallocation
    public Statement *dtorStatement = NULL;
  }
  
  -> E_throw {
    // the global that the throw argument is copy-ctored into, if
    // thrown by value; copied comment from Declarator::var: (serf)
    // computed information: name, type, etc.
    public Variable *globalVar = NULL;
    public Statement *ctorStatement; ctor ctorStatement=NULL;
  }
}


class Initializer {
  // [cppstd 1.9 para 12 and 13] "A full-expression is an expression
  // that is not a subexpression of another expression.  If a language
  // construct is defined to produce an implicit call of a function, a
  // use of the language construct is considered to be an expression
  // for the purposes of this definition.

  // [Note: certain contexts in C++ cause the evaluation of a
  // full-expression that results from a syntactic construct other
  // than expression (5.18).  For example, in 8.5, another syntax for
  // initializer is '( expression-list )' but the resulting construct
  // is a function call upon a constructor function with
  // expression-list as an argument list; such a function call is a
  // full-expression.  For example, in 8.5, another syntax for
  // initializer is '= initializer-clause' but again the resulting
  // construct might be a function call upon a constructor function
  // with one assignment-expression as an argument; again, the
  // function call is a full-expression. ]

  // Therefore, the arguments to IN_ctor and IN_expr are *not*
  // FullExpressions because the whole of Initializer is.  I think the
  // FullExpressionAnnot is redundant in the case of IN_compound, but
  // I like sharing it in Initializer and an extra layer doesn't hurt.

  // TODO: sm: Currently, we associate a FullExpressionAnnot with
  // Initializer, which means we get one for every element of a
  // compound initializer.  This wastes a lot of space, and doesn't
  // make sense for IN_compound.  I think we should say that (only)
  // the entire initializer is a single Full Expression, but that
  // requires adding another layer, like:
  //
  //   Initializer                   // has FullExpressionAnnot
  //     -> IN_cinit(CInitializer)
  //     -> IN_ctor(..)
  //   CInitializer                  // "C" for compound
  //     -> CI_expr
  //     -> CI_compound(..)
  //
  // But I'll leave it for now.

  public FullExpressionAnnot annot;
}


// EOF
