// -*- c++ -*-                                                         *
//  Copyright 2006 Hendrik Tews, All rights reserved.                  *
//  See file license.txt for terms of use                              *
//                                                                     *
// cc.ast            C++ abstract syntax: type nodes                   *
//**********************************************************************


// NOTE: This file is only used for the Ocaml part. The real elsa C++ type 
// nodes are still coming from hand-written C++ code in variable.h, 
// template.h. This file must be kept somehow in sync with those type 
// definitions. 

class Variable (
  SourceLoc loc,          // location of the name in the source text
  nullable StringRef name,

  // HT: circular pointer for compound types that have an 
  // implicit typedef variable (whatever the latter is)
  nullable circular CType *type,              // owner or serf?
  DeclFlags flags,
  nullable circular Expression *varValue,     // (serf)
  nullable CType *defaultParamType,           // (serf)
  nullable circular Function *funcDefn,       // (serf)
  nullable OverloadSet *overload,             // (serf)
  SObjSet<Variable*> *virtuallyOverride,
  nullable Scope *scope			      // (serf)
  ) 
{ 
  private(nullable, field) TemplateInfo templInfo; // (owner)
}


class OverloadSet (
  SObjList<Variable> set
  ) { }


class TemplateInfo (
  SObjList<Variable> params,
  // HT: NULL in t0026.cc
  nullable Variable * var,				     // const (serf)
  ObjList<InheritedTemplateParams> inheritedParams,
  nullable circular Variable * instantiationOf,		     // const (serf)
  SObjList<Variable> instantiations,
  // HT: NULL in t0026.cc or 27
  nullable circular Variable * specializationOf,	     // const (serf)
  SObjList<Variable> specializations,
  ObjList<STemplateArgument> arguments,
  SourceLoc instLoc,
  nullable circular Variable * partialInstantiationOf,	     // const (serf)
  SObjList<Variable> partialInstantiations,
  ObjList<STemplateArgument> argumentsToPrimary,
  nullable Scope *defnScope,
  nullable TemplateInfo definitionTemplateInfo,		    // (owner)
  bool instantiateBody,
  bool instantiationDisallowed,
  int uninstantiatedDefaultArgs,
  SObjList<CType> dependentBases
  ) 
  { 
  private(field) TemplateThingKind kind;
  }


class InheritedTemplateParams (
  SObjList<Variable> params,
  // circular in in/t0224.cc
  // not nullable, will always contain something 
  circular CompoundType *enclosing          // (serf)
  ) { }


class BaseClass (
  CompoundType * ct,
  AccessKeyword access,
  bool isVirtual
  ) {}

// BaseClassSubobj inherits from BaseClass
class BaseClassSubobj (
  CompoundType * ct,
  AccessKeyword access,
  bool isVirtual,
  SObjList<BaseClassSubobj> parents
  ) {}

class EnumValue(
  StringRef name, 
  nativeint val_value
  ) {}


class AtomicType () {
  -> SimpleType(SimpleTypeId type);

  -> CompoundType(
       nullable StringRef name, 
       Variable typedefVar, 
       AccessKeyword access,
       BoolValue forward,
       BoolValue isTransparentUnion,
       CompoundKeyword keyword,
       SObjList<Variable> dataMembers,
       ObjList<BaseClassSubobj> virtualBases,
       SObjList<Variable> conversionOperators,
       SObjList<Variable> friends,
       nullable StringRef instName,
       nullable TS_classSpec * syntax,
       nullable CType * selfType
       ) {
       private(field) Scope compound_scope;	// Scope ancestor
       private(field) ObjList<BaseClass> bases;       
       }


  -> EnumType(
       nullable StringRef name, 
       nullable Variable typedefVar, 
       AccessKeyword access,
       StringObjDict<EnumValue> valueIndex,
       bool hasNegativeValues
       );

  -> PseudoInstantiation(
       StringRef name, 
       nullable Variable typedefVar, 
       AccessKeyword access,
       CompoundType * primary,	// serf??
       ObjList<STemplateArgument> args
       );

  -> TypeVariable(
       StringRef name, 
       Variable typedefVar, 
       AccessKeyword access
       );

  -> DependentQType(
       StringRef name, 
       Variable typedefVar, 
       AccessKeyword access,
       AtomicType * first,
       PQName * rest		// serf??
       );
}


// ExnSpec is a inner class of FunctionType
class FunctionExnSpec (
  SObjList<CType> types
  ) {}


class CType () {
  -> CVAtomicType(AtomicType * atomic, CVFlags cv);
  -> PointerType(CVFlags cv, CType * atType);
  -> ReferenceType(CType * atType);
  -> FunctionType(
        FunctionFlags flags, 
	CType * retType, 
	SObjList<Variable> params,
	FunctionExnSpec * exnSpec);
  // PDSArrayType(CType * eltType) is ancestor of 
  // ArrayType and DependentSizedArrayType
  -> ArrayType(CType * eltType, Array_size size);
  -> DependentSizedArrayType(CType * eltType, Expression * sizeExpr);
  -> PointerToMemberType(
        AtomicType * inClassNAT, 	      // really NamedAtomicType
	CVFlags cv, 
	CType * atType);
}


class STemplateArgument () {
  -> STA_NONE();
  -> STA_TYPE() {private(field) CType * t;}
  -> STA_INT() {private(field) int i;}
  -> STA_ENUMERATOR() {private(field) Variable * v;}
  -> STA_REFERENCE() {private(field) Variable * v;}
  -> STA_POINTER() {private(field) Variable * v;}
  -> STA_MEMBER() {private(field) Variable * v;}
  -> STA_DEPEXPR() {private(field) Expression * e;}
  -> STA_TEMPLATE();
  -> STA_ATOMIC() {private(field) AtomicType * at;}
}


class Scope (
  StringRefMap<Variable> variables,
  StringRefMap<Variable> typeTags,
  nullable Scope * parentScope,	// serf??
  ScopeKind scopeKind,
  nullable Variable * namespaceVar,	// serf??
  SObjList<Variable> templateParams,
  nullable Variable * parameterizedEntity
  ) {
  // the compound this scope can be downcasted to
  private(field, nullable) CompoundType * scope_compound; 
}


