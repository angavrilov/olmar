(*  Copyright 2006 Hendrik Tews, All rights reserved.                  *)
(*  See file license.txt for terms of use                              *)
(***********************************************************************)

open Printf
open More_string
open Meta_ast
open Ast_config


(******************************************************************************
 ******************************************************************************
 *
 * identifier utilities
 *
 ******************************************************************************
 ******************************************************************************)

let rec reflection_function_type_component = function
  | AT_list(lk, ml_type, _) ->
      (reflection_function_type_component ml_type) ^
	(match lk with
	   | LK_ast_list -> "_ast_list"
	   | LK_fake_list -> "_fake_list")

  | AT_node cl -> cl.ac_name
  | AT_base type_name -> type_name

let name_of_reflection_function ml_type = 
  "ocaml_reflect_" ^ (reflection_function_type_component ml_type)


(******************************************************************************
 ******************************************************************************
 *
 * type utilities
 *
 ******************************************************************************
 ******************************************************************************)

let rec string_of_ast_type = function
  | AT_list(_, el_type, _) -> (string_of_ast_type el_type) ^ " list"
  | AT_node cl -> 
      (match cl.ac_super with
	 | None ->
	     "'a " ^ (node_ml_type_name cl)
	 | Some super ->
	     sprintf "'a %s (* = %s *)"
	       (node_ml_type_name super)
	       (variant_name cl)
      )
  | AT_base type_name -> 
      (translate_olmar_name
	 None
	 (String.uncapitalize type_name))


(******************************************************************************
 ******************************************************************************
 *
 * type defintion
 *
 ******************************************************************************
 ******************************************************************************)

let record_field_hash = Hashtbl.create 1901

let check_record_field context field_name =
  if Hashtbl.mem record_field_hash field_name then begin
    eprintf "Warning: record label %s used both in %s and %s\n"
      field_name
      context
      (Hashtbl.find record_field_hash field_name)
  end
  else
    Hashtbl.add record_field_hash field_name context;
  field_name


(* remember tags that variant constructors get from the type definition *)
let constructor_tags = Hashtbl.create 557


let generate_record_type oc cl =
  output_string oc "{\n";
  (* annotation field *)
  fprintf oc "  %s : 'a;\n" 
    (check_record_field cl.ac_name (annotation_field_name cl));
  List.iter
    (List.iter
       (fun field ->
	  fprintf oc "  %s : %s;\n"
	    (check_record_field
	       cl.ac_name
	       (translate_olmar_name (Some cl.ac_name) field.af_name))
	    (string_of_ast_type field.af_mod_type)
       ))
    (get_all_fields cl);
  output_string oc "}\n"


let generate_variant_decl oc variant_count cl_sub =
  let fields = get_all_fields cl_sub
  in
    fprintf oc "  | %s of 'a" 
      (variant_name cl_sub);
    List.iter
      (List.iter
	 (fun field ->
	    assert(field.af_modifiers = []);
	    output_string oc " * ";
	    output_string oc (string_of_ast_type field.af_mod_type)))
      fields;
    output_string oc "\n";
    (* remember tag for this constructor *)
    Hashtbl.add constructor_tags cl_sub.ac_name !variant_count;
    incr variant_count
  

let generate_type_def first oc super = 
  if !first then begin
    first := false;
    pr_comment oc ["syntax tree type definition"; ""];
    output_string oc "type "
  end
  else 
    output_string oc "and ";
  fprintf oc "%s = " (string_of_ast_type (AT_node super));
  (match super.ac_subclasses with
     | [] -> generate_record_type oc super
     | subclasses ->
	 let variant_count = ref 0
	 in
	   output_string oc "\n";
	   List.iter 
	     (generate_variant_decl oc variant_count) 
	     subclasses
  );
  output_string oc "\n\n"


let generate_type_def_file source ast oc =
  pr_comment oc 
    [do_not_edit_line;
     "";
     "automatically generated by gen_reflection from " ^ source;
     "";
     "************************************************************************";
     "********************** Ast type definition *****************************";
     "************************************************************************";
    ];
  output_string oc "\n\n";

  if get_ocaml_type_header() <> [] 
  then
    pr_comment oc ["header from control file"; ""];
  List.iter 
    (fun line ->
       output_string oc line;
       output_string oc "\n"
    ) 
    (get_ocaml_type_header());
  output_string oc "\n\n";

  List.iter (generate_type_def (ref true) oc) ast
    


(******************************************************************************
 ******************************************************************************
 *
 * ocaml_reflection : declarations and function register
 *
 ******************************************************************************
 ******************************************************************************)

let reflection_type_hash = Hashtbl.create 571

let string_refl_func_header ml_type =
  sprintf "value %s(%s const * x, Ocaml_reflection_data * data)"
    (name_of_reflection_function ml_type)
    (match ml_type with
       | AT_list(lk, _, c_type) -> 
	   sprintf "%s<%s>" 
	     (match lk with
		| LK_ast_list -> "ASTList"
		| LK_fake_list -> "FakeList")
	     c_type

       | AT_node cl -> cl.ac_name
       | AT_base type_name -> type_name
    )

let rec generate_refl_decl oc ml_type =
  if not (Hashtbl.mem reflection_type_hash ml_type)
  then begin
    Hashtbl.add reflection_type_hash ml_type ();
    (* register function and output header *)
    (match ml_type with
       | AT_list _
       | AT_node _ ->
	   output_string oc (string_refl_func_header ml_type);
	   output_string oc ";\n";
       | AT_base _ ->
	   pr_c_comment oc
	     ["relying on extern";
	      string_refl_func_header ml_type]
    );
    (* check for needed utility functions *)
    match ml_type with
      | AT_list(_, inner, _) ->
	  generate_refl_decl oc inner
      | AT_node cl ->
	  (match cl.ac_super with
	     | Some super -> generate_refl_decl oc (AT_node super)
	     | None ->
		 List.iter 
		   (fun sub -> generate_refl_decl oc (AT_node sub))
		   cl.ac_subclasses
	  )
      | AT_base _ -> ()
  end


let generate_reflection_decls_top_nodes oc =
  List.iter
    (fun top -> 
       try
	 generate_refl_decl oc (AT_node (get_node top))
       with
	 | Not_found ->
	     eprintf "Warning: Requested top node %s not found\n" top
    )
    (get_ast_top_nodes())


let generate_reflection_decls oc node =
  let cls = node :: node.ac_subclasses in
  let fields_ll =
    List.map
      (fun cl -> [cl.ac_args; cl.ac_last_args; cl.ac_fields])
      cls
  in
    List.iter
      (List.iter
	 (List.iter
	    (fun field ->
	       generate_refl_decl oc field.af_mod_type)))
      fields_ll
      

(******************************************************************************
 ******************************************************************************
 *
 * ocaml_reflection : function definitions
 *
 ******************************************************************************
 ******************************************************************************)


(* generate a reflection for a variant or for a record, depending
 * on super_opt: if there is a super class do a variant, otherwise
 *  a record
 *)
let generate_block_reflection oc cl =
  let out = output_string oc in
  let fpf format = fprintf oc format in
  let fields = get_all_fields cl in
  let field_counter = ref 0
  in 
    out "  ";
    pr_c_comment oc
      [sprintf "reflect %s into a %s" 
	 cl.ac_name
	 (match cl.ac_super with
	    | None -> "record"
	    | Some _ -> "variant")];
    out "\n";
    out "  CAMLparam0();\n";
    out "  CAMLlocal2(res, child);\n";
    out "  res = find_ocaml_shared_node_value(x);\n";
    out "  if( res != Val_None ) {\n";
    out "    xassert(Is_block(res) && Tag_val(res) == 0);\n";
    out "    CAMLreturn(Field(res, 0));\n";
    out "  }\n\n";

    out "  if(data->stack.contains(x)) {\n";
    out "    cerr << \"cyclic ast detected during ocaml reflection\\n\";\n";
    out "    xassert(false);\n";
    out "  } else {\n";
    out "    data->stack.add(x);\n";
    out "  }\n";

    fpf "  res = caml_alloc(%d, %d);\n\n"
      (count_fields fields +1) 
      (match cl.ac_super with
	 | Some _ -> (Hashtbl.find constructor_tags cl.ac_name)
	 | None -> 0);
    
    out "  child = ocaml_ast_annotation(x, data);\n";
    fpf "  Store_field(res, %d, child);\n\n" !field_counter;
    incr field_counter;

    List.iter
      (List.iter
	 (fun field ->
	    fpf "  child = %s(%sx->%s, data);\n"
	      (name_of_reflection_function field.af_mod_type)
	      (if field.af_is_pointer then "" else "&")
	      field.af_name;
	    fpf "  Store_field(res, %d, child);\n\n" !field_counter;
	    incr field_counter
	 ))
      fields;

    out "  register_ocaml_shared_node_value(x, res);\n";
    out "  data->stack.remove(x);\n";
    out "  CAMLreturn(res);\n";
    out "}\n\n\n"


let generate_downcast_reflection oc super =
  let out = output_string oc in
  let fpf format = fprintf oc format 
  in
    out "  switch(x->kind()) {\n";
    List.iter 
      (fun sub ->
	 fpf "  case %s::%s:\n" 
	   super.ac_name
	   (String.uppercase sub.ac_name);
	 fpf "    return %s(x->as%sC(), data);\n\n"
	   (name_of_reflection_function (AT_node sub))
	   sub.ac_name
      )
      super.ac_subclasses;
    fpf "  case %s::NUM_KINDS:\n" super.ac_name;
    out "    xassert(false);\n";
    out "    break;\n";
    out "  }\n";
    out "  xassert(false);\n";

    out "}\n\n\n"


let generate_list_refl_defn oc lk ml_type c_type =
  let out = output_string oc in
  let (list_combi, iter_name, iter_access) =
    match lk with
      | LK_ast_list -> ("FOREACH_ASTLIST", "iter", "iter.data()")
      | LK_fake_list -> ("FAKELIST_FOREACH", "prt", "ptr")
  in
    out "  CAMLparam0();\n";
    out "  CAMLlocal4(res, tmp, elem, previous);\n";
    out "  res = find_ocaml_shared_list_value(x);\n";
    out "  if( res != Val_None ) {\n";
    out "    xassert(Is_block(res) && Tag_val(res) == 0);\n";
    out "    CAMLreturn(Field(res, 0));\n";
    out "  }\n\n";

    out "  previous = 0;\n\n";

    fprintf oc "  %s(%s, *x, %s) {\n" list_combi c_type iter_name;
    fprintf oc "    elem = %s(%s, data);\n"
      (name_of_reflection_function ml_type)
      iter_access;
    out "    tmp = caml_alloc(2, Tag_cons);\n";
    out "    Store_field(tmp, 0, elem);\n";
    out "    Store_field(tmp, 1, Val_emptylist);\n";
    out "    if(previous == 0) {\n";
    out "      res = tmp;\n";
    out "    } else {\n";
    out "      Store_field(previous, 1, tmp);\n";
    out "    }\n";
    out "    previous = tmp;\n";
    out "  }\n\n";

    out "  register_ocaml_shared_list_value(x, res);\n";
    out "  CAMLreturn(res);\n";
    out "}\n\n\n"

  
let generate_refl_defn oc ml_type =
  output_string oc (string_refl_func_header ml_type);
  output_string oc " {\n";
  match ml_type with
    | AT_list(lk, inner, c_type) ->
	generate_list_refl_defn oc lk inner c_type
    | AT_node cl ->
	if cl.ac_subclasses = []
	then
	  generate_block_reflection oc cl
	else
	  generate_downcast_reflection oc cl
    | AT_base _ -> assert false


let generate_ocaml_reflect_cc source header ast oc =
  let out = output_string oc 
  in
    pr_c_comment oc
      [do_not_edit_line;
       "";
       "automatically generated by gen_reflection from " ^ source;
       "";
       "**********************************************************************";
       "*************** Ocaml reflection tree traversal **********************";
       "**********************************************************************";
      ];
    out "\n\n";
    fprintf oc "#include \"%s\"\n" (Filename.basename header);
    out "\n\n";

    pr_c_comment oc
      ["**********************************************************************";
       "Reflection functions declarations";
      ];
    out "\n\n";
    generate_reflection_decls_top_nodes oc;
    List.iter (generate_reflection_decls oc) ast;
    output_string oc "\n\n";

    pr_c_comment oc 
      ["**********************************************************************";
       "Reflection functions definitions";
      ];
    output_string oc "\n\n";
    Hashtbl.iter 
      (fun ml_type () -> match ml_type with
    	 | AT_list _
    	 | AT_node _ -> generate_refl_defn oc ml_type
    	 | AT_base _ -> ()
      )
      reflection_type_hash;
    out "\n"


(******************************************************************************
 ******************************************************************************
 *
 * ocaml_reflection : top nodes include file
 *
 ******************************************************************************
 ******************************************************************************)

let generate_ocaml_reflect_h source this_file oc =
  let out = output_string oc in
  let fpf format = fprintf oc format in
  let cpp_symbol = 
    String.uppercase (translate "." "_" (Filename.basename this_file))
  in
    pr_c_comment oc
      [do_not_edit_line;
       "";
       "automatically generated by gen_reflection from " ^ source;
       "";
       "**********************************************************************";
       "****************** Ocaml reflection top node *************************";
       "**********************************************************************";
      ];
    out "\n";
    fpf "#ifndef %s\n" cpp_symbol;
    fpf "#define %s\n" cpp_symbol;
    out "\n\n";

    if get_ocaml_reflect_header() <> [] 
    then
      pr_c_comment oc ["header from control file"; ""];
    List.iter 
      (fun line ->
	 out line;
	 out "\n"
      ) 
      (get_ocaml_reflect_header());
    out "\n\n";

    pr_c_comment oc
      ["**********************************************************************";
       "Reflection functions declarations for the top node";
      ];
    out "\n\n";

    List.iter
      (fun top -> 
	 try
	   output_string oc (string_refl_func_header (AT_node (get_node top)));
	   output_string oc ";\n";
	 with
	   | Not_found -> ()
      )
      (get_ast_top_nodes());

    out "\n\n";
    fpf "#endif // %s\n" cpp_symbol


(******************************************************************************
 ******************************************************************************
 *
 * arguments and main
 *
 ******************************************************************************
 ******************************************************************************)


let output_prefix_option = ref None

let arguments = 
  [
    ("-o", Arg.String (fun s -> output_prefix_option := Some s),
     "out set output prefix to out");
  ]


let main () =
  let (oast_file, ast) = setup_ml_ast arguments "gen_reflection" in
  let output_prefix = match !output_prefix_option with
    | Some prefix -> prefix
    | None -> 
	if Filename.check_suffix oast_file ".oast" 
	then
	  Filename.chop_suffix oast_file ".oast"
	else
	  oast_file
  in
  let file ext = output_prefix ^ ext 
  in
  let with_file ext comment action =
    let file_name = file ext in
    let oc = open_out file_name
    in
      action oc;
      close_out oc;
      eprintf "wrote %s (%s)\n" file_name comment
  in
  let header_ext = "_ocaml_reflect.h"
  in
    with_file "_type.ml" "type definition" 
      (generate_type_def_file oast_file ast);
    with_file "_ocaml_reflect.cc" "ocaml reflection traversal"
      (generate_ocaml_reflect_cc oast_file (file header_ext) ast);
    with_file header_ext "ocaml reflection top node declaration"
      (generate_ocaml_reflect_h oast_file (file header_ext));
;;


try
  main()
with
  | Assert_failure(file, line, char) ->
      eprintf "File \"%s\", line %d, character %d: Assertion failure\n"
	file line char;
      exit 1


