; this file is a random collection of forms that I copy+paste  -*- lisp -*-
; into a Simplify session to test its behavior

; declare predicate P
(DEFPRED (P x))

; ----------------------- unique existence ------------------
; claim unique existence of an object which satisfies P
(BG_PUSH
  (EXISTS (x) (AND (P x)
                   (FORALL (y) (IMPLIES (P y) (EQ y x)))))
)

; call this object z
(BG_PUSH (P z))

; does Simplify agree that anything satisfying P must be z? yes!
(FORALL (y) (IMPLIES (P y) (EQ y z)))

; does Simplify think that anything satisfying P must be 3? no!
(FORALL (y) (IMPLIES (P y) (EQ y 3)))

; does Simplify think that there could be something besides z
; which satisfies P? no!
(EXISTS (q) (AND (P q) (NEQ q z)))

; moreover, it stops believing that anything satsifying P must
; be z once I BG_POP either of the assumptions
(BG_POP)
(BG_POP)


; -------------- existence of exactly two ------------------
; claim that exactly two things satisfy P
(BG_PUSH
  (EXISTS (x y) (AND (P x) (P y) (NEQ z y)
                     (FORALL (z) (IMPLIES (P z)
                                          (OR (EQ z x) (EQ z y))))))
)

; give names to these objects
(BG_PUSH (AND
  (P z1)
  (P z2)
  (NEQ z1 z2)
))

; does Simplify agree that anything satisfying P must be z1 or z2? yes!
(FORALL (y) (IMPLIES (P y)
                     (OR (EQ y z1) (EQ y z2))))

; does Simplify think that anything satisfying P must be z1? no!
(FORALL (y) (IMPLIES (P y)
                     (EQ y z1)))

; does Simplify think that there could be something besides z1 or z2
; which satisfies P? no!
(EXISTS (q) (AND (P q) (NEQ q z1) (NEQ q z2)))

(BG_POP)
(BG_POP)


; -------------- reasoning about 'next' pointers ----------
; next: Node -> Node

; theory of the next map
(BG_PUSH
  ; read the most recent update to a next map: if the last
  ; change was to say that p->next = q, then reading p->next
  ; yields q
  (FORALL (next p q)
    (EQ
      (sel (upd next p q) p)
      q
    )
  )


  ; here's an alternate version which has a flaw; when I use this one
  ; instead, Simplify agrees that the later queries aren't true, which
  ; means its properly doing case analysis (!)
;   (FORALL (next p q)
;     (IMPLIES
;       (NEQ p 3)      ; flaw: incomplete coverage of decomposition axioms
;       (EQ
;         (sel (upd next p q) p)
;         q
;       )
;     ))


  ; read past an update to a different node
  (FORALL (next p q r)
    (IMPLIES
      (NEQ p r)
      (EQ
        (sel (upd next p q) r)
        (sel next r)
      )
    ))
)

; type tags: int vs node (for now)
(BG_PUSH
  (DISTINCT IntType NodeType))

; definition of a node (in the context of some 'next' map)
(DEFPRED (isNode next n))

; cannot fold into the DEFPRED because it's recursive
; (it's not recursive anymore; but I'll keep them separate for now anyway)
(BG_PUSH
  (FORALL (next n)
    (IFF
      (isNode next n)

      (AND
        ; a node has at most one predecessor
        (FORALL (x y)
          (IMPLIES
            (AND (EQ (sel next x) n) (EQ (sel next y) n))
            (EQ x y)))
        ; if it has a successor, the successor is a node too
        (IMPLIES
          (NEQ (sel next n) null)
          (EQ (typeOf (sel next n)) NodeType))
        ; type tag is Node
        (EQ (typeOf n) NodeType)
      )
    )))

; result of allocation: a new node (named node0) is introduced;
; a is known to not be null, and no existing 'next' pointer
; (modeled by map 'next0') could point to a
(BG_PUSH
  (AND
    (NEQ a null)
    (FORALL (n)
      (NEQ (sel next0 n) a))
    (EQ (typeOf a) NodeType)
  ))

; a's next got set to null; call the resulting next map next1
(BG_PUSH
  (EQ next1
      (upd next0 a null))
)

; does Simplify agree that a->next is null? yes
(EQ (sel next1 a) null)

; allocate another node, b; it's distinct from a and null,
; and nothing in next1 can point to it
(BG_PUSH
  (AND
    (DISTINCT a b null)
    (FORALL (n)
      (NEQ (sel next0 n) b))
    (EQ (typeOf b) NodeType)
  ))

; key question: does Simplify realize that in fact nothing in next1
; points to a?  this is true because nothing in next0 points to
; a, and next1 has only been augmented with a pointer to null
(FORALL (n)
  (NEQ (sel next1 n) a))
; agrees

; same thing for b; agrees
(FORALL (n)
  (NEQ (sel next1 n) b))

; now, set b->next to a
(BG_PUSH
  (EQ next2
      (upd next1 b a)))

; still agree that nothing points to b?
(FORALL (n)
  (NEQ (sel next2 n) b))

; what about a? correctly cannot prove
(FORALL (n)
  (NEQ (sel next2 n) a))

; should also realize that if something points to a, that
; thing must be b
(FORALL (n)
  (IMPLIES
    (EQ (sel next2 n) a)
    (EQ n b)
  ))

; does Simplify think that a is a node?
(isNode next1 a)

; what about b?
(isNode next2 b)

; tricky: make a loop: a->next points to b
(BG_PUSH
  (EQ next3
      (upd next2 a b)))

(isNode next3 a)
(isNode next3 b)

; make a circle immediately
(BG_PUSH
  (EQ next1
      (upd (upd next0
        a b)          ; a->next = b
        b a)          ; b->next = a
  ))

; assume a is a node
(BG_PUSH (isNode next1 a))

; now do you believe b is a node?  yes..
(isNode next1 b)
