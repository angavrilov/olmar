; this file is a random collection of forms that I copy+paste  -*- lisp -*-
; into a Simplify session to test its behavior

; declare predicate P
(DEFPRED (P x))

; ----------------------- unique existence ------------------
; claim unique existence of an object which satisfies P
(BG_PUSH
  (EXISTS (x) (AND (P x)
                   (FORALL (y) (IMPLIES (P y) (EQ y x)))))
)

; call this object z
(BG_PUSH (P z))

; does Simplify agree that anything satisfying P must be z? yes!
(FORALL (y) (IMPLIES (P y) (EQ y z)))

; does Simplify think that anything satisfying P must be 3? no!
(FORALL (y) (IMPLIES (P y) (EQ y 3)))

; does Simplify think that there could be something besides z
; which satisfies P? no!
(EXISTS (q) (AND (P q) (NEQ q z)))

; moreover, it stops believing that anything satsifying P must
; be z once I BG_POP either of the assumptions
(BG_POP)
(BG_POP)


; -------------- existence of exactly two ------------------
; claim that exactly two things satisfy P
(BG_PUSH
  (EXISTS (x y) (AND (P x) (P y) (NEQ z y)
                     (FORALL (z) (IMPLIES (P z)
                                          (OR (EQ z x) (EQ z y))))))
)

; give names to these objects
(BG_PUSH (AND
  (P z1)
  (P z2)
  (NEQ z1 z2)
))

; does Simplify agree that anything satisfying P must be z1 or z2? yes!
(FORALL (y) (IMPLIES (P y)
                     (OR (EQ y z1) (EQ y z2))))

; does Simplify think that anything satisfying P must be z1? no!
(FORALL (y) (IMPLIES (P y)
                     (EQ y z1)))

; does Simplify think that there could be something besides z1 or z2
; which satisfies P? no!
(EXISTS (q) (AND (P q) (NEQ q z1) (NEQ q z2)))

(BG_POP)
(BG_POP)


; -------------- reasoning about 'next' pointers ----------
; next: Node -> Node

; theory of the next map
(BG_PUSH
  ; read the most recent update to a next map: if the last
  ; change was to say that p->next = q, then reading p->next
  ; yields q
  (FORALL (next p q)
    (EQ
      (sel (upd next p q) p)
      q
    )
  )


  ; here's an alternate version which has a flaw; when I use this one
  ; instead, Simplify agrees that the later queries aren't true, which
  ; means its properly doing case analysis (!)
;   (FORALL (next p q)
;     (IMPLIES
;       (NEQ p 3)      ; flaw: incomplete coverage of decomposition axioms
;       (EQ
;         (sel (upd next p q) p)
;         q
;       )
;     ))


  ; read past an update to a different node
  (FORALL (next p q r)
    (IMPLIES
      (NEQ p r)
      (EQ
        (sel (upd next p q) r)
        (sel next r)
      )
    ))
)

; type tags: int vs node (for now)
(BG_PUSH
  (DISTINCT IntType NodeType))

; definition of a node (in the context of some 'next' map)
(DEFPRED (isNode next n))

; cannot fold into the DEFPRED because it's recursive
; (it's not recursive anymore; but I'll keep them separate for now anyway)
(BG_PUSH
  (FORALL (next n)
    (IFF
      (isNode next n)

      (AND
        ; a node has at most one predecessor
        (FORALL (x y)
          (IMPLIES
            (AND (EQ (sel next x) n) (EQ (sel next y) n))
            (EQ x y)))
        ; if it has a successor, the successor is a node too
        (IMPLIES
          (NEQ (sel next n) null)
          (EQ (typeOf (sel next n)) NodeType))
        ; type tag is Node
        (EQ (typeOf n) NodeType)
      )
    )))

; result of allocation: a new node (named node0) is introduced;
; a is known to not be null, and no existing 'next' pointer
; (modeled by map 'next0') could point to a
(BG_PUSH
  (AND
    (NEQ a null)
    (FORALL (n)
      (NEQ (sel next0 n) a))
    (EQ (typeOf a) NodeType)
  ))

; a's next got set to null; call the resulting next map next1
(BG_PUSH
  (EQ next1
      (upd next0 a null))
)

; does Simplify agree that a->next is null? yes
(EQ (sel next1 a) null)

; allocate another node, b; it's distinct from a and null,
; and nothing in next1 can point to it
(BG_PUSH
  (AND
    (DISTINCT a b null)
    (FORALL (n)
      (NEQ (sel next1 n) b))
    (EQ (typeOf b) NodeType)
  ))

; key question: does Simplify realize that in fact nothing in next1
; points to a?  this is true because nothing in next0 points to
; a, and next1 has only been augmented with a pointer to null
(FORALL (n)
  (NEQ (sel next1 n) a))
; agrees

; same thing for b; agrees
(FORALL (n)
  (NEQ (sel next1 n) b))

; now, set b->next to a
(BG_PUSH
  (EQ next2
      (upd next1 b a)))

; still agree that nothing points to b?
(FORALL (n)
  (NEQ (sel next2 n) b))

; what about a? correctly cannot prove
(FORALL (n)
  (NEQ (sel next2 n) a))

; should also realize that if something points to a, that
; thing must be b
(FORALL (n)
  (IMPLIES
    (EQ (sel next2 n) a)
    (EQ n b)
  ))

; does Simplify think that a is a node?
(isNode next1 a)

; what about b?
(isNode next2 b)

; tricky: make a loop: a->next points to b
(BG_PUSH
  (EQ next3
      (upd next2 a b)))

(isNode next3 a)
(isNode next3 b)

; make a circle immediately
(BG_PUSH
  (EQ next1
      (upd (upd next0
        a b)          ; a->next = b
        b a)          ; b->next = a
  ))

; assume a is a node
(BG_PUSH (isNode next1 a))

; now do you believe b is a node?  yes..
(isNode next1 b)


; --------- same as above, but using general select/update ----------
; in particular, 'next' is simply viewed as an offset; its actual
; value isn't needed (unless pointers that wander within fields are
; allowed), only its distinctness from other potential offsets is;
; since this experiment doesn't have any other potential offsets,
; even that isn't needed

; pull in select/update theory from bgpred.sx
(BG_PUSH (AND
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; pointer disequality can be shown by showing either component
  ; is unequal
  (FORALL (obj1 obj2 ofs1 ofs2)
    (IMPLIES
      (OR
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))
))


; definition of a node (in the context of some 'mem' map)
;
; NOTE: I do not recursively apply isNode to the successor, because
; that has problems with cycles (among other things); instead I do only
; local checking here, and rely on quantification (e.g. forall) to do
; iterative reasoning when necessary
(DEFPRED (isNode mem n)
  (AND
    ; a node has at most one predecessor
    (FORALL (x y)
      (IMPLIES
        (AND
          (EQ (select mem x next) n)    ; if both x and y point to n
          (EQ (select mem y next) n))
        (EQ x y)))                      ; then they're equal
    ; if it has a successor, the successor has node type too
    (IMPLIES
      (NEQ (select mem n next) null)
      (EQ (typeOf (select mem n next)) NodeType))
    ; type tag is Node
    (EQ (typeOf n) NodeType)
  )
)


; result of allocation: a new node (named node0) is introduced;
; a is known to not be null, and no existing 'next' pointer
; (modeled by map 'mem0') could point to a
(BG_PUSH
  (AND
    (NEQ a null)
    (FORALL (n)
      (NEQ (select mem0 n next) a))
    (EQ (typeOf a) NodeType)
  ))


; a's next got set to null; call the resulting next map mem1
(BG_PUSH
  (EQ mem1
      (update mem0 a next null))
)

; does Simplify agree that a->next is null?  yes
(EQ (select mem1 a next) null)

; allocate another node, b; it's distinct from a and null,
; and nothing in mem1 can point to it
(BG_PUSH
  (AND
    (DISTINCT a b null)
    (FORALL (n)
      (NEQ (select mem1 n next) b))
    (EQ (typeOf b) NodeType)
  ))

; key question: does Simplify realize that in fact nothing in mem1
; points to a?  this is true because nothing in mem0 points to
; a, and mem1 has only been augmented with a pointer to null
(FORALL (n)
  (NEQ (select mem1 n next) a))
; agrees

; same thing for b; agrees
(FORALL (n)
  (NEQ (select mem1 n next) b))

; now, set b->next to a
(BG_PUSH
  (EQ mem2
      (update mem1 b next a)))

; still agree that nothing points to b?
(FORALL (n)
  (NEQ (select mem2 n next) b))

; what about a? correctly cannot prove
(FORALL (n)
  (NEQ (select mem2 n next) a))

; should also realize that if something points to a, that
; thing must be b
(FORALL (n)
  (IMPLIES
    (EQ (select mem2 n next) a)
    (EQ n b)
  ))

; does Simplify think that a is a node?  yes
(isNode mem2 a)

; what about b?  yes
(isNode mem2 b)

; tricky: make a loop: a->next points to b
(BG_PUSH
  (EQ mem3
      (update mem2 a next b)))

(isNode mem3 a)
(isNode mem3 b)


; simplify unsound?  yes! .. :(
(IMPLIES
  (EQ x 3)
  (FORALL (x) (EQ x 3))
)


; ------------------- inDegree stuff -----------------------
