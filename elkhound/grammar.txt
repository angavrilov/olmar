
10/13/00
Grammar file format description
-------------------------------

This file describes the input format for grammars for the parser
generator.  If you'd like to look at a simple grammar while reading
this description, see 'cexp2.gr'.  It's a grammar for C expressions
with a list of variable bindings.


Lexical structure
-----------------

The grammar file format is free-form, meaning that all whitespace is
considered equivalent.  In the C tradition, grouping is generally
denoted by enclosing things in braces ("{" and "}").  Strings are
enclosed in double-quotes (").

Grammar files may include other grammar files, by writing
include("other_file_name").

Comments can use the C++ "//" syntax or the C "/**/" syntax.


Terminals
---------

The first thing in a grammar file is a declaration of all the tokens,
also called terminals.  This looks like:

  terminals {
    0 : L2_EOF               ;
    1 : L2_NAME              ;
    2 : L2_INT_LITERAL       ;
    3 : L2_FLOAT_LITERAL     ;
    4 : L2_STRING_LITERAL    ;
    5 : L2_CHAR_LITERAL      ;
    6 : L2_ASM               "asm" ;
    7 : L2_AUTO              "auto" ;
    /*...*/
    111 : L2_SEMICOLON         ";" ;
    112 : L2_LBRACE            "{" ;
    113 : L2_RBRACE            "}" ;
  }

Each statement gives a unique numeric code (e.g. 113), a canonical
name (e.g. L2_RBRACE), and an optional alias (e.g. "}").  Either the
name or the alias may appear in the grammar productions, though the
usual style is to use aliases for tokens that always have the same
spelling (like "}"), and the name for others (like L2_INT_LITERAL).


Nonterminals
------------

Following the terminals, the bulk of the grammar is one or more
nonterminals.  Each nonterminal declaration specifies all of the
productions for which it is the left-hand-side, all attributes and
conditions, and semantic functions.

A simple nonterminal might be:

  nonterm Expr {
    -> Expr "+" Expr ;
    -> L2_NAME ;
  }
  
This has two productions, `Expr -> Expr "+" Expr' and 
`Expr -> L2_NAME'.  The "->" operator introduces a production.

Very simple nonterminals can omit the braces:

  nonterm StartSymbol -> TranslationUnit L2_EOF ;
  nonterm SomeSeq -> empty | Some SomeSeq ;

Note that "empty" is a special nonterminal that means the empty
string.

"|" can be used to denote alternatives, but at the top level of a
production only -- you can't write, say, `A -> B ( C | D )'.  In
fact, parentheses in productions don't work at all.

Right-hand-side symbols can be given names, by putting the name
before a colon (":") and the symbol.  E.g.

  Expr -> e1:Expr op:Binop e2:Expr
  
gives the three RHS symbols the names "e1", "op", and "e2",
respectively.  These names can later be used to refer to attributes of
the symbols, and to call semantic functions defined on the symbols.


Attributes
----------

The 'cexp2.gr' uses attributes to implement precedence and
associativity, which are disambiguation policies.  First,
Expr and Binop declare the "prec" attribute:

  attr prec;

This means that all of the productions in either nonterminal
are required to give this attribute a value.  Since Expr wants
to assign precedence 100 to both L2_NAME and L2_INT_LITERAL
productions, it defines a default value:

  action prec := 100;

outside any production.

Then, inside the `Expr Binop Expr' production, it gives the
attribute a specific value:

  action prec := op.prec;

In this case, the precedence of an expression comes from the
value of the attribute in a child nonterminal, namely 'op'.

The expression after ":=" is a side-effect-free expression written
using C's syntax for such expressions.  The ground symbols can
be integer literals or attributes of child symbols.


Conditions
----------

The GLR parser works by building a subtree for every possible
parse.  In the expression grammar 'cexp2.gr', an expression like
"a+b*c" has two possible parses:

          *                  +
         / \                / \
        /   \              /   \
       +     \            /     *
      / \     \          /     / \
     /   \     \        /     /   \
    a  +  b  *  c      a  +  b  *  c

The interpretation we want is the second one, corresponding to the
traditional precedence of multiplcation over addition in mathematical
notation.  But how are we to select this?

(Note:  Bison (an LALR(1) parser generator) has a related notion.
However, Bison implements it by modifying the parse tables.  While
this is faster, it is somewhat more limited.  The mechanism described
here is more general.)

The answer is to use conditions on the attributes synthesized from
the precedences of the symbols.  cexp2.gr does it this way:

  condition  this.prec <= left.prec;             // precedence
  condition  this.prec <= right.prec;            // more precedence

(In the conditions, "this" refers to the nonterminal in whose context
the condition appears.  It is optional.)

Taken together (they could have been written as a single condition
with "&&", but I chose this way), they say that the precedence of
an operator on top must never be greater than the precedence of an
operator below it.  

Since "*" has higher precedence, the tree with "*" on top (the left
of the two alternatives above) has a false condition, and is hence
removed from the tree.

I leave it as an exercise to see how associativity works in this
grammar.


Semantic functions
------------------

After the tree is built, it is typical to perform various kinds of
tree analyses.  This can be written as functions defined within the
nonterminals.

The design paradigm used here is: "nonterminal = class".  I.e., each
nonterminal defines some set of semantic functions, and parent
nonterminals can call the functions defined for any of its children.

Semantic functions must be declared.  The declarations start with
"fundecl", and are then declarations of C++ member functions,
terminated by a semicolon (";").  For example:

  fundecl int eval(Bindings const &bindings) const;

Note the "const" at the end.  This is currently necessary, though
it is wrong (semantic functions should be allowed to modify the
tree) and will be removed at some point (soon).

The semantic functions are then defined with the "fun" keyword,
followed by the name (e.g. eval), an open-brace ("{") the code,
and terminated by a close-brace ("}").  For example:

  fun eval {
    int L = left.eval(bindings);
    int R = right.eval(bindings);
    int ret = op.eval(L, R);
    cout << L << " " << op.opSpelling() << " " << R
         << " = " << ret << endl;
    return ret;
  }

Several things are noteworthy:
  - The name "bindings" is available.  This is because it is the
    name used in the 'fundecl' declaration.
  - When childrens' functions are called (e.g. "left.eval(bindings)"),
    the arguments must be passed explicitly.  There is no way to say,
    "call my children with the same arguments you gave me".  (This is
    the subject of a future feature, perhaps.)
  - You can call childrens' functions more than once.  Above, 'op' has
    its 'eval' and 'opSpelling' functions called.
  - The code is full C++ code, entirely *unmolested* by the parser
    generator.  No substitutions are performed.
  - The parser generator recognizes nested pairs of braces in the code,
    so it is ok to use compound statements, loops, etc.  But don't hide
    such syntax in macro expansions -- the parser generator doesn't
    know about the preprocessor.
    
There is an additional "short form" syntax for semantic functions.
The following:

  fun eval = left + right;
  
is exactly equivalent to

  fun eval { return left + right; }

The short form just saves having to type "return", essentially.


Prologue and Epilogue
--------------------- 

It's often nececessary to be able to put some C++ code at the
beginning of the file has the emitted C++ code, to put declarations
of things used in the semantic functions.  Put is extra code into
a prologue block:

  prologue {
    #include "my-stuff.h"
  }

It's often convenient to have some C++ code at the end of the
emitted code.  Put this into an epilogue:

  epilogue {
    int main()
    {
      /*...*/
    }
  }
  

Miscellaneous
-------------

By default, all tree node classes will derive from NonterminalNode,
declared in glrtree.h.  If you want your own class, which must itself
(either directly or indirectly) derive from NonterminalNode, to be
the direct base class, specify it in a 'treeNodeBase' declaration:

  treeNodeBase "CCTreeNode";

The base class name goes in quotes.

An artifact of the way I finish GLR parsing is that the grammar's
true start symbol doesn't appear in the tree.  Thus, the top of
the tree yielded by ParseTree::getTop will have the type of the
first RHS element of the true start symbol.  That's why cc.gr has

  // dummy first rule
  nonterm StartSymbol -> TranslationUnit L2_EOF;

but then has

  xassert(tree->getTop()->getSymbolC()->
          name.equals("TranslationUnit"));

in its main function.
