# Makefile.in for elkhound
# see license.txt for copyright and terms of use

# I uncomment this temporarily to just build certain modules
#tmp: cc/cc_type.o cc/cc_env.o cc/cc_tcheck.o

# main targets: two C++ parsers and two C parsers
all: cc/ccparse cc2/cc2.exe cc/cparse cc/bccgr
	@echo BUILD FINISHED

# TODO: put these back, ideally in the same executable as the non-t versions
# cc2/cc2t.exe cc/ccparset


# directories of other software
SMBASE    := @SMBASE@
AST       := @AST@

# stuff inside those other directories
LIBSMBASE := $(SMBASE)/libsmbase.a
LIBAST    := $(AST)/libast.a
ASTGEN    := $(AST)/astgen


# remake the generated Makefile if its inputs have changed
Makefile: Makefile.in
	./config.status


# This variable is a parameter that can be passed on the 'make' command
# line.  It becomes part of the -tr argument to 'elkhound'.  By default,
# it's set to the flag to generate a debug dump of the LR parse tables.
TRGRAMANL := ,lrtable


# -------------------- compiler configuration -------------------
# C++ compiler, etc.
CXX := g++

# flags for the C and C++ compilers (and preprocessor)
# TODO: remove -Icc once Elsa is split out
# "-I." is needed for gcc-2 when compiling things in cc2/
CCFLAGS := @CCFLAGS@ -I$(SMBASE) -I$(AST) -Icc -I.

# flags for the linker
libraries := $(LIBAST) $(LIBSMBASE)
LDFLAGS := -g -Wall $(libraries)


# some other tools
AR     := ar
RANLIB := ranlib


# compile .cc to .o
%.o: %.cc
	$(CXX) -c -o $@ $< $(CCFLAGS)
	@$(SMBASE)/depend.pl -o $@ $< $(CCFLAGS) > $*.d


# ----------------- sets of related object files ---------------------
# files needed to represent a grammar in memory
grammar-set := \
  asockind.o \
  grammar.o
-include $(grammar-set:.o=.d)

# in addition to grammar-set, files needed to parse a grammar description
grampar-set := \
  emitcode.o \
  emittables.o \
  gramast.ast.gen.o \
  gramlex.yy.o \
  grampar.o \
  grampar.tab.o
-include $(grampar-set:.o=.d)

# minimal runtime files needed to do GLR parsing; these get
# combined to form libelkhound.a, the Elkhound runtime library
glr-set := \
  cyctimer.o \
  glr.o \
  parsetables.o \
  useract.o
-include $(glr-set:.o=.d)

# some (mostly) language-independent parsing support files which
# are shared by several of the test parsers (e.g. cexp3)
support-set := \
  cc/cc_lang.o \
  cc/lexer1.o \
  cc/lexer1yy.o \
  cc/lexer2.o \
  cc/parssppt.o
-include $(support-set:.o=.d)

# files for parsing C code with the c.gr or cc2.gr grammars;
# since this set is used with both grammars, I don't include either
# grammar in the set itself
c-set := \
  $(support-set) \
  cc/c.ast.gen.o \
  cc/c_env.o \
  cc/cc_flags.o \
  cc/c_type.o \
  cc/cparse.o \
  cc/exprequal.o \
  cc/exprvisit.o \
  cc/paths.o \
  cc/postorder.o \
  cc/stubs.o \
  cc/tcheck.o \
  cc/treeout.o \
  cc/c_variable.o
-include $(c-set:.o=.d)

# files for parsing C++ code with the cc.gr or cc2.gr grammars
cc-set := \
  $(support-set) \
  cc/cc.ast.gen.o \
  cc/cc_env.o \
  cc/cc_scope.o \
  cc/cc_flags.o \
  cc/cc_type.o \
  cc/cc_tcheck.o \
  cc/cc_print.o \
  cc/cc_ast_aux.o \
  cc/treeout.o \
  cc/variable.o \
  cc/ccparse.o
-include $(cc-set:.o=.d)

# a few random .o files which don't appear anyplace above, but I need
# to make sure their dependency info (if it exists) gets included
random-obj := \
  parsstub.o \
  glrmain.o \
  cc/ccgrmain.o \
  cc/c.gr.gen.o \
  cc/cc.gr.gen.o \
  cc/ccparset.o \
  cc/main.o
-include $(random-obj:.o=.d)


# ---------------------- generic rules ----------------------
# intermediate files for an ast spec
.PRECIOUS: %.ast.gen.cc %.ast.gen.h
%.ast.gen.cc %.ast.gen.h: %.ast $(AST)/astgen
	rm -f $*.ast.gen.*
	$(AST)/astgen -o$*.ast.gen $*.ast
	chmod a-w $*.ast.gen.h $*.ast.gen.cc

# intermediate files for a grammar
# TRGRAMANL: extra trace flags specified by user; starts with "," if defined
# ('chmod a-w' is so I don't accidentally edit it)
.PRECIOUS: %.gr.gen.cc %.gr.gen.h
%.gr.gen.cc %.gr.gen.h %.gr.gen.y: %.gr cc.tok elkhound
	rm -f $*.gr.gen.*
	./elkhound -v -tr bison,NOconflict$(TRGRAMANL) -o $*.gr.gen $*.gr
	chmod a-w $*.gr.gen.h $*.gr.gen.cc

# bison parser from the a given grammar; the 'sed' is because Bison
# already interpretes 0 as EOF, and if my rule names it explicitly
# then it gets mad
%.y: %.gr.gen.y
	echo '%{' >$@
	echo '#include "trivbison.h"' >>$@
	echo '%}' >>$@
	sed 's/"EOF" {/{/' <$*.gr.gen.y >>$@

# run Bison; the 'sed' command is to silence a spurious warning about
# 'yyval' being used uninitialized; I also compile here (instead of
# relying on another pattern rule) because I want to control exactly
# how the compilation happens (to ensure the Bison-parser is compiled
# with flags to make it a fair performance test with my own stuff)
#
# TODO: apparently bison-1.75 chooses its output files differently
# than prior versions.. may have to detect that with ./configure
%.tab.c %.tab.o %.tab.h: %.y
	bison -d -v $*.y
	mv $*.tab.c $*.tab.c.orig
	sed 's/YYSTYPE yyval;/YYSTYPE yyval = 0;/' <$*.tab.c.orig >$*.tab.c
	rm $*.tab.c.orig
	g++ -c -g -o $*.tab.o -O2 -DNDEBUG -Wall $(YYDEBUG) $*.tab.c

# run the trivial-grammar helper
.PRECIOUS: %.gr %.tree.gr
%.gr: %.gr.in make-trivparser.pl
	rm -f $@
	./make-trivparser.pl $(notdir $*) <$*.gr.in >$@
	chmod a-w $@

%.tree.gr: %.gr.in make-trivparser.pl
	rm -f $@
	./make-trivparser.pl -ptree $(notdir $*) <$*.gr.in >$@
	chmod a-w $@

# make a parser for testing some grammar, using trivial lexer
trivparse-deps := trivmain.cc ptreenode.o trivlex.o $(support-set) \
                  libelkhound.a
%.gr.exe: %.gr.gen.o $(trivparse-deps) $(libraries)
	$(CXX) -o $@ -DGRAMMAR_NAME=\"$*.bin\" $(CCFLAGS) $*.gr.gen.o $(trivparse-deps) $(LDFLAGS)

# similar, for Bison as the parser-generator
trivbison-deps := trivbison.o trivlex.o lexer2.o ptreenode.o libelkhound.a
%.bison.exe: %.tab.o $(trivbison-deps)
	$(CXX) -o $@ $*.tab.o $(trivbison-deps) $(LDFLAGS)


# ------------------- intermediate files --------------------
# grammar lexer
# like in ast/, need to replace forward decl with proper #include
gramlex.yy.cc: gramlex.lex
	flex -o$@ gramlex.lex
	mv $@ gramlex.tmp
	sed 's/class istream;/#include <iostream.h>/' <gramlex.tmp >$@
	rm gramlex.tmp

# bison implementation of grammar parser.
# I have to make some changes to the generated output so it will compile
# with a C++ compiler, and want to extract the codes so they're available
# separately without having to know about all of the types in YYSTYPE.
grampar.tab.cc grampar.tab.h grampar.codes.h: grampar.y gramast.ast.gen.h
	bison -d -v grampar.y
	mv -f grampar.tab.c tmp
	sed 's/typedef union {/typedef union YYSTYPE {/' <tmp >grampar.tab.cc
	mv -f grampar.tab.h tmp
	sed 's/typedef union {/typedef union YYSTYPE {/' <tmp >grampar.tab.h
	rm tmp
	grep '# *define' grampar.tab.h >grampar.codes.h


# ----------------- intermediate files for Elsa ---------------------
# flex implementation of lexer stage 1
cc/lexer1yy.cc: cc/lexer1.lex cc/lexer1.h
	cd cc; flex lexer1.lex

# token list for my grammar
cc/cc.tok: cc/lexer2
	cc/lexer2 -myparser >$@

# copy it to the parsgen/ directory for now so I can change
# the "include" line in cc.gr to not say "cc/"
cc.tok: cc/cc.tok
	cp -f $^ $@
	chmod a-w $@

# specific instructions for cc.ast, so I can add extension modules
CC_AST_MODS := cc/cc_tcheck.ast cc/cc_print.ast
cc/cc.ast.gen.cc cc/cc.ast.gen.h: cc/cc.ast $(CC_AST_MODS) $(AST)/astgen
	rm -f cc/cc.ast.gen.cc cc/cc.ast.gen.h
	$(AST)/astgen -occ/cc.ast.gen cc/cc.ast $(CC_AST_MODS)
	chmod a-w cc/cc.ast.gen.cc cc/cc.ast.gen.h

# don't delete these because error messages often point into them
.PRECIOUS: cc.gr.gen.h cc.gr.gen.cc

# C++ grammar, but building entire parse tree instead
# TODO: this won't work because I moved the #inclusion of cc.gr.gen.h
cc/cct.gr.gen.cc cc/cct.gr.gen.h cc/cct.gr.gen.y: cc/cc.gr cc.tok elkhound
	rm -f cc/cct.gr*
	sed 's/cc\.gr\.gen\.h/cct.gr.gen.h/' <cc/cc.gr >cc/cct.gr
	./elkhound -v -tr treebuild$(TRGRAMANL) -o cc/cct.gr.gen cc/cct.gr
	chmod a-w cc/cct.gr*

# bison parser from the same grammar; the 'sed' is because Bison
# already interpretes 0 as EOF, and if my rule names it explicitly
# then it gets mad
cc/bccgr.y: cc/c.gr.gen.y
	echo '%{' >$@
	echo '#include "bccgr.h"' >>$@
	echo '%}' >>$@
	sed 's/File L2_EOF/File/' <cc/c.gr.gen.y >>$@

# new C++ grammar with treebuilding actions
cc2/cc2t.gr.gen.cc cc2/cc2t.gr.gen.h cc2/cc2t.gr.gen.y: cc2/cc2.gr cc.tok elkhound
	rm -f cc2/cc2t*
	sed 's/cc2\.gr\.gen\.h/cc2t.gr.gen.h/' <cc2/cc2.gr >cc2/cc2t.gr
	./elkhound -v -tr treebuild$(TRGRAMANL) -o cc2/cc2t.gr.gen cc2/cc2t.gr
	chmod a-w cc2/cc2t.gr*


# ----------------- extra dependencies -----------------
# These dependencies ensure that automatically-generated code is
# created in time to be used by other build processes which need it.
# I had been maintaining the list by hand, but now I've got a script
# to build it.  The list may need to be rebuilt from time to time; if
# you get compile errors after 'make clean' because of missing files
# that are automatically generated, rebuild extradep.mk after a full
# compilation succeeds.

extradep.mk:
	./find-extra-deps *.d cc/*.d cc2/*.d >$@

include extradep.mk


# --------------------- test programs ----------------------
# first pass lexer
lexer1-dep := cc/lexer1.cc cc/lexer1yy.o
cc/lexer1: $(lexer1-dep) $(libraries)
	$(CXX) -o $@ -DTEST_LEXER1 $(CCFLAGS) $(lexer1-dep) $(LDFLAGS)

# grammar lexer test program
gramlex-dep := gramlex.yy.cc $(AST)/gramlex.cc
gramlex: ../ast/gramlex.h $(gramlex-dep) $(libraries)
	$(CXX) -o $@ -DTEST_GRAMLEX $(CCFLAGS) $(gramlex-dep) $(LDFLAGS)

# cycle timer test
cyctimer: cyctimer.cc cyctimer.h
	$(CXX) -o $@ -DTEST_CYCTIMER $(CCFLAGS) cyctimer.cc $(LDFLAGS)


# -------------------- exported library ----------------
# glr parsing engine
libelkhound.a: $(glr-set)
	rm -f $@
	ar -r $@ $(glr-set)
	ranlib $@


# --------------------- executables ---------------------
# second pass lexer; not considered a test program because this
# is what generates cc.tok
lexer2-dep := cc/lexer2.cc cc/lexer1.o cc/lexer1yy.o cc/cc_lang.o
cc/lexer2: $(lexer2-dep) cc/lexer2.h $(libraries)
	$(CXX) -o $@ -DTEST_LEXER2 $(CCFLAGS) $(lexer2-dep) $(LDFLAGS)

# reads the grammar and emits C++ code for semantic functions;
# this is the main parser generator binary
elkhound-dep := gramanl.cc gramexpl.o $(grammar-set) $(grampar-set) parsetables.o
elkhound: $(elkhound-dep) grammar.h gramanl.h $(libraries)
	$(CXX) -o $@ -DGRAMANL_MAIN $(CCFLAGS) $(elkhound-dep) $(LDFLAGS)

# stand-alone executable for parsing C
cparse-dep := cc/ccgrmain.o cc/c.gr.gen.o $(c-set) libelkhound.a
cc/cparse: $(cparse-dep) $(libraries)
	$(CXX) -o $@ $(cparse-dep) $(LDFLAGS)
	./$@ -tr yieldVariableName c.in/c.in1

# stand-alone executable for parsing C++
ccparse-dep := cc/main.o cc/cc.gr.gen.o $(cc-set) libelkhound.a
cc/ccparse: $(ccparse-dep) $(libraries)
	$(CXX) -o $@ $(ccparse-dep) $(LDFLAGS)
	./$@ c.in/c.in1

# treebuilding C++ parser
ccparset-dep := cc/ccparset.o cc/cct.gr.gen.o $(cc-set) ptreenode.o libelkhound.a 
cc/ccparset: $(ccparset-dep) $(SMBASE)/libsmbase.a
	$(CXX) -o $@ $(ccparset-dep) $(LDFLAGS)

# C-without-typedefs parser, using Bison
bccgr-deps := cc/bccgr.cc cc/bccgr.tab.o cc/lexer1.o cc/lexer1yy.o cc/lexer2.o \
              cc/cc_lang.o cyctimer.o
cc/bccgr: $(bccgr-deps) $(libraries)
	$(CXX) -o $@ $(CCFLAGS) $(bccgr-deps) $(LDFLAGS)
	cc/bccgr c.in/c.in1

# new C++ parser
cc2-deps := cc2/cc2main.o $(cc-set) cc2/cc2.gr.gen.o ptreenode.o libelkhound.a
cc2/cc2.exe: $(cc2-deps) $(libraries)
	$(CXX) -o $@ $(cc2-deps) $(LDFLAGS)

# new C++ parser with treebuilding
cc2t-deps := cc2/cc2main.o $(cc-set) cc2/cc2t.gr.gen.o ptreenode.o libelkhound.a
cc2/cc2t.exe: $(cc2t-deps) $(libraries)
	$(CXX) -o $@ $(cc2t-deps) $(LDFLAGS)


# ---------------------- Elkhound examples ------------------
# stuff in examples directory
.PHONY: examples
examples: all
	cd examples/arith; make
	cd examples/cexp; make
	cd examples/cdecl; make

# rule to decompress one of the big examples
cc.in/big/%.i: cc.in/big/gz/%.i.gz
	gunzip -c <$^ >$@

# decompress all of them which haven't already been decompressed
.PHONY: cc.in/big
cc.in/big: $(patsubst cc.in/big/gz/%.i.gz,cc.in/big/%.i,$(wildcard cc.in/big/gz/*.gz))
	@echo made cc.in/big


# ----------------------------- EFa -----------------------
# input for EFa
triv/efa.in:
	mkdir $@
	perl -e 'foreach $$n (500, 1000, 1500, 2000, 2500, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000) {  \
	           $$name = sprintf("%07d", $$n);            \
	           open(OUT, ">$@/$$name.in") or die $!; \
	           print OUT "A";                            \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("PA");                       \
	           }                                         \
	           close(OUT);                               \
	         }'

EFA_TESTS := triv/efa.perf.txt triv/efa.notree.perf.txt triv/efa.bison.tree.perf.txt triv/efa.bison.notree.perf.txt

#.PHONY: $(EFA_TESTS) all-efa

# run all the EFa tests; the whole batch runs in less than a minute
# (well, they did before I put in the loop from 1 to 5 ...)
all-efa: $(EFA_TESTS)

# performance test for EFa
triv/efa.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.gr.exe -tr progress -count $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.notree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.gr.exe -tr progress,trivialActions $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.bison.tree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.bison.exe $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.bison.notree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.bison.exe $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

%.csv: %.txt
	cat $^ | grep cycles | \
	  perl -p -e 's/^[^:]*\D(\d+)\D.*:.*\D(\d+)_(\d+) cycles.*$$/$$1, $$2$$3/' >$@

all-efa-csv: $(EFA_TESTS:.txt=.csv)


# --------------------------- EEb -----------------------
# input for EEb
triv/eeb.in:
	mkdir $@
	perl -e 'foreach $$n (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 20, 50, 100, 200, 300, 400, 500) {  \
	           open(OUT, ">$@/$$n.in") or die $!;    \
	           print OUT "B";                            \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("PB");                       \
	           }                                         \
	           close(OUT);                               \
	         }'

# performance test for EEb
triv/eeb.perf.txt:
	rm -f $@
	for n in 10 20 50 100 200 300 400 500; do \
	  triv/EEb.tree.gr.exe -tr progress -count triv/eeb.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/eeb.notree.perf.txt:
	rm -f $@
	for n in 10 20 50 100 200 300 400 500; do \
	  triv/EEb.tree.gr.exe -tr progress,trivialActions triv/eeb.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done


# --------------------------- SSx ----------------------
# input for SSx
triv/ssx.in:
	mkdir $@
	perl -e 'for($$n=1; $$n <= 99; $$n += 2) {           \
	           open(OUT, ">$@/$$n.in") or die $!;        \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("X");                        \
	           }                                         \
	           close(OUT);                               \
	         }'

# performance test for SSx
triv/ssx.perf.txt:
	rm -f $@
	for n in 15 25 35 45 55 65 75 85 99; do \
	  triv/SSx.tree.gr.exe -tr progress -count triv/ssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/ssx.notree.perf.txt:
	rm -f $@
	for n in 15 25 35 45 55 65 75 85 99; do \
	  triv/SSx.tree.gr.exe -tr progress,trivialActions triv/ssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done



# --------------------------- SSSx ----------------------
# input for SSSx
triv/sssx.in:
	mkdir $@
	perl -e 'for($$n=1; $$n <= 99; $$n += 1) {           \
	           open(OUT, ">$@/$$n.in") or die $!;        \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("X");                        \
	           }                                         \
	           close(OUT);                               \
	         }'

triv/sssx.perf.txt:
	rm -f $@
	for n in 5 10 15 20 25 30 35 40 45 50; do \
	  triv/SSSx.tree.gr.exe -tr progress -count triv/sssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/sssx.notree.perf.txt:
	rm -f $@
	for n in 5 10 15 20 25 30 35 40 45 50; do \
	  triv/SSSx.tree.gr.exe -tr progress,trivialActions triv/sssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done


# ------------------------ DeclExpr ----------------------
triv/DeclExpr.perf.txt:
	rm -f $@
	for n in 1 10 100 1000 10000; do \
	  triv/DeclExpr.gr.exe -tr progress,trivialActions triv/DeclExpr.in$$n 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done


# ------------------------ documentation -----------------------
# dependencies for 'elkhound', the parser generator executable
doc/elkhound.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) gramanl.cc >$@

# dependencies for 'glr.h', the entry point to the runtime library
doc/glr.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) glr.h >$@

# dependencies for 'ccgr', the prototype C parser and typechecker
doc/cc.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) -Icc -Sglr.h -Xsrcloc.h ccgrmain.h >$@

# dependencies for 'trivmain.cc', the trivial grammar driver
doc/triv.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) -Sglr.h trivmain.cc >$@

# use 'dot' to lay out the graph
# http://www.research.att.com/sw/tools/graphviz/
doc/%.ps: doc/%.dot
	dot -Tps <$^ >$@

# use 'convert' to make a PNG image with resolution not to exceed
# 1000 in X or 700 in Y ('convert' will preserve aspect ratio); this
# also antialiases, so it looks very nice (it's hard to reproduce
# this using 'gs' alone)
doc/%.png: doc/%.ps
	convert -geometry 1000x700 $^ $@

# "make doc" should build whatever we have that needs building
.PHONY: doc
doc: doc/elkhound.png doc/glr.png doc/cc.png doc/triv.png

doc-clean:
	cd doc; rm -f {elkhound,glr}.{ps,dot,png}

# some other random phony targets (I hate this clutter..)
.PHONY: doc-clean clean distclean check


# -------------------- clean, check, etc. ------------------
# things to remove from all directories
CLEAN_PATTERNS := \
  *.o  \
  *~ \
  *.d \
  *.exe \
  *.gen.* \
  *.bin \
  *.tab.* \
  *.output \
  a.out \
  core

clean:
	rm -f $(CLEAN_PATTERNS)
	rm -f elkhound glr cc/lexer1 cc/lexer1yy.cc gramlex.yy.cc gramlex cyctimer
	rm -f cc/lexer2 grampar.tab.* grampar
	rm -f cc/cc.bin cc/ccgr cc/cparse cc/ccparse cc/ccparset
	rm -f cc/libccgr.a libelkhound.a
	rm -f cc/bccgr
	rm -f cc/bccgr.y cc/cc.tok cc.tok grampar.codes.h
	rm -f gdb.log gprof.out gmon.out test-bad-tmp.c
	cd cc; rm -f $(CLEAN_PATTERNS)
	cd cc2; rm -f $(CLEAN_PATTERNS)
	cd triv; rm -f $(CLEAN_PATTERNS) *.y *.gr
	for dir in arith cdecl cexp; do \
	  (cd examples/$$dir; make clean); \
	done

distclean: clean
	rm -f Makefile config.status config.summary glrconfig.h
	cd triv; rm -rf sssx.in ssx.in eeb.in

check: all
	./regrtest
	@echo ""
	@echo "Regression tests passed."


# --------------- random other stuff --------------------
# test for rcptr
trcptr: rcptr.h trcptr.cc
	$(CXX) -o $@ trcptr.cc
