# Makefile.in
# source for Makefile for parser generator project

all: c.ast.gen.h glr.o ccgr cc2.exe cc2t.exe bccgr cexp3

temporary: ccgr bccgr triv/aSEb.gr.exe triv/SSx.tree.gr.exe triv/ssx.in \
           triv/EEb.tree.gr.exe triv/eeb.in triv/SSSx.tree.gr.exe triv/sssx.in \
           triv/EFa.tree.gr.exe triv/efa.in \
	   triv/EFa.bison.exe triv/EFa.tree.bison.exe

# main targets

ifeq ($(ocaml), yes)
  # old, obsolete
  mode := --ocaml
else
  mode := --nocaml
endif

# this target ensures the Makefile is in synch with Makefile.in
Makefile: Makefile.in
	./configure $(mode)

everything: gramanl glr lexer1 lexer2 grampar cexp2 ccgr

# directories
SMBASE := ../smbase
AST    := ../ast

# turn off implicit rules
.SUFFIXES:

# translation process variables
libraries   := $(SMBASE)/libsmbase.a
includes    := -I$(SMBASE) -I$(AST)

# needed for gcc-2 when compiling things in cc2/
includes    += -I.

ccflags     := -g -Wall @CCFLAGS@
no-warnings := -w
makelib     := ar -r
ranlib      := ranlib

ifeq ($(ocaml), yes)
  libraries += /usr/lib/ocaml/libunix.a /usr/lib/ocaml/libcamlrun.a
  includes  += -I/usr/lib/ocaml
  ccflags   += -DWES_OCAML_LINKAGE
endif

# make warnings into errors so I always get a chance to fix them
# (otherwise they scroll by and I might miss them)
#ccflags += -Werror

# when uncommented, we get profiling info
#ccflags += -pg

# optimizer...
#ccflags += -O2 -DNDEBUG

# uncomment to turn off source location info
#ccflags += -DNO_GLR_SOURCELOC

# even fewer debugging checks
#ccflags += -DNDEBUG_NO_ASSERTIONS

# for gcc-3
ccflags += -Wno-deprecated

# turn on to enable bison's debugging features
#YYDEBUG := -DYYDEBUG=1
#ccflags += $(YYDEBUG)

# generate debug table every time
#TRGRAMANL := foo,lrtable


# flags on command line
ccflags += $(EXTRA)

compile := g++ -c $(ccflags) $(includes)
depend  := g++ -MM $(ccflags) $(includes)
link    := g++ $(ccflags) $(includes)
linkend := $(libraries)

# compile .cc to .o; dependency manipulation involves:
#   sed:    strip the target (everything before colon)
#   sed:    remove any continuation backslashes
#   fmt -1: list words one per line
#   sed:    strip leading spaces
#   sed:    add trailing colons
# see http://www.cs.berkeley.edu/~smcpeak/autodepend/autodepend.html
.PRECIOUS: %.o
%.o: %.cc
	$(compile) $< -o $@
	@echo "dependencies for $< > $*.d"
	@$(depend) $< > $*.d
	@cp -f $*.d $*.d.tmp
	@sed -e 's/.*://' -e 's/\\$$//' < $*.d.tmp | fmt -1 | \
          sed -e 's/^ *//' -e 's/$$/:/' >> $*.d
	@rm -f $*.d.tmp

# sets of related object files
# files needed to represent a grammar in memory
grammar-set := \
  $(AST)/locstr.o \
  asockind.o \
  grammar.o
-include $(filter-out $(AST)/%, $(grammar-set:.o=.d))

# in addition to grammar-set, files needed to parse a grammar description
grampar-set := \
  $(AST)/asthelp.o \
  $(AST)/ccsstr.o \
  $(AST)/embedded.o \
  $(AST)/fileloc.o \
  $(AST)/gramlex.o \
  $(AST)/strtable.o \
  emitcode.o \
  emittables.o \
  gramast.ast.gen.o \
  gramlex.yy.o \
  grampar.o \
  grampar.tab.o
-include $(filter-out $(AST)/%, $(grampar-set:.o=.d))

# minimal runtime files needed to do GLR parsing; these get
# combined to form libglr.a, the Elkhound runtime library
glr-set := \
  $(AST)/fileloc.o \
  cyctimer.o \
  glr.o \
  parsetables.o \
  useract.o
-include $(filter-out $(AST)/%, $(glr-set:.o=.d))

# some (mostly) language-independent parsing support files which
# are shared by several of the test parsers (e.g. cexp3)
support-set := \
  $(AST)/asthelp.o \
  $(AST)/strtable.o \
  cc_lang.o \
  lexer1.o \
  lexer1yy.o \
  lexer2.o \
  parssppt.o
-include $(filter-out $(AST)/%, $(support-set:.o=.d))

# files for parsing C/C++ code with the cc.gr or cc2.gr grammars;
# since this set is used with both grammars, I don't include either
# grammar in the set itself
cc-set := \
  $(support-set) \
  c.ast.gen.o \
  cc_env.o \
  cc_flags.o \
  cc_type.o \
  cparse.o \
  exprequal.o \
  exprvisit.o \
  paths.o \
  postorder.o \
  stubs.o \
  tcheck.o \
  treeout.o \
  variable.o
-include $(filter-out $(AST)/%, $(cc-set:.o=.d))

# how to compile a .o in an adjacent directory (looser dependency
# tracking across directories...)
.PRECIOUS: $(AST)/%.o
$(AST)/%.o: $(AST)/%.cc
	make -C $(AST) $*.o

# a few random .o files which don't appear anyplace above, but I need
# to make sure their dependency info (if it exists) gets included
random-obj := parsstub.o cexp2.o cexp3.gen.o \
              glrmain.o cexp3mrg.o cexp3ast.gen.o cdecl.gen.o \
              ccgrmain.o
-include $(random-obj:.o=.d)

# extra dependencies
gramlex.yy.o: grampar.codes.h

# ------ targets -------
# reads the grammar and emits C++ code for semantic functions
gramanl-dep := gramanl.cc gramexpl.o $(grammar-set) $(grampar-set) \
               parsetables.o $(libraries)
gramanl: $(gramanl-dep) grammar.h gramanl.h
	$(link) -o gramanl -DGRAMANL_MAIN $(gramanl-dep)

lexer1yy.cc: lexer1.lex lexer1.h
	flex lexer1.lex

# first pass lexer
lexer1-dep := lexer1.cc lexer1yy.o fileloc.o $(libraries)
lexer1: $(lexer1-dep)
	$(link) -o lexer1 -DTEST_LEXER1 $(lexer1-dep)

# second pass lexer
lexer2-dep := lexer2.cc lexer1.o lexer1yy.o $(AST)/fileloc.o \
              $(AST)/strtable.o cc_lang.o $(libraries)
lexer2: $(lexer2-dep) lexer2.h
	$(link) -o lexer2 -DTEST_LEXER2 $(lexer2-dep)

# grammar lexer
# like in ast/, need to replace forward decl with proper #include
gramlex.yy.cc: gramlex.lex
	flex -o$@ gramlex.lex
	mv $@ gramlex.tmp
	sed 's/class istream;/#include <iostream.h>/' <gramlex.tmp >$@
	rm gramlex.tmp

# grammar lexer test program
gramlex-dep := gramlex.yy.cc gramlex.cc $(AST)/fileloc.o $(AST)/ccsstr.o \
               $(AST)/embedded.o $(libraries)
gramlex: gramlex.h $(gramlex-dep)
	$(link) -o gramlex -DTEST_GRAMLEX $(gramlex-dep)

# grammar parser
grampar.tab.cc grampar.tab.h grampar.codes.h: grampar.y gramast.ast.gen.h
	bison -d -v grampar.y
	mv -f grampar.tab.c tmp
	sed 's/typedef union {/typedef union YYSTYPE {/' < tmp > grampar.tab.cc
	mv -f grampar.tab.h tmp
	sed 's/typedef union {/typedef union YYSTYPE {/' < tmp > grampar.tab.h
	rm tmp
	grep '# *define' grampar.tab.h > grampar.codes.h

# (unmaintained) grammar parser test program
# grampar: grampar.cc $(grammar-set) gramlex.yy.o grampar.tab.o \
#          $(AST)/gramlex.o ast.o $(AST)/fileloc.o gramast.ast.gen.o $(AST)/ccsstr.o \
#          $(AST)/embedded.o $(AST)/strtable.o $(AST)/asthelp.o \
#          $(libraries)
# 	$(link) -o grampar -DTEST_GRAMPAR $^

# cycle timer test
cyctimer: cyctimer.cc cyctimer.h
	g++ -o $@ $(ccflags) $(includes) -DTEST_CYCTIMER cyctimer.cc $(linkend)

# token list for my grammar
cc.tok: lexer2
	./lexer2 myparser > cc.tok

# C expression (sort of) evaluator
cexp2-sem-dep := cexp2.sem.cc $(grammar-set) $(glr-set) \
                 $(grampar-set) $(libraries)
cexp2.sem: $(cexp2-sem-dep)
	$(link) -o cexp2.sem -DTEST_CEXP2_SEM $(cexp2-sem-dep)

# intermediate files for cexp2
# ('chmod a-w' is so I don't accidentally edit them)
cexp2.cc cexp2.h: cexp2.gr gramanl
	rm -f cexp2.h cexp2.cc
	./gramanl cexp2
	chmod a-w cexp2.cc cexp2.h

# parser and semantic analyzer for cexp2.gr
cexp2-dep := cexp2.o $(grammar-set) $(grampar-set) \
             $(glr-set) $(libraries)
cexp2: $(cexp2-dep) cexp2.h
	$(link) -o cexp2 $(cexp2-dep)

# glr parsing engine
libglr.a: $(glr-set)
	rm -f libglr.a
	ar -r libglr.a $(glr-set)
	ranlib libglr.a

# intermediate files for cexp3 (disambiguates using prec/assoc)
# ('chmod a-w' is so I don't accidentally edit it)
#cexp3.gr.gen.cc cexp3.gr.gen.h: cexp3.gr cc.tok gramanl
#	rm -f cexp3.gr.gen.*
#	./gramanl cexp3
#	chmod a-w cexp3.gr.gen.{h,cc}

#cexp3ast.h cexp3ast.cc: cexp3ast.ast
#	../../ast/astgen cexp3ast.ast

# AUXDEPEND
cexp3.gr.gen.o: cexp3ast.ast.gen.h

# ast for cexp3
# (these rules should be superceded by pattern rule below)
#cexp3ast.gen.cc cexp3ast.gen.h: cexp3ast.ast $(AST)/astgen
#	$(AST)/astgen cexp3ast.ast

# parser and semantic analyzer for cexp3.gr
# the egrep below is because there's a bug in gcc-2's 'cout',
# which prints ints in hex even when it shouldn't ...
cexp-dep := glrmain.o cexp3mrg.o cexp3ast.ast.gen.o \
            $(support-set) libglr.a $(libraries)
cexp3-dep := cexp3.gr.gen.o $(cexp-dep)
cexp3: $(cexp3-dep)
	$(link) -o cexp3 $(cexp3-dep)
	./cexp3 cexp3.bin in/cexp3.in1 | tee tmp.out
	egrep 'result: (0x)?7' tmp.out

# intermediate files for a grammar
# TRGRAMANL: extra trace flags specified by user; starts with "," if defined
# ('chmod a-w' is so I don't accidentally edit it)
.PRECIOUS: %.gr.gen.cc %.gr.gen.h
%.gr.gen.cc %.gr.gen.h %.gr.gen.y: %.gr cc.tok gramanl
	rm -f $*.gr.gen.*
	./gramanl -tr conflict$(TRGRAMANL) $*
	chmod a-w $*.gr.gen.h $*.gr.gen.cc

# intermediate files for an ast spec
.PRECIOUS: %.ast.gen.cc %.ast.gen.h
%.ast.gen.cc %.ast.gen.h: %.ast $(AST)/astgen
	rm -f $*.ast.gen.*
	$(AST)/astgen -b$*.ast.gen $*.ast
	chmod a-w $*.ast.gen.h $*.ast.gen.cc

# don't delete these things
.PRECIOUS: cexp3b cexp3

# cexp3b: disambiguation using 'merge'
cexp3b.gr: cexp3.gr
	rm -f cexp3b.gr
	grep -v PREC cexp3.gr > cexp3b.gr
	chmod a-w cexp3b.gr

# parser and semantic analyzer for cexp3b.gr
cexp3b-dep := cexp3b.gr.gen.o $(cexp-dep)
cexp3b: $(cexp3b-dep)
	$(link) -o cexp3b $(cexp3b-dep)
	./cexp3b cexp3b.bin in/cexp3.in1 | tee tmp.out
	egrep 'result: (0x)?7' tmp.out

# intermediate files for cdecl
# (superceded by pattern rule)
#cdecl.gen.cc cdecl.gen.h: cdecl.gr cc.tok gramanl
#	rm -f cdecl.gen.*
#	./gramanl cdecl
#	chmod a-w cdecl.gen.{h,cc}

# parser and semantic analyzer for cdecl.gr
cdecl-dep := cdecl.gen.o glrmain.o libglr.a $(libraries)
cdecl: $(cdecl-dep)
	$(link) -o cdecl $(cdecl-dep)
	./cdecl cdecl.bin in/cdecl.in1
	./cdecl -tr cdecl cdecl.bin in/cdecl.in1 | grep -v progress > tmp
	diff out/cdecl.out1 tmp

# intermediate files for cdecl2
# (superceded by pattern rule)
#cdecl2.gen.cc cdecl2.gen.h: cdecl2.gr cc.tok gramanl
#	rm -f cdecl2.gen.*
#	./gramanl cdecl2
#	chmod a-w cdecl2.gen.{h,cc}

# parser and semantic analyzer for cdecl2.gr
cdecl2-dep := cdecl2.gen.o glrmain.o libglr.a $(libraries)
cdecl2: $(cdecl2-dep)
	$(link) -o cdecl2 $(cdecl2-dep)
	./cdecl2 cdecl2.bin in/cdecl.in1
	./cdecl2 -tr cdecl cdecl2.bin in/cdecl.in1 | grep -v progress > tmp
	diff out/cdecl.out1 tmp

# don't delete these because error messages often point into them
.PRECIOUS: cc.gr.gen.h cc.gr.gen.cc

# parser and semantic analyzer for cc.gr, rolled up as a library for
# easier importing into ocaml
# turns out if you don't remove the library, there's a possibility
# of old object files staying in it .. !
libccgr.a: cc.gr.gen.o $(cc-set) libglr.a
	cp -f libglr.a libccgr.a
	ar -r libccgr.a cc.gr.gen.o $(cc-set)
	ranlib libccgr.a

# stand-alone executable
ifeq ($(ocaml), no)
ccgr: ccgrmain.o libccgr.a $(SMBASE)/libsmbase.a
	$(link) -o ccgr $^
	./ccgr cc.bin c.in/c.in1
else
ccgr:
	@echo "we don't build ccgr in ocaml mode"
endif

.PRECIOUS: ccgr

# bison parser from the same grammar; the 'sed' is because Bison
# already interpretes 0 as EOF, and if my rule names it explicitly
# then it gets mad
bccgr.y: cc.gr.gen.y
	echo '%{' > bccgr.y
	echo '#include "bccgr.h"' >> bccgr.y
	echo '%}' >> bccgr.y
	sed 's/File "L2_EOF"/File/' <cc.gr.gen.y >>bccgr.y

# bison parser from the a given grammar; the 'sed' is because Bison
# already interpretes 0 as EOF, and if my rule names it explicitly
# then it gets mad
%.y: %.gr.gen.y
	echo '%{' > $@
	echo '#include "trivbison.h"' >> $@
	echo '%}' >> $@
	sed 's/"EOF" {/{/' <$*.gr.gen.y >>$@

# run Bison; the 'sed' command is to silence a spurious warning about
# 'yyval' being used uninitialized; I also compile here (instead of
# relying on another pattern rule) because I want to control exactly
# how the compilation happens (to ensure the Bison-parser is compiled
# with flags to make it a fair performance test with my own stuff)
%.tab.c %.tab.o %.tab.h: %.y
	bison -d -v $*.y
	mv $*.tab.c $*.tab.c.orig
	sed 's/YYSTYPE yyval;/YYSTYPE yyval = 0;/' <$*.tab.c.orig >$*.tab.c
	rm $*.tab.c.orig
	g++ -c -g -o $*.tab.o -Wall -O2 -DNDEBUG $(YYDEBUG) $*.tab.c

bccgr.tab.o: bccgr.h

bccgr: bccgr.cc bccgr.tab.o lexer1.o lexer1yy.o lexer2.o $(AST)/fileloc.o \
       $(AST)/strtable.o cc_lang.o cyctimer.o $(SMBASE)/libsmbase.a
	g++ -o bccgr $(ccflags) $(includes) $(YYDEBUG) $^
	./bccgr c.in/c.in1

# run the trivial-grammar helper
.PRECIOUS: %.gr %.tree.gr
%.gr: %.gr.in make-trivparser.pl
	rm -f $@
	./make-trivparser.pl $(notdir $*) <$*.gr.in >$@
	chmod a-w $@

%.tree.gr: %.gr.in make-trivparser.pl
	rm -f $@
	./make-trivparser.pl -ptree $(notdir $*) <$*.gr.in >$@
	chmod a-w $@

# make a parser for testing some grammar, using trivial lexer
trivparse-deps := trivmain.cc ptreenode.o trivlex.o $(support-set) \
                  libglr.a
%.gr.exe: %.gr.gen.o $(trivparse-deps)
	g++ -o $@ $(ccflags) $(includes) -DGRAMMAR_NAME=\"$*.bin\" \
	  $^ $(linkend)


# similar, for Bison as the parser-generator
%.bison.exe: %.tab.o trivbison.o trivlex.o lexer2.o ptreenode.o \
             libglr.a
	g++ -o $@ $(ccflags) $(includes) $^ $(linkend)

# new C++ parser
cc2.exe: cc2main.o $(cc-set) cc2/cc2.gr.gen.o ptreenode.o libglr.a $(SMBASE)/libsmbase.a
	g++ -o $@ $(ccflags) $^

# new C++ grammar with treebuilding actions
cc2/cc2t.gr.gen.cc cc2/cc2t.gr.gen.h cc2/cc2t.gr.gen.y: cc2/cc2.gr cc.tok gramanl
	rm -f cc2/cc2t*
	sed 's/cc2\.gr\.gen\.h/cc2t.gr.gen.h/' <cc2/cc2.gr >cc2/cc2t.gr
	./gramanl -tr treebuild$(TRGRAMANL) cc2/cc2t
	chmod a-w cc2/cc2t.gr*

# new C++ parser with treebuilding
cc2t.exe: cc2main.o $(cc-set) cc2/cc2t.gr.gen.o ptreenode.o libglr.a $(SMBASE)/libsmbase.a
	g++ -o $@ $(ccflags) $^


# stuff in examples directory
.PHONY: examples
examples:
	cd examples/arith; make clean && make


# ----------------------------- EFa -----------------------
# input for EFa
triv/efa.in:
	mkdir $@
	perl -e 'foreach $$n (500, 1000, 1500, 2000, 2500, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000) {  \
	           $$name = sprintf("%07d", $$n);            \
	           open(OUT, ">$@/$$name.in") or die $!; \
	           print OUT "A";                            \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("PA");                       \
	           }                                         \
	           close(OUT);                               \
	         }'

EFA_TESTS := triv/efa.perf.txt triv/efa.notree.perf.txt triv/efa.bison.tree.perf.txt triv/efa.bison.notree.perf.txt

#.PHONY: $(EFA_TESTS) all-efa

# run all the EFa tests; the whole batch runs in less than a minute
# (well, they did before I put in the loop from 1 to 5 ...)
all-efa: $(EFA_TESTS)

# performance test for EFa
triv/efa.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.gr.exe -tr progress -count $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.notree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.gr.exe -tr progress,trivialActions $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.bison.tree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.tree.bison.exe $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

triv/efa.bison.notree.perf.txt:
	rm -f $@
	for fn in triv/efa.in/*; do \
	  for count in 1 2 3 4 5; do \
	    triv/EFa.bison.exe $$fn 2>&1 | \
	      sed "s,^,$$fn: ," >> $@ ; \
	  done; \
	done

%.csv: %.txt
	cat $^ | grep cycles | \
	  perl -p -e 's/^[^:]*\D(\d+)\D.*:.*\D(\d+)_(\d+) cycles.*$$/$$1, $$2$$3/' >$@

all-efa-csv: $(EFA_TESTS:.txt=.csv)


# --------------------------- EEb -----------------------
# input for EEb
triv/eeb.in:
	mkdir $@
	perl -e 'foreach $$n (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 20, 50, 100, 200, 300, 400, 500) {  \
	           open(OUT, ">$@/$$n.in") or die $!;    \
	           print OUT "B";                            \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("PB");                       \
	           }                                         \
	           close(OUT);                               \
	         }'

# performance test for EEb
triv/eeb.perf.txt:
	rm -f $@
	for n in 10 20 50 100 200 300 400 500; do \
	  triv/EEb.tree.gr.exe -tr progress -count triv/eeb.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/eeb.notree.perf.txt:
	rm -f $@
	for n in 10 20 50 100 200 300 400 500; do \
	  triv/EEb.tree.gr.exe -tr progress,trivialActions triv/eeb.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done


# --------------------------- SSx ----------------------
# input for SSx
triv/ssx.in:
	mkdir $@
	perl -e 'for($$n=1; $$n <= 99; $$n += 2) {           \
	           open(OUT, ">$@/$$n.in") or die $!;        \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("X");                        \
	           }                                         \
	           close(OUT);                               \
	         }'

# performance test for SSx
triv/ssx.perf.txt:
	rm -f $@
	for n in 15 25 35 45 55 65 75 85 99; do \
	  triv/SSx.tree.gr.exe -tr progress -count triv/ssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/ssx.notree.perf.txt:
	rm -f $@
	for n in 15 25 35 45 55 65 75 85 99; do \
	  triv/SSx.tree.gr.exe -tr progress,trivialActions triv/ssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done



# --------------------------- SSSx ----------------------
# input for SSSx
triv/sssx.in:
	mkdir $@
	perl -e 'for($$n=1; $$n <= 99; $$n += 1) {           \
	           open(OUT, ">$@/$$n.in") or die $!;        \
	           for($$i=0; $$i < $$n; $$i++) {            \
	             print OUT ("X");                        \
	           }                                         \
	           close(OUT);                               \
	         }'

triv/sssx.perf.txt:
	rm -f $@
	for n in 5 10 15 20 25 30 35 40 45 50; do \
	  triv/SSSx.tree.gr.exe -tr progress -count triv/sssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done

triv/sssx.notree.perf.txt:
	rm -f $@
	for n in 5 10 15 20 25 30 35 40 45 50; do \
	  triv/SSSx.tree.gr.exe -tr progress,trivialActions triv/sssx.in/$$n.in 2>&1 | \
	    sed "s/^/$$n: /" >> $@ ; \
	done


# ------------------------ documentation -----------------------
# dependencies for 'gramanl', the parser generator executable
doc/gramanl.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) gramanl.cc >$@

# dependencies for 'glr.h', the entry point to the runtime library
doc/glr.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) glr.h >$@

# dependencies for 'ccgr', the prototype C parser and typechecker
doc/cc.dot:
	$(SMBASE)/scan-depends.pl -r -I$(AST) -Nglr.h ccgrmain.h >$@

# use 'dot' to lay out the graph
# http://www.research.att.com/sw/tools/graphviz/
doc/%.ps: doc/%.dot
	dot -Tps <$^ >$@

# use 'convert' to make a PNG image with resolution not to exceed
# 1000 in X or 700 in Y ('convert' will preserve aspect ratio); this
# also antialiases, so it looks very nice (it's hard to reproduce
# this using 'gs' alone)
doc/%.png: doc/%.ps
	convert -geometry 1000x700 $^ $@

# "make doc" should build whatever we have that needs building
.PHONY: doc
doc: doc/gramanl.png doc/glr.png doc/cc.png

doc-clean:
	cd doc; rm -f {gramanl,glr}.{ps,dot,png}


# -------------------- clean, check, etc. ------------------
clean:
	rm -f *.o *~ *.d *.exe *.gen.* *.bin *.tab.* *.output
	rm -f gramanl glr lexer1 lexer1yy.cc gramlex.yy.cc gramlex
	rm -f lexer2 grampar.tab.* grampar a.out
	rm -f cexp2.sem cexp2 cc.bin ccgr libccgr.a libglr.a
	rm -f cc.gr.ps
	rm -f core cdecl cexp3 bccgr cdecl2 cexp3b
	rm -f bccgr.y cc.tok grampar.codes.h
	rm -f gdb.log gprof.out gmon.out
	cd triv; rm -f *.exe *.gen.* *.bin *.tab.* *.output *.y *.gr

distclean:
	rm -f Makefile
	cd triv; rm -rf sssx.in ssx.in eeb.in

check: all
	./regrtest
	@echo ""
	@echo "Regression tests passed."

# --------------- random other stuff --------------------
# printable version of the C++ grammar; removes the '// C++' tags
# because they just wrap onto next line and mess things up
cc.gr.ps:
	sed 's#[ 	]*// C[+][+].*##' < cc.gr \
	  | enscript -2r --output=cc.gr.ps ; true

# test for rcptr
trcptr: rcptr.h trcptr.cc
	$(link) -o trcptr trcptr.cc
