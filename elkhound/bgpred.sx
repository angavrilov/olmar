; bgpred.sx  -*- lisp -*-
; background predicate for running Simplify

(PROMPT_OFF)
(BG_PUSH (AND

  ; how to simplify a few expression kinds
  (FORALL (x)     ; not needed: (PATS (uMinus x))
    (EQ (uMinus x) (- 0 x)))

  ; how to take apart a pointer
  (FORALL (b f)
    (EQ
      (object (pointer b f))
      b
    ))

  (FORALL (b f)
    (EQ
      (offset (pointer b f))
      f
    ))

  ; arithmetic does not change the object
  (FORALL (ptr ofs)           (PATS (object (+ ptr ofs)))
    (EQ
      (object (+ ptr ofs))
      (object ptr)
    ))
  (FORALL (ptr ofs)           (PATS (object (- ptr ofs)))
    (EQ
      (object (- ptr ofs))
      (object ptr)
    ))

  ; arithmetic changes the offset in the obvious way
  (FORALL (ptr ofs)           (PATS (offset (+ ptr ofs)))
    (EQ
      (offset (+ ptr ofs))
      (+ (offset ptr) ofs)
    ))
  (FORALL (ptr ofs)           (PATS (offset (- ptr ofs)))
    (EQ
      (offset (- ptr ofs))
      (- (offset ptr) ofs)
    ))

  ; reading from the same location as was last written
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; fact that construction and deconstruction is identity
  ; pattern means this applies whenever both (object p) and
  ; (offset p) are around, for the same p
  (FORALL (p)                 (PATS (MPAT (object p) (offset p)))
    (EQ
      p
      (pointer (object p) (offset p))
    ))

  ; pointer disequality can be shown by showing either component
  ; is unequal
  (FORALL (obj1 obj2 ofs1 ofs2)
    (IMPLIES
      (OR
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))

  ; reading first zero from a memory where last changed obj is diff't
  (FORALL (mem obj1 obj2 ofs1 value)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (update mem obj1 ofs1 value) obj2)
        (firstZero mem obj2)
      )
    ))
  (FORALL (mem obj1 obj2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (changed mem obj1) obj2)
        (firstZero mem obj2)
      )
    ))

  ; validPointer: abstraction of a valid pointer
  ; causes Simplify to mess up?
  ;(FORALL (p)
  ;  (IMPLIES
  ;    (validPointer p)
  ;    (AND
  ;      (>= (offset p) 0)
  ;      (< (offset p) (length (object p)))
  ;    )
  ;  ))
  
  ; read the last-updated value out of a tuple
  ;   n: field index
  ;   s: structure (tuple) value
  ;   v: last-updated value
  (FORALL (n s v)
    (EQ
      (getElt n (setElt n s v))
      v
    ))

  ; skip past the last-updated value when reading a different entry
  ;   n: field index being read
  ;   m: field index last updated
  ;   s: original tuple value
  ;   v: last-updated value
  (FORALL (n m s v)
    (IMPLIES
      (NEQ n m)
      (EQ
        (getElt n (setElt m s v))
        (getElt n s)
      )
    ))

))
