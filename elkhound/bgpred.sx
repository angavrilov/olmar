; bgpred.sx  -*- lisp -*-
; background predicate for running Simplify

(PROMPT_OFF)
(BG_PUSH (AND

  ; how to simplify a few expression kinds
  (FORALL (x)     ; not needed: (PATS (MPAT (uMinus x)))
    (EQ (uMinus x) (- 0 x)))

  ; how to take apart a pointer
  (FORALL (b f)
    (EQ
      (object (pointer b f))
      b
    ))

  (FORALL (b f)
    (EQ
      (offset (pointer b f))
      f
    ))

  ; arithmetic does not change the object
  (FORALL (ptr ofs)           (PATS (MPAT (object (+ ptr ofs))))
    (EQ
      (object (+ ptr ofs))
      (object ptr)
    ))
  (FORALL (ptr ofs)           (PATS (MPAT (object (- ptr ofs))))
    (EQ
      (object (- ptr ofs))
      (object ptr)
    ))

  ; arithmetic changes the offset in the obvious way
  (FORALL (ptr ofs)           (PATS (MPAT (offset (+ ptr ofs))))
    (EQ
      (offset (+ ptr ofs))
      (+ (offset ptr) ofs)
    ))
  (FORALL (ptr ofs)           (PATS (MPAT (offset (- ptr ofs))))
    (EQ
      (offset (- ptr ofs))
      (- (offset ptr) ofs)
    ))

  ; reading from the same location as was last written
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; pointer disequality can be shown by showing either component
  ; is unequal
  (FORALL (obj1 obj2 ofs1 ofs2)
    (IMPLIES
      (OR
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))

  ; reading first zero from a memory where last changed obj is diff't
  (FORALL (mem obj1 obj2 ofs1 value)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (update mem obj1 ofs1 value) obj2)
        (firstZero mem obj2)
      )
    ))
  (FORALL (mem obj1 obj2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (changed mem obj1) obj2)
        (firstZero mem obj2)
      )
    ))

  ; validPointer: abstraction of a valid pointer
  ; causes Simplify to mess up?
  ;(FORALL (p)
  ;  (IMPLIES
  ;    (validPointer p)
  ;    (AND
  ;      (>= (offset p) 0)
  ;      (< (offset p) (length (object p)))
  ;    )
  ;  ))
))
