; bgpred.sx  -*- lisp -*-
; background predicate for running Simplify

(PROMPT_OFF)

(DEFPRED (inDegree0 mem field obj))
(DEFPRED (inDegree1 mem field obj referrerObj))

(BG_PUSH (AND

  ; ---------------- misc -----------------
  ; how to simplify a few expression kinds
  (FORALL (x)     ; not needed: (PATS (uMinus x))
    (EQ (uMinus x) (- 0 x)))

  ; ------------- tuple: "pointer" ---------------
  ; how to take apart a pointer
  (FORALL (b f)
    (EQ
      (object (pointer b f))
      b
    ))

  (FORALL (b f)
    (EQ
      (offset (pointer b f))
      f
    ))

  ; arithmetic does not change the object
  (FORALL (ptr ofs)           (PATS (object (+ ptr ofs)))
    (EQ
      (object (+ ptr ofs))
      (object ptr)
    ))
  (FORALL (ptr ofs)           (PATS (object (- ptr ofs)))
    (EQ
      (object (- ptr ofs))
      (object ptr)
    ))

  ; arithmetic changes the offset in the obvious way
  (FORALL (ptr ofs)           (PATS (offset (+ ptr ofs)))
    (EQ
      (offset (+ ptr ofs))
      (+ (offset ptr) ofs)
    ))
  (FORALL (ptr ofs)           (PATS (offset (- ptr ofs)))
    (EQ
      (offset (- ptr ofs))
      (- (offset ptr) ofs)
    ))

  ; fact that construction and deconstruction is identity
  ; pattern means this applies whenever both (object p) and
  ; (offset p) are around, for the same p
  (FORALL (p)                 (PATS (MPAT (object p) (offset p)))
    (EQ
      p
      (pointer (object p) (offset p))
    ))

  ; pointer disequality can be shown by showing either component
  ; is unequal
  (FORALL (obj1 obj2 ofs1 ofs2)
    (IMPLIES
      (OR
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
    ))

  ; --------------- theory: select/update ------------------
  ; reading from the same location as was last written
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))

  ; ------------- extension for strings: firstZero -----------------
  ; reading first zero from a memory where last changed obj is diff't
  (FORALL (mem obj1 obj2 ofs1 value)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (update mem obj1 ofs1 value) obj2)
        (firstZero mem obj2)
      )
    ))
  (FORALL (mem obj1 obj2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (changed mem obj1) obj2)
        (firstZero mem obj2)
      )
    ))

  ; validPointer: abstraction of a valid pointer
  ; causes Simplify to mess up?
  ; update: maybe because I didn't do defpred validPointer?
  ;(FORALL (p)
  ;  (IMPLIES
  ;    (validPointer p)
  ;    (AND
  ;      (>= (offset p) 0)
  ;      (< (offset p) (length (object p)))
  ;    )
  ;  ))

  ; ------------------- theory: arbitrary tuples -----------------
  ; read the last-updated value out of a tuple
  ;   n: field index
  ;   s: structure (tuple) value
  ;   v: last-updated value
  (FORALL (n s v)
    (EQ
      (getElt n (setElt n s v))
      v
    ))

  ; skip past the last-updated value when reading a different entry
  ;   n: field index being read
  ;   m: field index last updated
  ;   s: original tuple value
  ;   v: last-updated value
  (FORALL (n m s v)
    (IMPLIES
      (NEQ n m)
      (EQ
        (getElt n (setElt m s v))
        (getElt n s)
      )
    ))

; this section causes Simplify to drop into an infinite loop    
;   ; -------------------- theory: node in-degree --------------------
;   ; how the in-degree changes across a memory update
;   ;   mem0: initial memory configuration
;   ;   mem1: memory after the update
;   ;   next: field whose in-degree is being tested
;   ;   offset: the field written by the update
;   ;   a: object whose in-degree is of interest
;   ;   b: object whose 'offset' field was changed
;   ;   x: object to which b's next field pointed in mem0
;   ;   y: object to which b's offset field now points, in mem1
;   ;   n: in-degree of 'a' in mem0
;   ;   m: in-degree of 'a' in mem1
;   (FORALL (mem0 mem1 next ofs a b x y n m)
;     (IMPLIES
;       (AND
;         (EQ (select mem0 b next) x)          ; b->next == x, in mem0
;         (EQ (inDegree mem0 next a) n)        ; n things point to a, in mem0
;         (EQ mem1 (update mem0 b ofs y))      ; b->ofs := y (to form mem1)
;         (EQ (inDegree mem1 next a) m)        ; m things point to a, in mem1
;       )
;       (AND
;         (IMPLIES (NEQ ofs next) (EQ n m))      ; different field?  no change
;         (IMPLIES (EQ ofs next) (AND            ; same field...
;           (IMPLIES (NEQ a x) (AND                ; b previously didn't point at a
;             (IMPLIES (EQ a y) (EQ m (+ n 1)))      ; b now points at a; inDegree++
;             (IMPLIES (NEQ a y) (EQ m n))           ; b still doesn't point at a; no change
;           ))
;           (IMPLIES (EQ a x) (AND                 ; b previously pointed at a
;             (IMPLIES (EQ a y) (EQ m n))            ; b still points at a; no change
;             (IMPLIES (NEQ a y) (EQ m (- n 1)))     ; b now points elsewhere; inDegree--
;           ))
;         ))
;       )
;     ))

  ; ==================== new in-degree predicates ================
  ; --------------------------- inDegree0 ------------------------
  ; inDegree0: state that a particular node has nothing pointing to
  ; it, w.r.t. some field
  ;(DEFPRED (inDegree0 mem field obj))
  ;  mem: memory state in which this claim is true
  ;  field: offset of the field in question
  ;  obj: object whose in-degree is 0

  ; inDegree0-no-point: nothing else points to it; I don't write
  ; this as IFF because I don't want Simplify to try to use this to
  ; *prove* inDegree0
  (FORALL (mem field obj)
    (IMPLIES
      (inDegree0 mem field obj)
      (FORALL (otherObj)
        (NEQ
          (object (select mem otherObj field))
          obj
        ))
    ))

  ; inDegree0-surv-otherObj: survives updates which don't install
  ; pointers to the object in question
  (FORALL (mem field obj referrerObj otherObj otherOfs)
    (IMPLIES
      (AND
        (inDegree0 mem field obj)
        (NEQ otherObj obj)
      )
      (inDegree0
        (update mem referrerObj field (pointer otherObj otherOfs))
        field obj)
    ))

  ; inDegree0-surv-otherField: it also survives updates to other fields
  (FORALL (mem field obj referrerObj otherObj otherOfs otherField)
    (IMPLIES
      (AND
        (inDegree0 mem field obj)
        (NEQ otherField field)
      )
      (inDegree0
        (update mem referrerObj otherField (pointer otherObj otherOfs))
        field obj)
    ))


  ; --------------------------- inDegree1 ------------------------
  ; inDegree1: exactly one thing points to an object, and we give that
  ; thing a name
  ;(DEFPRED (inDegree1 mem field obj referrerObj))
  ;   referrerObj: object whose 'field' field points at 'obj'

  ; inDegree1-one-point: referrerObj->field == obj
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree1 mem field obj referrerObj)
      (EQ
        (select mem referrerObj field)
        obj
      )
    ))

  ; another implication: nothing besides 'referrerObj' points at it
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree1 mem field obj referrerObj)
      (FORALL (otherObj)
        (IMPLIES
          (NEQ otherObj referrerObj)
          (NEQ
            (select mem otherObj field)
            obj
          )))
    ))

  ; inDegree1-surv-otherObj: inDegree1 survives updates that don't
  ; mention obj or referrerObj
  (FORALL (mem field obj referrerObj srcObj destObj destOfs)
    (IMPLIES
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ srcObj referrerObj)
        (NEQ destObj obj)
      )
      (inDegree1
        (update mem srcObj field (pointer destObj destOfs))
        field obj referrerObj)
    ))

  ; inDegree1-surv-otherField: survives updates to different fields
  (FORALL (mem field obj referrerObj srcObj destObj destOfs otherField)
    (IMPLIES
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ field otherField)
      )
      (inDegree1
        (update mem srcObj otherField (pointer destObj destOfs))
        field obj referrerObj)
    ))

  ; ---------------- inDegree0 -> inDegree1 --------------------
  ; inDegree0-to-inDegree1: how inDegree0 becomes inDegree1
  ; Q: should I explicitly make the offset 0 here?
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree0 mem field obj)                           ; in-degree was 0
      (inDegree1
        (update mem referrerObj field (pointer obj 0))    ; referrer changed
        field obj referrerObj)                            ; so conclude inDegree1
    ))

  ; ---------------- inDegree1 -> inDegree0 --------------------
  (FORALL (mem field obj referrerObj otherObj otherOfs)
    (IMPLIES                                          
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ obj otherObj)
      )
      (inDegree0
        (update mem referrerObj field (pointer otherObj otherOfs))
        field obj)
    ))

))
