; bgpred.sx  -*- lisp -*-
; background predicate for running Simplify

(PROMPT_OFF)

(DEFPRED (inDegree0 mem field obj))
(DEFPRED (inDegree1 mem field obj referrerObj))
(DEFPRED (hasTypeNode obj))

; true when nothing stored in 'mem' refers to 'objAddr'
(DEFPRED (freshObj objAddr mem))

; true iff ok to (sel obj index)
(DEFPRED (okSel obj index))

; true iff ok to (selOffset obj offset)
(DEFPRED (okSelOffset obj offset))

; true iff ok to (selOffset obj (addOffset offset i)) for all 0 <= i < len
(DEFPRED (okSelOffsetRange obj offset len))

; true iff ptr1 is not a prefix of ptr2, and vice-versa
(DEFPRED (unrelated ptr1 ptr2))

; true when 'okSel' is always true for an object (typically memory)
(DEFPRED (uncheckedAccess obj))

; x == whole
(DEFPRED (isWhole x))

; an address is a tree node object, for treeadd
(DEFPRED (treeNode mem addr))

(DEFPRED (equalMemory mem1 mem2))

(BG_PUSH (AND

  ; ---------------- misc -----------------
  ; how to simplify a few expression kinds
  (FORALL (x)     ; not needed: (PATS (uMinus x))
    (EQ (uMinus x) (- 0 x)))
    
  ; strangely, this is needed for fact3.sx, if the assumptions
  ; are introduced using IMPLIES (as opposed to BG_PUSH)
  (FORALL (n)
    (EQ (* n 1) n)
  )

  ; more simple arithmetic..
  (FORALL (i j k)
    (EQ (* (* i j) k)
        (* j (* k i))
    ))
  
  ; and I have always said I didn't want to axiomatize arithmetic...
  (FORALL (x y) (EQ (* x y) (* y x)))
  (FORALL (x n) (EQ (- (+ x n) n) x))

;   ; ------------- tuple: "pointer" ---------------
;   ; how to take apart a pointer
;   (FORALL (b f)
;     (EQ
;       (object (pointer b f))
;       b
;     ))

;   (FORALL (b f)
;     (EQ
;       (offset (pointer b f))
;       f
;     ))

;   ; arithmetic does not change the object
;   (FORALL (ptr ofs)           (PATS (object (+ ptr ofs)))
;     (EQ
;       (object (+ ptr ofs))
;       (object ptr)
;     ))
;   (FORALL (ptr ofs)           (PATS (object (- ptr ofs)))
;     (EQ
;       (object (- ptr ofs))
;       (object ptr)
;     ))

;   ; arithmetic changes the offset in the obvious way
;   (FORALL (ptr ofs)           (PATS (offset (+ ptr ofs)))
;     (EQ
;       (offset (+ ptr ofs))
;       (+ (offset ptr) ofs)
;     ))
;   (FORALL (ptr ofs)           (PATS (offset (- ptr ofs)))
;     (EQ
;       (offset (- ptr ofs))
;       (- (offset ptr) ofs)
;     ))

;   ; fact that construction and deconstruction is identity
;   ; pattern means this applies whenever both (object p) and
;   ; (offset p) are around, for the same p
;   (FORALL (p)                 (PATS (MPAT (object p) (offset p)))
;     (EQ
;       p
;       (pointer (object p) (offset p))
;     ))

;   ; pointer disequality can be shown by showing either component
;   ; is unequal
;   (FORALL (obj1 obj2 ofs1 ofs2)
;     (IMPLIES
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
;       (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;     ))

;   ; --------------- theory: select/update ------------------
;   ; reading from the same location as was last written
;   (FORALL (mem obj ofs value)
;     (EQ
;       (select (update mem obj ofs value) obj ofs)
;       value
;     ))

;   ; reading from a different location from last written
;   (FORALL (mem obj1 obj2 ofs1 ofs2 value)
;     (IMPLIES
;       (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
; ;       (OR
; ;         (NEQ obj1 obj2)      ; different objects
; ;         (NEQ ofs1 ofs2)      ; different offsets
; ;       )
;       (EQ
;         (select (update mem obj1 ofs1 value) obj2 ofs2)
;         (select mem obj2 ofs2)
;       )))

;   ; you can read past a 'changed' marker, but only if you're
;   ; reading from a different object
;   (FORALL (mem obj1 obj2 ofs2)
;     (IMPLIES
;       (NEQ obj1 obj2)
;       (EQ
;         (select (changed mem obj1) obj2 ofs2)
;         (select mem obj2 ofs2)
;       )
;     ))

  ; ------------- extension for strings: firstZero -----------------
  ; reading first zero from a memory where last changed obj is diff't
  
  ; removed this because if firstZero is applied to the object, not
  ; its address, then this stuff is not needed
  ;   (FORALL (mem obj1 obj2 ofs1 value)
  ;     (IMPLIES
  ;       (NEQ obj1 obj2)
  ;       (EQ
  ;         (firstZero (update mem obj1 ofs1 value) obj2)
  ;         (firstZero mem obj2)
  ;       )
  ;     ))
  ;   (FORALL (mem obj1 obj2)
  ;     (IMPLIES
  ;       (NEQ obj1 obj2)
  ;       (EQ
  ;         (firstZero (changed mem obj1) obj2)
  ;         (firstZero mem obj2)
  ;       )
  ;     ))

  ; validPointer: abstraction of a valid pointer
  ; causes Simplify to mess up?
  ; update: maybe because I didn't do defpred validPointer?
  ;(FORALL (p)
  ;  (IMPLIES
  ;    (validPointer p)
  ;    (AND
  ;      (>= (offset p) 0)
  ;      (< (offset p) (length (object p)))
  ;    )
  ;  ))

  ; ------------------- theory: arbitrary tuples -----------------
  ; read the last-updated value out of a tuple
  ;   n: field index
  ;   s: structure (tuple) value
  ;   v: last-updated value
  (FORALL (n s v)
    (EQ
      (getElt n (setElt n s v))
      v
    ))

  ; skip past the last-updated value when reading a different entry
  ;   n: field index being read
  ;   m: field index last updated
  ;   s: original tuple value
  ;   v: last-updated value
  (FORALL (n m s v)
    (IMPLIES
      (NEQ n m)
      (EQ
        (getElt n (setElt m s v))
        (getElt n s)
      )
    ))

; this section causes Simplify to drop into an infinite loop    
;   ; -------------------- theory: node in-degree --------------------
;   ; how the in-degree changes across a memory update
;   ;   mem0: initial memory configuration
;   ;   mem1: memory after the update
;   ;   next: field whose in-degree is being tested
;   ;   offset: the field written by the update
;   ;   a: object whose in-degree is of interest
;   ;   b: object whose 'offset' field was changed
;   ;   x: object to which b's next field pointed in mem0
;   ;   y: object to which b's offset field now points, in mem1
;   ;   n: in-degree of 'a' in mem0
;   ;   m: in-degree of 'a' in mem1
;   (FORALL (mem0 mem1 next ofs a b x y n m)
;     (IMPLIES
;       (AND
;         (EQ (select mem0 b next) x)          ; b->next == x, in mem0
;         (EQ (inDegree mem0 next a) n)        ; n things point to a, in mem0
;         (EQ mem1 (update mem0 b ofs y))      ; b->ofs := y (to form mem1)
;         (EQ (inDegree mem1 next a) m)        ; m things point to a, in mem1
;       )
;       (AND
;         (IMPLIES (NEQ ofs next) (EQ n m))      ; different field?  no change
;         (IMPLIES (EQ ofs next) (AND            ; same field...
;           (IMPLIES (NEQ a x) (AND                ; b previously didn't point at a
;             (IMPLIES (EQ a y) (EQ m (+ n 1)))      ; b now points at a; inDegree++
;             (IMPLIES (NEQ a y) (EQ m n))           ; b still doesn't point at a; no change
;           ))
;           (IMPLIES (EQ a x) (AND                 ; b previously pointed at a
;             (IMPLIES (EQ a y) (EQ m n))            ; b still points at a; no change
;             (IMPLIES (NEQ a y) (EQ m (- n 1)))     ; b now points elsewhere; inDegree--
;           ))
;         ))
;       )
;     ))

  ; ==================== new in-degree predicates ================
  ; --------------------------- inDegree0 ------------------------
  ; inDegree0: state that a particular node has nothing pointing to
  ; it, w.r.t. some field
  ;(DEFPRED (inDegree0 mem field obj))
  ;  mem: memory state in which this claim is true
  ;  field: offset of the field in question
  ;  obj: object whose in-degree is 0

  ; inDegree0-no-point: nothing else points to it; I don't write
  ; this as IFF because I don't want Simplify to try to use this to
  ; *prove* inDegree0
  (FORALL (mem field obj)
    (IMPLIES
      (inDegree0 mem field obj)
      (FORALL (otherObj)
        (NEQ
          (object (select mem otherObj field))
          obj
        ))
    ))

  ; inDegree0-surv-otherObj: survives updates which don't install
  ; pointers to the object in question
  (FORALL (mem field obj referrerObj otherObj otherOfs)
    (IMPLIES
      (AND
        (inDegree0 mem field obj)
        (NEQ otherObj obj)
      )
      (inDegree0
        (update mem referrerObj field (pointer otherObj otherOfs))
        field obj)
    ))

  ; inDegree0-surv-otherField: it also survives updates to other fields
  (FORALL (mem field obj referrerObj otherObj otherOfs otherField)
    (IMPLIES
      (AND
        (inDegree0 mem field obj)
        (NEQ otherField field)
      )
      (inDegree0
        (update mem referrerObj otherField (pointer otherObj otherOfs))
        field obj)
    ))


  ; --------------------------- inDegree1 ------------------------
  ; inDegree1: exactly one thing points to an object, and we give that
  ; thing a name
  ;(DEFPRED (inDegree1 mem field obj referrerObj))
  ;   referrerObj: object whose 'field' field points at 'obj'

  ; inDegree1-one-point: referrerObj->field == obj
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree1 mem field obj referrerObj)
      (EQ
        (object (select mem referrerObj field))
        obj
      )
    ))

  ; inDegree1-none-other: nothing besides 'referrerObj' points at it
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree1 mem field obj referrerObj)
      (FORALL (otherObj)
        (IMPLIES
          (NEQ otherObj referrerObj)
          (NEQ
            (object (select mem otherObj field))
            obj
          )))
    ))

  ; inDegree1-surv-otherObj: inDegree1 survives updates that don't
  ; mention obj or referrerObj
  (FORALL (mem field obj referrerObj srcObj destObj destOfs)
    (IMPLIES
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ srcObj referrerObj)
        (NEQ destObj obj)
      )
      (inDegree1
        (update mem srcObj field (pointer destObj destOfs))
        field obj referrerObj)
    ))

  ; inDegree1-surv-otherField: survives updates to different fields
  (FORALL (mem field obj referrerObj srcObj destObj destOfs otherField)
    (IMPLIES
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ field otherField)
      )
      (inDegree1
        (update mem srcObj otherField (pointer destObj destOfs))
        field obj referrerObj)
    ))

  ; ---------------- inDegree0 -> inDegree1 --------------------
  ; inDegree0-to-inDegree1: how inDegree0 becomes inDegree1
  ; Q: should I explicitly make the offset 0 here?
  (FORALL (mem field obj referrerObj)
    (IMPLIES
      (inDegree0 mem field obj)                           ; in-degree was 0
      (inDegree1
        (update mem referrerObj field (pointer obj 0))    ; referrer changed
        field obj referrerObj)                            ; so conclude inDegree1
    ))

  ; ---------------- inDegree1 -> inDegree0 --------------------
  ; inDegree1-to-inDegree0
  (FORALL (mem field obj referrerObj otherObj otherOfs)
    (IMPLIES                                          
      (AND
        (inDegree1 mem field obj referrerObj)
        (NEQ obj otherObj)
      )
      (inDegree0
        (update mem referrerObj field (pointer otherObj otherOfs))
        field obj)
    ))

    
  ; ================== new, generalized sel/upd ===============
  ; (sel obj index): select subobject 'index' from 'obj'; the index
  ;                  could be an array index, or a field number
  ; (upd obj index val): yield a modified 'obj' where (sel obj index)
  ;                      equals 'val' in the yielded object

  ; reading from the most recently-written field
  (FORALL (obj index val)
    (EQ
      (sel (upd obj index val) index)          ; obj[index := val].index
      val
    ))

  ; reading from a different field
  (FORALL (obj index1 index2 val)
    (IMPLIES
      (NEQ index1 index2)
      (EQ
        (sel (upd obj index1 val) index2)      ; obj[index1 := val].index2
        (sel obj index2)                       ; obj.index2
      )
    ))

  ; when overwriting, can forget intervening writes
;   (FORALL (obj index lostVal newVal)  (PATS (upd (upd obj index lostVal) index newVal))
;     (EQ
;       (upd (upd obj index lostVal) index newVal)
;       (upd obj index newVal)
;     ))

  (FORALL (mem1 mem2)    ;(PATS (EQ mem1 mem2))
    (IMPLIES
      (FORALL (index)
        (EQ (sel mem1 index) (sel mem2 index)))
      (equalMemory mem1 mem2)
    ))

  (FORALL (mem1 mem2)
    (IMPLIES
      (equalMemory mem1 mem2)
      (EQ mem1 mem2)
    ))  

  ; okSel: ok to access a field
  (FORALL (obj index)
    (IMPLIES
      (AND
        (>= index 0)
        (< index (length obj))
      )
      (okSel obj index)
    ))

  ; length: survives updates to elements
  (FORALL (obj index val)
    (EQ
      (length obj)
      (length (upd obj index val))
    ))

  ; okSel: ok to access survives updates to elements
  (FORALL (obj index1 index2 val)   (PATS (okSel (upd obj index1 val) index2))
    (IMPLIES
      (okSel obj index2)                     ; index2 was valid before
      (okSel (upd obj index1 val) index2)    ; and it's still valid
    ))

;   ; ---------------------- uncheckedAccess ------------------
;   ; ok to access any field in an unchecked-access object (like memory itself)
;   (FORALL (mem index)
;     (IMPLIES
;       (uncheckedAccess mem)
;       (okSel mem index)
;     ))

;   ; unchecked-access survives updates (another idea: I could make okSel
;   ; always skip updates..)
;   (FORALL (mem index val)
;     (IMPLIES
;       (uncheckedAccess mem)
;       (uncheckedAccess (upd mem index val))
;     ))

  ; =================== sel/upd with offsets ===================
  ; An "index" is an atomic array index or field number; it can
  ; be (or equal to) a literal integer.  An "offset" is a possibly
  ; empty sequence of indexes.
  
  ; Offsets are built from this grammar:
  ;   offset ::= sub(index, offset) | whole

  ; reading from a nonempty offset:
  ;   selOffset(M, .i rest) === selOffset(M.i, rest)
  (FORALL (obj index rest)
    (EQ
      (selOffset obj (sub index rest))
      (selOffset (sel obj index) rest)
    ))

  ; reading from an empty offset
  ;   selOffset(M, .) === M
  (FORALL (obj)
    (EQ
      (selOffset obj whole)
      obj
    ))

  ; writing through a nonempty offset
  ;   updOffset(M, .i rest, val) === M[i := updOffset(M.i, rest, val)]
  (FORALL (obj index rest val)
    (EQ
      (updOffset obj (sub index rest) val)
      (upd obj index (updOffset (sel obj index) rest val))
    ))

  ; writing through an empty offset
  ;   updOffset(M, ., val) === val
  (FORALL (obj val)
    (EQ
      (updOffset obj whole val)
      val
    ))

  ; ------------------ direct read/write with offsets ----------------
  ; selOffset of updOffset at same place
  (FORALL (mem ptr val)
    (EQ
      (selOffset (updOffset mem ptr val) ptr)
      val
    ))

  ; setOffset of updOffset at different place
  ; unfortunately, Simplify loops with this axiom..
;   (FORALL (mem ptr1 ptr2 val2)    (PATS (selOffset (updOffset mem ptr2 val2) ptr1))
;     (IMPLIES
;       (unrelated ptr1 ptr2)
;       (EQ
;         (selOffset mem ptr1)
;         (selOffset (updOffset mem ptr2 val2) ptr1)
;       )
;     ))

  ; skip past a write that uses a different starting object
  ; (will have to add additional cases in an ad-hoc way, since
  ; the general axiom above can't be used..)
  (FORALL (mem index1 rest1 index2 rest2 val2)
    (IMPLIES
      (NEQ index1 index2)
      (EQ
        (selOffset mem (sub index1 rest1))
        (selOffset (updOffset mem (sub index2 rest2) val2)
                   (sub index1 rest1))
      )
    ))

  ; skip past a write at a different offset from the same pointer
  (FORALL (mem basePtr index1 index2 val2)
    (IMPLIES
      (NEQ index1 index2)
      (EQ
        (selOffset mem (addOffset basePtr index1))
        (selOffset (updOffset mem (addOffset basePtr index2) val2)
                   (addOffset basePtr index1))
      )
    ))

  ; this is needed for reasoning about multiple writes to memory
  ; at the same location, when the goal talks about memory as a whole
  ; instead of the values at individual cells
  (FORALL (mem ptr oldVal newVal)
    (EQ
      (updOffset (updOffset mem ptr oldVal) ptr newVal)
      (updOffset mem ptr newVal)       ; can forget previous write
    ))

  ; ----------------------- unrelated -------------------
  ; [unr1] unrelated: first indices differ
;   (FORALL (a rest1 b rest2)    ;(PATS (unrelated (sub a rest1) (sub b rest2)))
;     (IMPLIES
;       (NEQ a b)
;       (unrelated (sub a rest1) (sub b rest2))
;     ))

;   ; [unr2] unrelated: unrelated rests
;   (FORALL (a rest1 b rest2)    ;(PATS (unrelated (sub a rest1) (sub b rest2)))
;     (IMPLIES
;       (unrelated rest1 rest2)
;       (unrelated (sub a rest1) (sub b rest2))
;     ))

;   ; [unr3] unrelated: different offsets of same pointer
;   (FORALL (ptr i j)
;     (IMPLIES
;       (NEQ i j)
;       (unrelated (addOffset ptr i) (addOffset ptr j))
;     ))

  ; -------------------- okSelOffset ----------------
  ; if the offset is 'whole', it's always ok
  (FORALL (obj)
    (okSelOffset obj whole))

  ; can skip going through okSel for these
  ; no you can't!
  ;   (FORALL (mem ptr)
  ;     (IMPLIES
  ;       (uncheckedAccess mem)
  ;       (okSelOffset mem )
  ;     ))

  ; for non-whole offsets, check the first index, then recursively
  ; check the rest of the offset (will Simplify get lost??  I'll
  ; try to avoid that with a pattern that limits it to applications
  ; when the goal is desired)
  ; update: vcgen/swap1.c wants to use the rule in reverse, so I've
  ; gone ahead and removed the pattern and changed "implies" to "iff"
  (FORALL (obj index rest)   ;(PATS (okSelOffset obj (sub index rest)))
    (IFF       ;IMPLIES
      (AND
        (okSel obj index)
        (okSelOffset (sel obj index) rest)
      )
      (okSelOffset obj (sub index rest))
    ))

  ; it survives all memory updates; this is true because I don't model
  ; *pointer* dereferences with 'sel', I only model accesses within
  ; objects, which doesn't change
  (FORALL (mem obj1 obj2 val)   ;(PATS (okSelOffset (upd mem obj2 val) obj1))
    (IMPLIES
      (okSelOffset mem obj1)
      (okSelOffset (upd mem obj2 val) obj1)
    ))

  ; survives the other kind of update too..
  (FORALL (mem obj1 ofs val)    ;(PATS (okSelOffset (updOffset mem ofs val) obj1))
    (IMPLIES
      (okSelOffset mem obj1)
      (okSelOffset (updOffset mem ofs val) obj1)
    ))

  ; --------------------- addOffset -----------------
  ; NOTE: I tried using "+" instead of "addOffset", but Simplify
  ; loops forever

  ; arithmetic with a nested offset
  ;   addOffset(.i.k rest, j) === .i.addOffset(.k rest, j)
  (FORALL (i j k rest)
    (EQ
      (addOffset (sub i (sub k rest)) j)
      (sub i (addOffset (sub k rest) j))
    ))

  ; arithmetic with a base offset
  ;   addOffset(.i whole, j) === .(i+j)
  (FORALL (i j)
    (EQ
      (addOffset (sub i whole) j)
      (sub (+ i j) whole)
    ))

  ; ------------------- okSelOffsetRange ----------------
  ; prove okSelOffsetRange by proving a universal (easy)
  (FORALL (obj offset len)    (PATS (okSelOffsetRange obj offset len))
    (IMPLIES
      (FORALL (i)     ; forall 0 <= i < len. okSelOffset(obj, offset+i)
        (IMPLIES
          (AND (<= 0 i) (< i len))
          (okSelOffset obj (addOffset offset i))
        ))
      (okSelOffsetRange obj offset len)
    ))

  ; use okSelOffsetRange to prove okSelOffset
  (FORALL (obj offset len i)   (PATS (MPAT (okSelOffsetRange obj offset len)
                                           (okSelOffset obj (addOffset offset i))))
    (IMPLIES
      (AND
        (okSelOffsetRange obj offset len)
        (<= 0 i) (< i len)
      )
      (okSelOffset obj (addOffset offset i))
    ))

  ; -------------------- appendIndex ----------------
  ; append an index specifier to an empty offset
  ;   appendIndex(whole, index) === .index
  (FORALL (index)
    (EQ
      (appendIndex whole index)
      (sub index whole)
    ))
   
  ; append an index to a nonempty offset
  ;   appendIndex(.a rest, index) === .a.appendIndex(rest, index)
  (FORALL (a rest index)
    (EQ
      (appendIndex (sub a rest) index)
      (sub a (appendIndex rest index))
    ))

  ; ---------------- selectors for offsets ---------------
  ; firstIndexOf: select first component of 'sub'
  (FORALL (index rest)
    (EQ
      (firstIndexOf (sub index rest))
      index
    ))

  ; restOf: select second component of 'sub'
  (FORALL (index rest)
    (EQ
      (restOf (sub index rest))
      rest
    ))

  ; isWhole: equal to 'whole'; can't just say that though because
  ; I make up new variables ...
  (FORALL (x)
    (IFF
      (isWhole x)
      (EQ whole x)
    ))

  ; whatever..
  (EQ whole 0)

  ; special case: if I know that 'restOf' is whole, then I know the
  ; pointer is equal to sub(firstIndex)
  (FORALL (ptr)
    (IMPLIES
      (EQ whole (restOf ptr))
      (EQ ptr (sub (firstIndexOf ptr) whole))
    ))

  ; ------------------------ fresh -------------------------
  ; two memories are (or at least can be) equal if the only
  ; modification involves objects fresh in the older one
  ; (this is unsound in the presence of divergent memory histories)
  (FORALL (obj mem val)   (PATS (MPAT (freshObj obj mem)
                                      (upd mem obj val) ))
    (IMPLIES
      (freshObj obj mem)    ; if mem0 never talked about obj
      (EQ
        (upd mem obj val)   ; then mem0 with obj changed
        mem                 ; can be considered the same memory
      )))


  ; ------------------- treeNode ------------------
  (FORALL (mem addr)
    (IFF
      (treeNode mem addr)
      (OR
        (EQ addr 0)
        (AND
          (NEQ addr 0)
          (okSel mem addr)
          (treeNode mem (firstIndexOf (sel (sel mem addr) 1)))  ; left
          (EQ whole (restOf (sel (sel mem addr) 1)))
          (treeNode mem (firstIndexOf (sel (sel mem addr) 2)))  ; right
          (EQ whole (restOf (sel (sel mem addr) 2)))
        )
      )
    )
  )

;   ; treeNode => ...
;   (FORALL (mem addr)
;     (IMPLIES
;       (treeNode mem addr)
;       (OR
;         (EQ addr 0)
;         (AND
;           (NEQ addr 0)
;           (okSel mem addr)
;           (treeNode mem (firstIndexOf (sel (sel mem addr) 1)))  ; left
;           (EQ whole (restOf (sel (sel mem addr) 1)))
;           (treeNode mem (firstIndexOf (sel (sel mem addr) 2)))  ; right
;           (EQ whole (restOf (sel (sel mem addr) 2)))
;         )
;       )
;     )
;   )

;   ; ...(1) => treeNode
;   (FORALL (mem addr)
;     (IMPLIES
;       (EQ addr 0)
;       (treeNode mem addr)
;     )
;   )

;   ; ...(2) => treeNode
;   (FORALL (mem addr)
;     (IMPLIES
;       (AND
;         (NEQ addr 0)
;         (okSel mem addr)
;         (treeNode mem (firstIndexOf (sel (sel mem addr) 1)))  ; left
;         (EQ whole (restOf (sel (sel mem addr) 1)))
;         (treeNode mem (firstIndexOf (sel (sel mem addr) 2)))  ; right
;         (EQ whole (restOf (sel (sel mem addr) 2)))
;       )
;       (treeNode mem addr)
;     )
;   )

  ; --------------- factorial --------------
  (EQ (factorial 0) 1)
  (EQ (factorial 1) 1)
  
  (FORALL (n)
    (IMPLIES
      (> n 0)
      (EQ 
        (factorial n)
        (* n (factorial (- n 1)))
      )))

))
