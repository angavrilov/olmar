; bgpred.sx  -*- lisp -*-
; background predicate for running Simplify

(PROMPT_OFF)
(BG_PUSH (AND

  ; how to simplify a few expression kinds
  (FORALL (x)     ; not needed: (PATS (MPAT (uMinus x)))
    (EQ (uMinus x) (- 0 x)))

  ; how to take apart a pointer
  (FORALL (b f)
    (EQ
      (object (pointer b f))
      b
    ))

  (FORALL (b f)
    (EQ
      (offset (pointer b f))
      f
    ))

  ; arithmetic does not change the object
  (FORALL (ptr ofs)           (PATS (MPAT (object (+ ptr ofs))))
    (EQ
      (object (+ ptr ofs))
      (object ptr)
    ))
  (FORALL (ptr ofs)           (PATS (MPAT (object (- ptr ofs))))
    (EQ
      (object (- ptr ofs))
      (object ptr)
    ))

  ; arithmetic changes the offset in the obvious way
  (FORALL (ptr ofs)           (PATS (MPAT (offset (+ ptr ofs))))
    (EQ
      (offset (+ ptr ofs))
      (+ (offset ptr) ofs)
    ))
  (FORALL (ptr ofs)           (PATS (MPAT (offset (- ptr ofs))))
    (EQ
      (offset (- ptr ofs))
      (- (offset ptr) ofs)
    ))

  ; reading from the same location as was last written
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (OR 
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))

  ; reading first zero from a memory where last changed obj is diff't
  (FORALL (mem obj1 obj2 ofs1 value)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (update mem obj1 ofs1 value) obj2)
        (firstZero mem obj2)
      )
    ))
  (FORALL (mem obj1 obj2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (firstZero (changed mem obj1) obj2)
        (firstZero mem obj2)
      )
    ))
))
