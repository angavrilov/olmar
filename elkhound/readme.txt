
10/13/00
Overview docs for this parser generator
---------------------------------------


Deliverables
------------
This parser generator takes as input a language grammar written in
essentially BNF (Backus-Naur Form), and outputs a C++ parser for that
language.  The executable that does this is called 'gramanl' (grammar
analyzer).

Additionally, the 'cc.gr' grammar is a grammar for C and C++.  By running
the parser generator on cc.gr, you get a parser for C/C++.  The Makefile
will generate the 'ccgr' executable which is this grammar's parser.


Limitations
-----------
The present design is geared towards parsing C++.  Thus, for example,
the generated parser always assumes it is using the C++ lexical analyzer.

It is slow and uses a lot of memory.


Phases of parsing
-----------------
The generated parser has several phases:
  Lexer1:    Partitions the input file(s) into tokens.
  Lexer2:    Applies interpretations (e.g. parses integers) to tokens.
  Parse:     Parses the tokens into a (possibly-ambiguous) tree.
  Semantics: Compute some semantics info, primarily to fully
             disambiguate the parse tree.

The lexers aren't very interesting.  There is currently no preprocessor,
so usually it is necessary to run the input through one first.  Gcc's
'-E' flag will do this.

The parser uses the GLR (Generalized LR) parsing algorithm, which permits
both temporary and permanent ambiguity.  This is very convenient for
writing grammars, but it means later stages must resolve any ambiguity
that remains after parsing.

The grammar writer may use synthesized attributes to do some disambiguation
during parsing and tree-building.  These are 'action' and 'condition'
clauses in the grammar input file.

The semantics stage is usually one or more top-down tree traversals.
These traversals are entirely at the direction of the semantic functions
in the grammar input file, denoted by 'fun'.  The semantic functions
may call semantic functions of right-hand-side nonterminals.

Disambiguation in the semantic phase is currently somewhat primitive.
It relies on a special semantic function marked as 'disamb' (instead
of 'fun').  The special function takes responsibility for identifying
which subtrees to eliminate, and then doing the elimination.


Module sets
-----------
Unless otherwise noted, all modules are a .cc file and an .h file.
Read the .h file first, it's shorter and has more "what this does"
type comments.

The first set of modules, called 'grammar-set' in the Makefile, are
for representing grammars in memory.  They are:

  grammar:   Terminal, Nonterminal, Production, Grammar, etc.  This
             is the core of the grammar representation.

  action:    Action, for computing attributes during tree building.

  cond:      Condition, for disambiguation during tree building.

  attr:      Attributes; represents node attribute values.

  litcode:   LiteralCode; stores literal embedded C++ semantic
             function code.


The next set, 'grampar-set', is responsible for parsing grammar input
files and creating the Grammar and associated objects.  The modules are:

  gramlex.lex:  Flex scanner for the grammar input file.

  grampar.y:    Bison grammar for the grammar input file.  The actions
                in this file create an AST for the grammar.

  gramlex:      Wrapper C++ class for the lexer.  Provides a cleaner
                interface than raw flex variable access.

  grampar:      Parses the AST produced by grampar.y and fills in a
                Grammar structure as it parses.
                
  fileloc:      Represents a location in a source file.  Useful for
                error reporting.

  ast:          A generic AST module for use with Bison grammars.

  gramast:      Specialization of 'ast' for the grammar AST.

  ccsstr:       Contains the knowledge needed to parse the embedded C++
                code, e.g., finding the closing "}".


Next, 'glr-set' are the modules for the GLR parsing algorithm itself:

  gramanl:      Grammar analysis.  Given a grammar, it computes things
                like first/follow sets, LR item sets, etc.  This module
                also has the driver to emit the C++ semantic functions.
                
  glrtree:      Represents the parse tree produced by the GLR parser.
  
  glr:          The GLR algorithm itself.
  
  lexer1.lex:   Flex scanner for C/C++.

  lexer1:       First-stage lexical analysis of C/C++ (see Phases
                of parsing, above).
                
  lexer2:       Second-stage lexical analysis of C/C++.
  
  parssppt:     Some generic support routines for parsers.  Contains
                declarations for some of the emitted C++ code.


Next, the 'cc-set' of modules is the implementation of C/C++
semantics.  The routines here are called by the semantic functions in
'cc.gr' to do the bulk of the language-specific stuff.

  cc_tree:      CCTreeNode, a base class for all of the parse tree
                nodes generated by the parser.  Contains code that is
                useful to all such nodes.
                
  cc_type:      Represents C/C++ types, such as "int" and "pointer to
                a function that returns a pointer to struct Foo".

  cc_env:       Environment; declarations result in mappings that get 
                put into the environment.  Knows about scoping.
                
  cc_err:       Objects to represent parse errors.  These get accumulated
                in the environment and reported to the user eventually.


Finally, the 'common' set has just one member:

  trace:        A debugging module.  You write code like:
                  trace("foo") << some-debug-string << endl;
                and this will be printed if the "foo" trace flag is set,
                which is usually done from the command line.
                   

Other documentation
-------------------
There are a few other documentation files lying around:

  readme.txt    This file.

  types.txt     Describes the represntation of C/C++ types.
  
  grammar.txt   Describes the format of grammar files like cc.gr.

  parsgen.txt   Some of the trace flags defined.  Currently incomplete.
  
