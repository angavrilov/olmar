// gramast.ast
// grammar AST, in a new experimental format

// the entire grammar spec
class GrammarAST (ASTList<ToplevelForm> forms);

// something at the top level
class ToplevelForm {
  -> terminals(ASTList<TermDecl> terms);
  -> nonterminal(string name, ASTList<string> baseClasses, ASTList<NTBodyElt> elts);
  -> TF_lit(LiteralCode *lit);
  -> treeNodeBase(string baseClassName);
}

// declaration of a single terminal, aka token
class TermDecl (int code, string name, string alias);

// something that appears in the body of a nonterminal declaration
class NTBodyElt {
  -> attr(string name);
  -> decl(string declBody);
  -> elt(GroupElement *elt);
  -> NT_lit(LiteralCode *lit);
}

// elements of nonterms or form groups
class GroupElement {
  -> form(ASTList<RHSElt> rhs, ASTList<FormBodyElt> elts);    // aka production
  -> formGroup(ASTList<GroupElements> elts);
  -> fbe(FormBodyElement *e);
}

// things that can be directly associated with a form
class FormBodyElement {
  -> action(string name, owner AttrExpr *expr);
  -> condition(owner AttrExpr *condExpr);
  -> treeCompare(string leftName, string rightName, owner AttrExpr *decideExpr);
  -> funDecl(string funDeclBody);
  -> funDefn(string name, string funDefnBody);
}

// one of the things that appears after the '->', i.e. the
// right-hand-side elements
class RHSElt {
  -> ntref(string tag, string ntname);      // nonterminal reference
  -> termref(string tag, string tokname);   // terminal reference
}

// some literal C++ code to be copied verbatim somewhere
class LiteralCode {
  // code that gets associated with some existing semantic function
  -> modifier(string codeKindTag, string funcToModify, string codeBody);
  
  // code that lives on its own, its use entirely determined by
  // the codeKindTag
  -> standAlone(string codeKindTag, string codeBody);
}
