// c.ast
// C abstract syntax

// included in generated header
verbatim {
  #include "cc_flags.h"      // CVFlags, DeclFlags, etc.

  class Env;                 // cc_env.h
  class Type;                // cc_type.h
  class FunctionType;

  class AEnv;                // aenv.h
  class AbsValue;            // absval.ast
} // end verbatim

// included in generated source file
impl_verbatim {
  #include "cc_type.h"       // Type
}


// ---------------- file -------------
// an entire file (with included stuff) of toplevel forms
class TranslationUnit (ASTList<TopForm> topForms) {
  // type checker
  public void tcheck(Env &env);

  // abstract interpreter
  public void vcgen(AEnv &env) const;
}

// a toplevel form
class TopForm {
  pure_virtual void tcheck(Env &env);
  pure_virtual void vcgen(AEnv &env) const;

  -> TF_decl(Declaration decl);        // includes function prototypes

  // functions with bodies
  -> TF_func(DeclFlags dflags,         // static, extern, etc.
             TypeSpecifier retspec,    // type specifier for return value
             Declarator nameParams,    // 1. remainder of return value type
                                       // 2. name of function
                                       // 3. names/types of parameters
             S_compound body) {        // body of function
       public FunctionType const *ftype() const;
       public StringRef name() const;
     }
}

impl_verbatim {
  // pulled these out of line because Declaration appears lower in .h file
  FunctionType const *TF_func::ftype() const 
    { return &( nameParams->type->asFunctionTypeC() ); }
  StringRef TF_func::name() const { return nameParams->name; }
}


// --------------- types and declarators ---------------
// variable declaration or definition, or function declaration
class Declaration (
  enum DeclFlags dflags,               // typedef, virtual, extern, etc.
  TypeSpecifier spec,                  // e.g. "int"
  ASTList<Declarator> decllist         // e.g. "x=3, y"
) {
  public void tcheck(Env &env);
  public void vcgen(AEnv &env) const;
}

// just one complete type; appears in parameter decls and in casts
class ASTTypeId (
  TypeSpecifier spec,      // "int"
  Declarator decl          // this will be abstract sometimes
) {
  public Type const *tcheck(Env &env);
}

// a name of an "atomic" type -- one to which type constructors
// (e.g. '*') can be applied, but which itself is not built with type
// constructors
// that's not quite right -- typedef'd types need not be atomic
class TypeSpecifier {
  public enum CVFlags cv;
  ctor { cv=CV_NONE; };

  // yield the type named by the specifier; this type may of course
  // get refined when the declarator is considered
  pure_virtual Type const *tcheck(Env &env);

  // apply the 'cv' information
  protected Type const *applyCV(Env &env, Type const *base);

  -> TS_name(StringRef name);              // a typedef'd name

  -> TS_simple(SimpleTypeId id);           // int or char or float or ..

  -> TS_elaborated(                        // "class Foo"
       TypeIntr keyword,
       StringRef name
     );

  -> TS_classSpec(                         // "class { ... }"
       TypeIntr keyword,                     // "class", "struct", "union"
       StringRef /*nullable*/ name,          // user-provided name, if any
       ASTList<Declaration> members          // the fields of the struct
     );

  -> TS_enumSpec(                          // "enum { ... }"
       StringRef /*nullable*/ name,          // name of enum, if any
       ASTList<Enumerator> elts              // elements of the enumeration
     );
}

// a binding of a name to a constant value
class Enumerator (
  StringRef name,                       // name of this constant
  Expression /*nullable*/ expr          // constant expr, or NULL for "next"
);


// a thing which introduces a name of a declared thing, and also
// optionally adds type constructors to the base type of the specifier;
// may have an initializing expression, depending on the context
class Declarator (
  IDeclarator decl,                    // syntax of type designation
  Initializer init                     // (nullable) optional data initializer
) {
  public Type const *type;             // computed type for this declarator
  public StringRef name;               // name of thing being introduced
  public bool addrTaken;               // true if '&' is applied to this variable
  ctor { type=NULL; name=NULL; addrTaken=false; };

  // returns the type denoted by the combination of 'base' and the
  // type constructors in this declarator
  public Type const *tcheck(Env &env, Type const *base, DeclFlags dflags);

  public void vcgen(AEnv &env) const;
}


// inner declarator; things recursively buried inside declarators;
// cannot have initializers; the internal structure is not analyzed
// once typechecking determines what type is denoted;
// type constructors are encoded as a (possibly empty) list of pointer
// constructors, then maybe a function or array type, recursively
class IDeclarator {
  public ASTList<PtrOperator> stars;   // pointer constructors, left to right

  // external interface; adds 'stars' before calling 'itcheck'; the
  // toplevel 'declarator' is passed along for annotation purposes
  public Type const *tcheck(Env &env, Type const *base, DeclFlags dflags,
                            Declarator *declarator);

  // returns the type denoted by the combination of 'base' and the
  // type constructors in this declarator (recursively)
  pure_virtual Type const *
    itcheck(Env &env, Type const *base, DeclFlags dflags, Declarator *declarator);

  // dig down and find the name being declared; may return NULL
  pure_virtual StringRef getName() const;

  -> D_name(StringRef /*nullable*/ name);                       // "x" (NULL means abstract declarator or anonymous parameter)
  -> D_func(IDeclarator base, ASTList<ASTTypeId> params,        // "f(int)"
            ASTList<FuncAnnotation> ann);
  -> D_array(IDeclarator base, Expression /*nullable*/ size);   // "a[5]" or "b[]"
  -> D_bitfield(StringRef /*nullable*/ name, Expression bits);  // "c : 2"
}

// each star is associated with one of these; it's here so I can expand
// it to include C++'s '&'
class PtrOperator (CVFlags cv);

// ------------------- statements -----------------
class Statement {
  pure_virtual void tcheck(Env &env);
  pure_virtual void vcgen(AEnv &env) const;

  -> S_skip();      // nop; used whenever optional Statement is not present
  -> S_label(StringRef name, Statement s);
  -> S_case(Expression expr, Statement s);
  -> S_caseRange(Expression low, Expression high, Statement s);
  -> S_default(Statement s);
  -> S_expr(Expression expr);      // expression evaluated for side effect
  -> S_compound(ASTList<Statement> stmts);
  -> S_if(Expression cond, Statement thenBranch, Statement elseBranch);
  -> S_switch(Expression expr, Statement branches);
  -> S_while(Expression cond, Statement body);
  -> S_doWhile(Statement body, Expression cond);
  -> S_for(Statement init, Expression cond,
           Expression after, Statement body);
  -> S_break();
  -> S_continue();
  -> S_return(Expression /*nullable*/ expr);
  -> S_goto(StringRef target);
  -> S_decl(Declaration decl);
  
  // theorem prover extensions
  -> S_assert(Expression expr);
  -> S_assume(Expression expr);
  -> S_invariant(Expression expr);
}


// ----------------- expressions -----------------
// general C expressions
class Expression {
  // type check and yield the type of the expression; this type
  // gets automatically stored in the 'type' field
  public Type const *tcheck(Env &env);
  public Type const *type;
  ctor type=NULL;

  custom debugPrint {
    if (type) {
      ind(os, indent) << "type: " << type->toCString() << "\n";
    }
    else {
      ind(os, indent) << "type: (null)\n";
    }
  }

  // inner typechecker which does not have to store its result
  // in 'type'
  pure_virtual Type const *itcheck(Env &env);

  // try to evaluate the expression as a constant integer;
  // this can *only* be done after the expression has been tcheck'd
  pure_virtual int constEval(Env &env) const;
  protected int xnonconst() const;       // throws XNonConst

  // unparse the expression
  pure_virtual string toString() const;
  
  // given the current abstract environment, return the abstract value
  // representing this expression's result, and also update the environment
  // to reflect any side effects; for now, will return NULL if the value
  // is not an integer type
  pure_virtual AbsValue *vcgen(AEnv &env) const;

  -> E_intLit(int i);
  -> E_floatLit(float f);
  -> E_stringLit(StringRef s);    // not quite right b/c can't handle embedded nuls
  -> E_charLit(char c);
  -> E_structLit(ASTTypeId stype, ASTList<Initializer> init);

  -> E_variable(StringRef name);
  -> E_arrayAcc(Expression arr, Expression index);
  -> E_funCall(Expression func, ASTList<Expression> args);
  -> E_fieldAcc(Expression obj, StringRef field);

  -> E_unary(UnaryOp op, Expression expr);
  -> E_binary(Expression e1, BinaryOp op, Expression e2);

  // these are not ordinary unary operators because of their importance
  -> E_addrOf(Expression expr);
  -> E_deref(Expression ptr);

  -> E_cast(ASTTypeId ctype, Expression expr);
  -> E_cond(Expression cond, Expression th, Expression el);
  -> E_gnuCond(Expression cond, Expression el);
  -> E_comma(Expression e1, Expression e2);
  -> E_sizeofType(ASTTypeId atype) {
       public int size;     // size of the type
       ctor size=-1;
     }

  // these are not ordinary binary because they too are special
  -> E_assign(Expression target, Expression src);
  -> E_arithAssign(Expression target, BinaryOp op, Expression src);   // e.g. "+="
}

// animals which appear after declarations to assign initial values
class Initializer {
  // when a label is present it modifies which element of the
  // surrounding structure is being initialized
  public InitLabel *label;      // (nullable) gnu: range or field label
  ctor { label = NULL; };

  // check that the initializer is well-typed, given the type of
  // the thing it initializes
  pure_virtual void tcheck(Env &env, Type const *type);

  // compute an abstract value for this initializer
  pure_virtual AbsValue *vcgen(AEnv &env, Type const *type) const;

  -> IN_expr(Expression e);
  -> IN_compound(ASTList<Initializer> inits);
}

// gnu extension to attach particular elements of an initializer list
// to particular fields of the structure or array being initialized
class InitLabel {
  -> IL_element(Expression index);
  -> IL_range(Expression low, Expression high);   // inclusive 
  -> IL_field(StringRef name);
  -> IL_elementField(Expression index, StringRef name);
}


// -------------- annotations ---------------
class FuncAnnotation {
  -> FA_precondition(Expression expr);
  -> FA_postcondition(Expression expr);
}
