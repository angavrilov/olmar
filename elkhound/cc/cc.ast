// cc.ast            see license.txt for copyright and terms of use
// C++ abstract syntax

// note: wherever ASTList or FakeList is used, its elements are listed
// in the order they appear lexically in the input file, i.e. right to
// left and then top to bottom

// How do I decide between ASTList and FakeList?  Creating ASTLists
// can be done with left recursion, which saves stack space, whereas
// FakeLists require right recursion.  But, ASTLists cannot safely
// be yielded as semantic values if there's any chance they'll be
// yielded more than once.
//
// So, I use FakeList everywhere I can accept the stack growth.  The
// only places I cannot accept this growth are places where it is
// relatively common for the list to have >100 elements.  Those
// places are:
//   - toplevel forms (and namespace toplevels, when I add them)
//   - statement lists in compound statements
//   - class/struct members
//   - compound initializers
//
// In these places where I use ASTList, I encapsulate it in another
// class if necessary to avoid yielding it as a semantic value.

// included in generated header
verbatim {
  #include "sobjlist.h"      // SObjList
  #include "variable.h"      // Variable
  #include "cc_flags.h"      // CVFlags, DeclFlags, etc. (r)
  #include "cc_type.h"       // Type, FunctonType, CompoundType

  class Env;                 // cc_env.h
//    #include <stdio.h>
} // end verbatim

// included in generated source file
impl_verbatim {
  //#include "cc_type.h"       // Type
//    #include <stdio.h>
}


// ---------------- file -------------
// an entire file (with included stuff) of toplevel forms; I use
// an ASTList here because I want to use left recursion, and
// there's never a multiple-yield problem with toplevel forms
class TranslationUnit (ASTList<TopForm> topForms) {
  // type checker
  public void tcheck(Env &env);
  public void twalk(Env &env);
}

// a toplevel form
class TopForm (SourceLocation loc) {
  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);
                                       
  // includes function prototypes
  -> TF_decl(Declaration decl);
                                       
  // functions with bodies
  -> TF_func(Function f);

  // template functions or template classes
  -> TF_template(TemplateDeclaration td);
  
  // linkage specification enclosing a bunch of forms
  -> TF_linkage(StringRef linkageType, TranslationUnit forms);
}


// ----------------------- function -------------------------
// a function definition (toplevel or class member)
class Function (
  DeclFlags dflags,             // static, extern, etc.

  TypeSpecifier retspec,        // type specifier for return value

  Declarator nameAndParams,     // 1. remainder of return value type
                                // 2. name of function
                                // 3. names/types of parameters

  FakeList<MemberInit> *inits,  // (for ctors only) member initialization list

  S_compound body,              // body of function

  FakeList<Handler> *handlers   // handlers for ctor "try" block
) {
  // if 'checkBody' is false, we treat this like it was just
  // a prototype for the function
  public void tcheck(Env &env, bool checkBody);
  public void twalk(Env &env);

  private CompoundType *verifyIsCtor(Env &env, char const *context);
  private void tcheck_memberInits(Env &env);
  private void twalk_memberInits(Env &env);
  private void tcheck_handlers(Env &env);
  private void twalk_handlers(Env &env);
}

class MemberInit (
  PQName name,                   // name of member or base class
  FakeList<Expression> *args     // arguments to its constructor
) {
  // standard way to make it possible to include something
  // in a FakeList; this line is repeated below in several places
  public MemberInit *next;  ctor next=NULL;     // FakeList link
}


// --------------- types and declarators ---------------
// variable declaration or definition, or function declaration
class Declaration (
  enum DeclFlags dflags,               // typedef, virtual, extern, etc.
  TypeSpecifier spec,                  // e.g. "int"
  FakeList<Declarator> *decllist       // e.g. "x=3, y"
) {
  public void tcheck(Env &env);        // adds declared variables to env
  public void twalk(Env &env);        // adds declared variables to env
}

// just one complete type; appears in parameter decls and in casts
class ASTTypeId (
  TypeSpecifier spec,        // "int"
  Declarator decl            // this will be abstract sometimes (e.g. casts)
) {
  public ASTTypeId *next;  ctor next=NULL;     // FakeList link
  
  // typecheck the typeid; if we're in the context of an E_new, then
  // pass is_E_new as true, in which case this function may return a
  // non-null Expression* corresponding to the 'size' argument to
  // new[]
  public Expression *tcheck(Env &env, bool in_E_new=false);

  public void twalk(Env &env);
  
  public Type const *getType() const;      // can use after calling 'tcheck'
}

// a name with optional class qualifiers (PQ: "possibly qualified");
// if the first qualifier is NULL, then it means there was a leading
// "::" symbol
class PQName {
  public bool hasQualifiers() const { return isPQ_qualifier(); };

  public string qualifierString() const;  
  public string toString() const;
  public friend stringBuilder& operator<< (stringBuilder &sb, PQName const &obj);

  // retrieve a StringRef for the underlying name, be it a PQ_name or
  // a PQ_operator
  pure_virtual StringRef getName() const;

  // get the PQName at the bottom of any qualifiers
  public PQName const *getUnqualifiedName() const;

  // typecheck the template arguments buried in this PQName
  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);


  // outer qualifier applied to some inner PQName, plus an optional
  // list of template arguments to the qualifier
  -> PQ_qualifier(StringRef qualifier, FakeList<TemplateArgument> *targs,
                  PQName rest);

  // final name, when it's an ordinary identifier
  // NOTE: 'name' here is *never* NULL--instead, I use NULL
  // PQName pointers in abstract declarators
  -> PQ_name(StringRef name);

  // "operator" names; 'o' has the full info, while 'fakeName' is
  // for getName(), which is sometimes used for string maps
  -> PQ_operator(OperatorName o, StringRef fakeName);
  
  // template instances: a template function or class name, plus
  // some template arguments 
  -> PQ_template(StringRef name, FakeList<TemplateArgument> *args);
}


// a name of an "atomic" type--one to which type constructors
// (e.g. '*') can be applied, but which itself is not syntactically
// built with type constructors (typedef'd types may have been built
// with type constructors when the name was defined, but a
// TypeSpecifier refers only to the name)
class TypeSpecifier {
  public enum CVFlags cv;
  ctor { cv=CV_NONE; };

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // yield the type named by the specifier; this type may of course
  // get refined when the declarator is considered
  pure_virtual Type const *tcheck(Env &env);
  pure_virtual void twalk(Env &env);

  -> TS_name(PQName name);                 // a typedef'd name (typedef might be implicit, as for classes)

  -> TS_simple(SimpleTypeId id);           // int or char or float or ..

  -> TS_elaborated(                        // "class Foo"
       SourceLocation loc,
       TypeIntr keyword,
       PQName name
     );

  -> TS_classSpec(                         // "class { ... }"
       SourceLocation loc,
       TypeIntr keyword,                     // "class", "struct", "union"
       StringRef /*nullable*/ name,          // user-provided name, if any
       FakeList<BaseClassSpec> *bases,       // base classes
       MemberList members                    // field and methods of the class
     ) {
       private void tcheckFunctionBodies(Env &env);
       //public void twalk(Env &env);
     }

  -> TS_enumSpec(                          // "enum { ... }"
       SourceLocation loc,
       StringRef /*nullable*/ name,          // name of enum, if any
       FakeList<Enumerator> *elts            // elements of the enumeration
     );
}

// base class specification
class BaseClassSpec (
  bool isVirtual,                       // true for virtual base classes
  AccessKeyword access,                 // public/protected/private
  PQName name                           // name of base class
) {
  public BaseClassSpec *next;  ctor next=NULL;     // FakeList link
  public void twalk(Env &env);
}


// list of class members; this is encapsulated so I can use
// ASTList without yielding ASTLists in cc.gr
class MemberList (ASTList<Member> list);

// member of a class
class Member {
  -> MR_decl(Declaration d);            // data members or functions w/o bodies
  -> MR_func(Function f);               // function with body
  -> MR_access(AccessKeyword k);        // section header
  -> MR_publish(PQName name);           // publish a superclass member
  
  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);
}

// a binding of a name to a constant value
class Enumerator (
  SourceLocation loc,                   // location
  StringRef name,                       // name of this constant
  Expression /*nullable*/ expr          // constant expr, or NULL for "next"
) {
  public Enumerator *next;  ctor next=NULL;     // FakeList link

  public Variable *var;                 // (serf) introduction record
  ctor var=NULL;

  // when the enumerator values are computed, I store them here
  // so I can see them in the AST printout; I only print this
  // value if 'var' is non-NULL
  public int enumValue;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // we pass both the base 'enum' and the Type wrapped around it,
  // since both are needed and it's slightly expensive to compute
  // one from the other for each enumerator
  public void tcheck(Env &env, EnumType *parentEnum, Type *parentType);
  public void twalk(Env &env);
}


verbatim {              
  // this class contains the data passed into and out of the
  // declarator checking functions
  struct DeclaratorTcheck {
    // the bottom-most IDeclarator (D_name or D_bitfield) creates
    // or looks up a Variable, and sets this to point at it
    Variable *var;

    // on the way in, this is the type computed so far; initially
    // it's just the type specifier but additional declarators will
    // layer additional type constructors on top of it and replace
    // the pointer here with a pointer to the constructed type; at
    // the end it is the fully-constructed type
    //
    // however, it need not be the same type as var->type at the
    // end, because var->type might be a function type from a
    // prototype (with the prototype's parameter names) while this
    // field will be the constructed type with its names
    Type const *type;

    // these are the declflags attached to the outer declaration
    DeclFlags dflags;
    
    // when this is set to true, we're inside an E_new, so be on
    // the lookout for the final [size] expression
    bool in_E_new;

    // in a new[] declarator, when we hit the final [size], stash
    // the size's AST node pointer here; then E_new can collect it
    Expression *size_E_new;

  public:
    DeclaratorTcheck(Type const *t, DeclFlags d)
      : var(NULL), type(t), dflags(d),
        in_E_new(false), size_E_new(NULL) {}
    DeclaratorTcheck(DeclaratorTcheck const &obj)
      : var(obj.var), type(obj.type), dflags(obj.dflags),
        in_E_new(obj.in_E_new), size_E_new(obj.size_E_new) {}

    DeclaratorTcheck& operator= (DeclaratorTcheck const &obj) {
      var = obj.var;
      type = obj.type;
      dflags = obj.dflags;
      in_E_new = obj.in_E_new;
      size_E_new = obj.size_E_new;
      return *this;
    }
  };
}


// Syntactically, a Declarator is a thing which introduces a name of a
// declared thing, and also optionally adds type constructors to the
// base type of the specifier.  It may have an initializing
// expression, depending on the context.
class Declarator (
  IDeclarator decl,                    // syntax of type designation
  Initializer init                     // (nullable) optional data initializer
) {
  public Variable *var;                // (serf) computed information: name, type, etc.
  ctor var=NULL;
//    ctor printf("**************** Declarator ctor\n");
                                                       
  // FakeList link; use 'setNext' to set 'next'
  public Declarator *next;  ctor next=NULL;
  public void setNext(Declarator *newNext);    
  
  // ambiguity representation
  public Declarator *ambiguity;  ctor ambiguity=NULL;
  public void addAmbiguity(Declarator *alternative);

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // determine the type denoted by the combination of 'dt.type' and
  // the type constructors in this declarator, then make a Variable
  // which has that type and store it in 'dt.var'; if this declarator
  // refers to something that is *already* declared (like a function
  // with a prior prototype), the 'var' field will be shared among the
  // various declarations; if not, put it into the environment
  //
  // the return value specifies which of possibly ambiguous
  // alternatives was selected
  public /*no_ignore*/ Declarator *tcheck(Env &env, DeclaratorTcheck &dt);
  public void mid_tcheck(Env &env, DeclaratorTcheck &dt);
  public void twalk(Env &env);
}


// inner declarator; things *recursively* buried inside declarators;
// cannot have initializers; the internal structure is not analyzed
// once typechecking determines what type is denoted;
// type constructors are encoded as a (possibly empty) list of pointer
// constructors, then maybe a function or array type, recursively
class IDeclarator {
  // external interface; add the type constructor represented by this
  // IDeclarator to 'dt.type' and then make a Variable to represent
  // it; put the variable into the environment if appropriate
  pure_virtual void tcheck(Env &env, DeclaratorTcheck &dt);
  public void twalk(Env &env);

  // dig down and find the name being declared; may return NULL
  pure_virtual PQName const *getDeclaratorId() const;

  // "x" (NULL means abstract declarator or anonymous parameter);
  // this is used for ctors and dtors as well as ordinary names
  // (dtor names start with "~"); it's also used for operator names
  -> D_name(SourceLocation loc,
            PQName /*nullable*/ name);

  // "*x" (as in "int *x")
  -> D_pointer(bool isPtr,  // true for "*", false for "&"
               CVFlags cv,  // optional qualifiers applied to ptr/ref type
               IDeclarator base);

  // "f(int)"
  -> D_func(SourceLocation loc,
            IDeclarator base,                       // D_name of function, typically
            FakeList<ASTTypeId> *params,            // params with optional default values
            CVFlags cv,                             // optional "const" for member functions
            ExceptionSpec /*nullable*/ exnSpec);    // throwable exceptions

  // "a[5]" or "b[]"
  -> D_array(IDeclarator base, Expression /*nullable*/ size);

  // "c : 2"
  //
  // I use a PQName here instead of a StringRef for uniformity
  // (so every IDeclarator ends with a PQName); there are never
  // qualifiers on a bitfield name
  -> D_bitfield(SourceLocation loc, PQName /*nullable*/ name,
                Expression bits);
}

// specification of what a function can throw; if an ExceptionSpec
// pointer is NULL, it means there is no specification, i.e. anything
// can be thrown
class ExceptionSpec (
  FakeList<ASTTypeId> *types       // list of allowable types; might be empty (NULL)
) {
  public FunctionType::ExnSpec *tcheck(Env &env);
  public void twalk(Env &env);
}

// names for operator and conversion functions
class OperatorName {
  // render the operator as a string, for use with string-based maps
  pure_virtual char const *getOperatorName() const;

  // operator new & delete (see note at end about SpecialDeclarator)
  -> ON_newDel(bool isNew, bool isArray);

  // binary operator; since the declarator parser won't
  // know whether "+" and "-" are being overloaded as unary
  // or binary (since it won't count arguments or know
  // whether it's in a class context), "+" and "-" are always
  // classified as ON_binary even when in fact unary; op
  // will never be BIN_DOT_STAR nor BIN_ASSIGN
  -> ON_binary(BinaryOp op);

  // unary operator; only "!" and "~" are classified this way
  -> ON_unary(UnaryOp op);

  // ++ or --; since declarator parser doesn't know about
  // the arguments, this is always EFF_PREINC or EFF_PREDEC
  // even when in fact the "post" version is being overloaded
  -> ON_effect(EffectOp op);

  // assignment; compound if op != BIN_ASSIGN
  -> ON_assign(BinaryOp op);

  // remaining misc ops not captured above
  -> ON_overload(OverloadableOp op);


  // conversion operator to convert to 'type'; type will always have an
  // abstract declarator, with only pointer-type constructors (if any)
  -> ON_conversion(ASTTypeId type);
}


// ------------------- statements -----------------
class Statement (SourceLocation loc) {
  // represent ambiguous statements by forming a linked list of alternatives
  public Statement * const ambiguity;
  ctor const_cast<Statement*&>(ambiguity) = NULL;
  public void addAmbiguity(Statement *alt);

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  // typecheck, and return which Statement is selected from among
  // syntactically ambiguous choices
  public /*no_ignore*/ Statement *tcheck(Env &env);
  public void twalk(Env &env);

  public void mid_tcheck(Env &env, int &) { itcheck(env); };

  pure_virtual void itcheck(Env &env);
  pure_virtual void itwalk(Env &env);

  // e.g. "S_if@4:5" -- kind, line, col
  //public string kindLocString() const;

  -> S_skip();      // nop; used whenever optional Statement is not present
  -> S_label(StringRef name, Statement s);
  -> S_case(Expression expr, Statement s);
  -> S_default(Statement s);
  -> S_expr(Expression expr);       // expression evaluated for side effect
  -> S_compound(ASTList<Statement> stmts);        // using ASTList for performance, I never yield it in cc.gr
  -> S_if(Condition cond, Statement thenBranch, Statement elseBranch);
  -> S_switch(Condition cond, Statement branches);
  -> S_while(Condition cond, Statement body);
  -> S_doWhile(Statement body, Expression expr);  // note: 'expr' is not a Condition
  -> S_for(Statement init, Condition cond,
           Expression after, Statement body) {
       //public virtual void tcheck(Env &env);      // special handling of 'init'
     }
  -> S_break();
  -> S_continue();
  -> S_return(Expression /*nullable*/ expr);
  -> S_goto(StringRef target);
  -> S_decl(Declaration decl);
  -> S_try(Statement body, FakeList<Handler> *handlers);
}

// condition expression in a control-flow statement; it's allowed
// to declare a variable that will hold the condition's value for
// the duration of the substatement(s)
class Condition {
  -> CN_expr(Expression expr);      // simple expression
  -> CN_decl(ASTTypeId typeId);     // type, name, & initializer (must all be present)
  
  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);
}

// exception handler
class Handler (
  Statement body                    // code to run when handler selected
) {
  public Handler *next;  ctor next=NULL;      // FakeList link

  -> HR_type(ASTTypeId typeId);     // handles given type of exception
  -> HR_default();                  // handles any type; synactically "..."

  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);
}


// ----------------- expressions -----------------
// C expressions
class Expression {
  // FakeList link; since you have to use 'setNext', I'm making
  // 'next' const, and I'll cast it away in 'setNext'
  //
  // update: I'm tired of casting it, and I'm pretty sure there
  // aren't any stray updates at this point
  public Expression *next;
  ctor next = NULL;
  public void setNext(Expression *newNext);


  // same as we do for statements
  public Expression * const ambiguity;
  ctor const_cast<Expression*&>(ambiguity) = NULL;
  public void addAmbiguity(Expression *alternative);

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  // type check and yield the type of the expression; this type
  // gets automatically stored in the 'type' field; the return
  // value specifies which of possibly ambiguous alternatives
  // was selected for retention
  public /*no_ignore*/ Expression *tcheck(Env &env);
  public void twalk(Env &env);

  public void mid_tcheck(Env &env, int &);

  // per-type checker; return type this expression eval's to
  pure_virtual Type const *itcheck(Env &env);
  pure_virtual void itwalk(Env &env);

  // type computed for this expression; might be a SimpleType for
  // ST_ERROR, in which case a subsequent attempt to typecheck the
  // same expression should stop and look for an ambiguous alt.
  public Type const *type;
  ctor type=NULL;


  // const-eval; for now very simple; will add an error message to
  // the environment if this expression is not a constant (and also
  // return false); can only call this after tchecking
  public bool constEval(Env &env, int &result) const;


  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // unparse the expression
  //pure_virtual string toString() const;


  -> E_boolLit(bool b);
  -> E_intLit(int i);
  -> E_floatLit(float f);
  -> E_stringLit(StringRef s);    // not quite right b/c can't handle embedded nuls
  -> E_charLit(char c);
  //-> E_structLit(ASTTypeId stype, ASTList<Initializer> init);

  // variable reference; 'name' might be "this"
  -> E_variable(PQName name) {
       public Variable *var;      // (serf) binding introduction of this name
       ctor var=NULL;
     }

  -> E_funCall(Expression func, FakeList<Expression> *args);

  // call to constructor as an expression
  -> E_constructor(TypeSpecifier spec, FakeList<Expression> *args) {
       public Type const *type;   // type being constructed
       ctor type=NULL;
  }

  // field within an object; as a special case, fieldName might begin
  // with "~", meaning we're naming the destructor
  -> E_fieldAcc(Expression obj, PQName fieldName) {
       public Variable const *field;
       ctor field=NULL;
     }

  -> E_sizeof(Expression expr) {
       public int size;     // size of the type of expr
       ctor size=-1;
     }

  -> E_unary(UnaryOp op, Expression expr);
  -> E_effect(EffectOp op, Expression expr);
  -> E_binary(Expression e1, BinaryOp op, Expression e2);

  -> E_addrOf(Expression expr);
  -> E_deref(Expression ptr);

  -> E_cast(ASTTypeId ctype, Expression expr);
  -> E_cond(Expression cond, Expression th, Expression el);
  //-> E_gnuCond(Expression cond, Expression el);
  -> E_comma(Expression e1, Expression e2);
  -> E_sizeofType(ASTTypeId atype) {
       public int size;     // size of the type
       ctor size=-1;
     }

  // this is a simple assignment if op==BIN_ASSIGN, otherwise it's an
  // incremental assignment, like a += 3 (e.g. for op=BIN_PLUS)
  -> E_assign(Expression target, BinaryOp op, Expression src);

  -> E_new(bool colonColon,                      // true if "::" preceeds "new"
           FakeList<Expression> *placementArgs,  // arguments to placement-new (empty/NULL if no placement syntax)
           ASTTypeId atype,                      // type to allocate
           ExpressionListOpt ctorArgs) {         // arguments to type's constructor (NULL if no ctor call syntax)
       // if this is non-NULL, it's the number of elements to allocate via new[]
       public Expression /*nullable serf*/ *arraySize;
       ctor arraySize=NULL;
     }

  -> E_delete(bool colonColon,                   // true if "::" preceeds "delete"
              bool array,                        // true if "[]" follows "delete"
              Expression expr);                  // address of obj to deallocate

  -> E_throw(Expression /*nullable*/ expr);

  -> E_keywordCast(CastKeyword key,              // dynamic_cast, static_cast, etc.
                   ASTTypeId type,               // type to cast to
                   Expression expr);             // expression being cast

  -> E_typeidExpr(Expression expr);
  -> E_typeidType(ASTTypeId type);
}

// this is used for cases where there is a difference between a list
// with no elements, and no list at all (the latter is represented by
// a NULL pointer to an ExpressionListOpt, while the former is a valid
// ExpressionListOpt with a NULL 'list' field)
class ExpressionListOpt (
  FakeList<Expression> *list
);


// animals which appear after declarations to assign initial values
class Initializer {
  public Initializer *next;  ctor next=NULL;       // FakeList link

  // check that the initializer is well-typed, given the type of
  // the thing it initializes
  //pure_virtual void tcheck(Env &env, Type const *type);

  // simpler tcheck for now..
  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);

  // simple initializer, like "int x = 3"
  -> IN_expr(Expression e);

  // compound initializer, like "int x[4] = { 1,2,3,4 };
  // using ASTList for performance; some files have initializers
  // with thousands of elements
  -> IN_compound(ASTList<Initializer> inits);

  // constructor initializer, like "int x(3);"
  -> IN_ctor(FakeList<Expression> *args);
}

// gnu extension to attach particular elements of an initializer list
// to particular fields of the structure or array being initialized
class InitLabel {
  -> IL_element(Expression index);
  -> IL_range(Expression low, Expression high);   // inclusive
  -> IL_field(StringRef name);
  -> IL_elementField(Expression index, StringRef name);
}


// ------------------- templates -------------------
// wrap some template parameters on a declaration or function
class TemplateDeclaration (
  FakeList<TemplateParameter> *params
) {
  public void tcheck(Env &env);
  public void twalk(Env &env);

  pure_virtual void itcheck(Env &env);
  pure_virtual void itwalk(Env &env);

  // declare a template function
  -> TD_func(Function f);
  
  // declare a template class; 'type' could either be a
  // TS_elaborated (forward decl) or a TS_classSpec (definition)
  -> TD_class(TypeSpecifier type);
}

// one of the parameters to a template declaration
class TemplateParameter (SourceLocation loc) {
  public TemplateParameter *next;  ctor next=NULL;   // FakeList link

  pure_virtual void tcheck(Env &env, TemplateParams *tparams);
  pure_virtual void twalk(Env &env);

  // type parameter; when present, 'name' is what the template code
  // will use to refer to the actual argument type; when present,
  // 'defaultType' provides a default argument
  -> TP_type(StringRef /*nullable*/ name,
             ASTTypeId /*nullable*/ defaultType);

  // TODO: add non-type paramters
}


// one of the arguments to a template instantiation
class TemplateArgument {
  public TemplateArgument *next;  ctor next=NULL;   // FakeList link

  pure_virtual void tcheck(Env &env);
  pure_virtual void twalk(Env &env);

  // return a canonical string for this template argument,
  // such that different arguments get different strings
  pure_virtual string argString() const;

  // type argument, corresponds to a TP_type parameter
  -> TA_type(ASTTypeId type);

  // TODO: add non-type arguments
}


// --------------------- notes ------------------

/* 
  SpecialDeclarator:

  Why split out the various overloadable operators (c++ spec section
  A.11) into various ON_XXX classes, instead of using just one
  ON_overload?  Well, in any case, code which interprets overloaded
  operator declarators will have to map to/from the other operator
  names, so reusing those names may simplify some of that code.  Also,
  reuse means I get debug printing for free.  Finally, it's easy to
  write a simple is-overload test for SimpleDeclarator, which
  accomplishes everything that aggregating them would.
*/

