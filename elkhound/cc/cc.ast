// cc.ast            see license.txt for copyright and terms of use
// C++ abstract syntax

// note: wherever ASTList or FakeList is used, its elements are listed
// in the order they appear lexically in the input file, i.e. right to
// left and then top to bottom

// How do I decide between ASTList and FakeList?  Creating ASTLists
// can be done with left recursion, which saves stack space, whereas
// FakeLists require right recursion.  But, ASTLists cannot safely
// be yielded as semantic values if there's any chance they'll be
// yielded more than once.
//
// So, I use FakeList everywhere I can accept the stack growth.  The
// only places I cannot accept this growth are places where it is
// relatively common for the list to have >100 elements.  Those
// places are:
//   - toplevel forms (and namespace toplevels, when I add them)
//   - statement lists in compound statements
//   - class/struct members
//   - compound initializers
//
// In these places where I use ASTList, I encapsulate it in another
// class if necessary to avoid yielding it as a semantic value.

// included in generated header
verbatim {
  #include "sobjlist.h"      // SObjList
  #include "variable.h"      // Variable
  #include "cc_flags.h"      // CVFlags, DeclFlags, etc. (r)
  #include "cc_type.h"       // Type, FunctonType, CompoundType

  class Env;                 // cc_env.h
} // end verbatim

// included in generated source file
impl_verbatim {
  //#include "cc_type.h"       // Type
}


// ---------------- file -------------
// an entire file (with included stuff) of toplevel forms; I use
// an ASTList here because I want to use left recursion, and
// there's never a multiple-yield problem with toplevel forms
class TranslationUnit (ASTList<TopForm> topForms) {
  // type checker
  public void tcheck(Env &env);
}

// a toplevel form
class TopForm (SourceLocation loc) {
  pure_virtual void tcheck(Env &env);

  -> TF_decl(Declaration decl);        // includes function prototypes

  -> TF_func(Function f);              // functions with bodies
}


// ----------------------- function -------------------------
// a function definition (toplevel or class member)
class Function (
  DeclFlags dflags,             // static, extern, etc.

  TypeSpecifier retspec,        // type specifier for return value

  Declarator nameParams,        // 1. remainder of return value type
                                // 2. name of function
                                // 3. names/types of parameters

  FakeList<MemberInit> *inits,  // (for ctors only) member initialization list

  S_compound body,              // body of function

  FakeList<Handler> *handlers   // handlers for ctor "try" block
) {
  // if 'checkBody' is false, we treat this like it was just
  // a prototype for the function
  public void tcheck(Env &env, bool checkBody);

  private CompoundType *verifyIsCtor(Env &env, char const *context);
  private void tcheck_memberInits(Env &env);
  private void tcheck_handlers(Env &env);
}

class MemberInit (
  PQName name,                   // name of member or base class
  FakeList<Expression> *args     // arguments to its constructor
) {
  // standard way to make it possible to include something
  // in a FakeList; this line is repeated below in several places
  public MemberInit *next;  ctor next=NULL;     // FakeList link
}


// --------------- types and declarators ---------------
// variable declaration or definition, or function declaration
class Declaration (
  enum DeclFlags dflags,               // typedef, virtual, extern, etc.
  TypeSpecifier spec,                  // e.g. "int"
  FakeList<Declarator> *decllist       // e.g. "x=3, y"
) {
  public void tcheck(Env &env);        // adds declared variables to env
}

// just one complete type; appears in parameter decls and in casts
class ASTTypeId (
  TypeSpecifier spec,        // "int"
  Declarator decl            // this will be abstract sometimes (e.g. casts)
) {
  public ASTTypeId *next;  ctor next=NULL;     // FakeList link

  public void tcheck(Env &env);
  
  public Type const *getType() const;      // can use after calling 'tcheck'
}

// a name with optional class qualifiers (PQ: "possibly qualified");
// if the first qualifier is NULL, then it means there was a leading
// "::" symbol
class PQName {
  public bool hasQualifiers() const { return isPQ_qualifier(); };

  public string qualifierString() const;  
  public string toString() const;
  public friend stringBuilder& operator<< (stringBuilder &sb, PQName const &obj);
                                   
  // retrieve the eventual PQ_name's name
  pure_virtual StringRef getName() const;

  // final name
  -> PQ_name(StringRef name);

  // outer qualifier applied to some inner PQName
  -> PQ_qualifier(StringRef qualifier, PQName rest);
}


// a name of an "atomic" type--one to which type constructors
// (e.g. '*') can be applied, but which itself is not syntactically
// built with type constructors (typedef'd types may have been built
// with type constructors when the name was defined, but a
// TypeSpecifier refers only to the name)
class TypeSpecifier {
  public enum CVFlags cv;
  ctor { cv=CV_NONE; };

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // yield the type named by the specifier; this type may of course
  // get refined when the declarator is considered
  pure_virtual Type const *tcheck(Env &env);

  -> TS_name(PQName name);                 // a typedef'd name (typedef might be implicit, as for classes)

  -> TS_simple(SimpleTypeId id);           // int or char or float or ..

  -> TS_elaborated(                        // "class Foo"
       SourceLocation loc,
       TypeIntr keyword,
       PQName name
     );

  -> TS_classSpec(                         // "class { ... }"
       SourceLocation loc,
       TypeIntr keyword,                     // "class", "struct", "union"
       StringRef /*nullable*/ name,          // user-provided name, if any
       FakeList<BaseClassSpec> *bases,       // base classes
       MemberList members                    // field and methods of the class
     );

  -> TS_enumSpec(                          // "enum { ... }"
       StringRef /*nullable*/ name,          // name of enum, if any
       FakeList<Enumerator> *elts            // elements of the enumeration
     );
}

// base class specification
class BaseClassSpec (
  bool isVirtual,                       // true for virtual base classes
  AccessKeyword access,                 // public/protected/private
  PQName name                           // name of base class
) {
  public BaseClassSpec *next;  ctor next=NULL;     // FakeList link
}


// list of class members; this is encapsulated so I can use
// ASTList without yielding ASTLists in cc.gr
class MemberList (ASTList<Member> list);

// member of a class
class Member {
  -> MR_decl(Declaration d);            // data members or functions w/o bodies
  -> MR_func(Function f);               // function with body
  -> MR_access(AccessKeyword k);        // section header
  
  pure_virtual void tcheck(Env &env);
}

// a binding of a name to a constant value
class Enumerator (
  SourceLocation loc,                   // location
  StringRef name,                       // name of this constant
  Expression /*nullable*/ expr          // constant expr, or NULL for "next"
) {
  public Enumerator *next;  ctor next=NULL;     // FakeList link

  public Variable *var;                 // (serf) introduction record
  ctor var=NULL;
                                                          
  // we pass both the base 'enum' and the Type wrapped around it,
  // since both are needed and it's slightly expensive to compute
  // one from the other for each enumerator
  public void tcheck(Env &env, EnumType *parentEnum, Type *parentType);
}


// Syntactically, a Declarator is a thing which introduces a name of a
// declared thing, and also optionally adds type constructors to the
// base type of the specifier.  It may have an initializing
// expression, depending on the context.
class Declarator (
  IDeclarator decl,                    // syntax of type designation
  Initializer init                     // (nullable) optional data initializer
) {
  // not commented-out because something in cc_env.cc refers to it..
  public Variable *var;                // (serf) computed information: name, type, etc.
  ctor var=NULL;

  public Declarator *next;  ctor next=NULL;     // FakeList link

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // determine the type denoted by the combination of 'spec' and the
  // type constructors in this declarator, then make a Variable which
  // has that type and store it in 'var'; if this declarator refers to
  // something that is *already* declared (like a function with a 
  // prior prototype), the 'var' field will be shared among the
  // various declarations; if not, put it into the environment
  public void tcheck(Env &env, Type const *spec, DeclFlags dflags);
}


// inner declarator; things *recursively* buried inside declarators;
// cannot have initializers; the internal structure is not analyzed
// once typechecking determines what type is denoted;
// type constructors are encoded as a (possibly empty) list of pointer
// constructors, then maybe a function or array type, recursively
class IDeclarator {
  public FakeList<PtrOperator> *stars;   // pointer constructors, left to right
  ctor stars=NULL;

  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // external interface; adds 'stars' before calling 'itcheck';
  // add the type constructor represented by this IDeclarator to
  // 'spec' and then make a Variable to represent it; put the
  // variable into the environment if appropriate
  public Variable * /*owner*/ tcheck(Env &env, Type const *spec, DeclFlags dflags);

  pure_virtual Variable * /*owner*/ itcheck(Env &env, Type const *spec, DeclFlags dflags);

  // dig down and find the name being declared; may return NULL
  //pure_virtual StringRef getName() const;

  // "x" (NULL means abstract declarator or anonymous parameter);
  // this is used for ctors and dtors as well as ordinary names
  // (dtor names start with "~")
  -> D_name(SourceLocation loc,
            PQName /*nullable*/ name);

  // C++ operator declarator
  -> D_operator(SourceLocation loc,
                OperatorDeclarator o);

  // "f(int)"
  -> D_func(SourceLocation loc,
            IDeclarator base,                       // D_name of function, typically
            FakeList<ASTTypeId> *params,            // params with optional default values
            CVFlags cv,                             // optional "const" for member functions
            ExceptionSpec /*nullable*/ exnSpec);    // throwable exceptions

  // "a[5]" or "b[]"
  -> D_array(IDeclarator base, Expression /*nullable*/ size);

  // "c : 2"
  -> D_bitfield(SourceLocation loc, StringRef /*nullable*/ name, 
                Expression bits);
}

// stands for a "*" or "&" in the construction of a pointer or
// reference type
class PtrOperator (
  CVFlags cv,          // optional qualifiers applied to ptr/ref type
  bool isPtr           // true for "*", false for "&"
) {
  public PtrOperator *next;  ctor next=NULL;     // FakeList link
  public string toString() const;
}

// specification of what a function can throw; if an ExceptionSpec
// pointer is NULL, it means there is no specification, i.e. anything
// can be thrown
class ExceptionSpec (
  FakeList<ASTTypeId> *types       // list of allowable types; might be empty (NULL)
) {
  public FunctionType::ExnSpec *tcheck(Env &env);
}

// declarators for operator and conversion functions
class OperatorDeclarator {
  pure_virtual char const *getOperatorName() const;

  // operator new & delete (see note at end about SpecialDeclarator)
  -> OD_newDel(bool isNew, bool isArray);

  // binary operator; since the declarator parser won't
  // know whether "+" and "-" are being overloaded as unary
  // or binary (since it won't count arguments or know
  // whether it's in a class context), "+" and "-" are always
  // classified as OD_binary even when in fact unary; op
  // will never be BIN_DOT_STAR nor BIN_ASSIGN
  -> OD_binary(BinaryOp op);

  // unary operator; only "!" and "~" are classified this way
  -> OD_unary(UnaryOp op);

  // ++ or --; since declarator parser doesn't know about
  // the arguments, this is always EFF_PREINC or EFF_PREDEC
  // even when in fact the "post" version is being overloaded
  -> OD_effect(EffectOp op);

  // assignment; compound if op != BIN_ASSIGN
  -> OD_assign(BinaryOp op);

  // remaining misc ops not captured above
  -> OD_overload(OverloadableOp op);


  // conversion operator to convert to 'type'; type will always have an
  // abstract declarator, with only pointer-type constructors (if any)
  -> OD_conversion(ASTTypeId type);
}


// ------------------- statements -----------------
class Statement (SourceLocation loc) {
  // represent ambiguous statements by forming a linked list of alternatives
  public Statement * const ambiguity;
  ctor const_cast<Statement*&>(ambiguity) = NULL;
  public void addAmbiguity(Statement *alt);

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;   // cc_tcheck.cc
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  // typecheck, and return which Statement is selected from among
  // syntactically ambiguous choices
  public Statement *tcheck(Env &env);
  public void mid_tcheck(Env &env) { itcheck(env); };

  pure_virtual void itcheck(Env &env);

  // e.g. "S_if@4:5" -- kind, line, col
  //public string kindLocString() const;

  -> S_skip();      // nop; used whenever optional Statement is not present
  -> S_label(StringRef name, Statement s);
  -> S_case(Expression expr, Statement s);
  -> S_default(Statement s);
  -> S_expr(Expression expr);       // expression evaluated for side effect
  -> S_compound(ASTList<Statement> stmts);        // using ASTList for performance, I never yield it in cc.gr
  -> S_if(Condition cond, Statement thenBranch, Statement elseBranch);
  -> S_switch(Condition cond, Statement branches);
  -> S_while(Condition cond, Statement body);
  -> S_doWhile(Statement body, Expression expr);  // note: 'expr' is not a Condition
  -> S_for(Statement init, Condition cond,
           Expression after, Statement body) {
       //public virtual void tcheck(Env &env);      // special handling of 'init'
     }
  -> S_break();
  -> S_continue();
  -> S_return(Expression /*nullable*/ expr);
  -> S_goto(StringRef target);
  -> S_decl(Declaration decl);
  -> S_try(Statement body, FakeList<Handler> *handlers);
}

// condition expression in a control-flow statement; it's allowed
// to declare a variable that will hold the condition's value for
// the duration of the substatement(s)
class Condition {
  -> CN_expr(Expression expr);      // simple expression
  -> CN_decl(ASTTypeId typeId);     // type, name, & initializer (must all be present)
  
  pure_virtual void tcheck(Env &env);
}

// exception handler
class Handler (
  Statement body                    // code to run when handler selected
) {
  public Handler *next;  ctor next=NULL;      // FakeList link

  -> HR_type(ASTTypeId typeId);     // handles given type of exception
  -> HR_default();                  // handles any type; synactically "..."

  pure_virtual void tcheck(Env &env);
}


// ----------------- expressions -----------------
// C expressions
class Expression {
  // FakeList link; since you have to use 'setNext', I'm making
  // 'next' const, and I'll cast it away in 'setNext'
  public Expression * const next;  
  ctor const_cast<Expression*&>(next) = NULL;
  public void setNext(Expression *newNext);


  // same as we do for statements
  public Expression * const ambiguity;
  ctor const_cast<Expression*&>(ambiguity) = NULL;
  public void addAmbiguity(Expression *alternative);

  // print ambiguities
  public void printAmbiguities(ostream &os, int indent) const;   // cc_tcheck.cc
  custom preemptDebugPrint {
    if (ambiguity) {
      printAmbiguities(os, indent);
      return;     // skip the normal, unambiguous-node print code
    }
  }


  // type check and yield the type of the expression; this type
  // gets automatically stored in the 'type' field; the return
  // value specifies which of possibly ambiguous alternatives
  // was selected for retention
  public Expression *tcheck(Env &env);
  public void mid_tcheck(Env &env);

  // per-type checker; return type this expression eval's to
  pure_virtual Type const *itcheck(Env &env);

  // type computed for this expression; might be a SimpleType for
  // ST_ERROR, in which case a subsequent attempt to typecheck the
  // same expression should stop and look for an ambiguous alt.
  public Type const *type;
  ctor type=NULL;


  // const-eval; for now very simple; will add an error message to
  // the environment if this expression is not a constant (and also
  // return false); can only call this after tchecking
  public bool constEval(Env &env, int &result) const;


  public void printExtras(ostream &os, int indent) const;
  custom debugPrint { printExtras(os, indent); }

  // unparse the expression
  //pure_virtual string toString() const;


  -> E_boolLit(bool b);
  -> E_intLit(int i);
  -> E_floatLit(float f);
  -> E_stringLit(StringRef s);    // not quite right b/c can't handle embedded nuls
  -> E_charLit(char c);
  //-> E_structLit(ASTTypeId stype, ASTList<Initializer> init);

  // variable reference; 'name' might be "this"
  -> E_variable(PQName name) {
       public Variable *var;      // (serf) binding introduction of this name
       ctor var=NULL;

       public void printExtras(ostream &os, int indent) const;
       custom debugPrint { printExtras(os, indent); }
     }

  -> E_funCall(Expression func, FakeList<Expression> *args);

  // call to constructor as an expression
  -> E_constructor(TypeSpecifier type, FakeList<Expression> *args);

  // field within an object; as a special case, fieldName might begin
  // with "~", meaning we're naming the destructor
  -> E_fieldAcc(Expression obj, PQName fieldName) {
       public Variable *field;
       ctor field = NULL;
     }

  -> E_sizeof(Expression expr) {
       public int size;     // size of the type of expr
       ctor size=-1;
     }

  -> E_unary(UnaryOp op, Expression expr);
  -> E_effect(EffectOp op, Expression expr);
  -> E_binary(Expression e1, BinaryOp op, Expression e2);

  -> E_addrOf(Expression expr);
  -> E_deref(Expression ptr);

  -> E_cast(ASTTypeId ctype, Expression expr);
  -> E_cond(Expression cond, Expression th, Expression el);
  //-> E_gnuCond(Expression cond, Expression el);
  -> E_comma(Expression e1, Expression e2);
  -> E_sizeofType(ASTTypeId atype) {
       public int size;     // size of the type
       ctor size=-1;
     }

  // this is a simple assignment if op==BIN_ASSIGN, otherwise it's an
  // incremental assignment, like a += 3 (e.g. for op=BIN_PLUS)
  -> E_assign(Expression target, BinaryOp op, Expression src);

  -> E_new(bool colonColon,                      // true if "::" preceeds "new"
           FakeList<Expression> *placementArgs,  // arguments to placement-new (empty/NULL if no placement syntax)
           ASTTypeId atype,                      // type to allocate
           ExpressionListOpt ctorArgs);          // arguments to type's constructor (NULL if no ctor call syntax)

  -> E_delete(bool colonColon,                   // true if "::" preceeds "delete"
              bool array,                        // true if "[]" follows "delete"
              Expression expr);                  // address of obj to deallocate

  -> E_throw(Expression /*nullable*/ expr);

  -> E_keywordCast(CastKeyword key,              // dynamic_cast, static_cast, etc.
                   ASTTypeId type,               // type to cast to
                   Expression expr);             // expression being cast

  -> E_typeidExpr(Expression expr);
  -> E_typeidType(ASTTypeId type);
}

// this is used for cases where there is a difference between a list
// with no elements, and no list at all (the latter is represented by
// a NULL pointer to an ExpressionListOpt, while the former is a valid
// ExpressionListOpt with a NULL 'list' field)
class ExpressionListOpt (
  FakeList<Expression> *list
);


// animals which appear after declarations to assign initial values
class Initializer {
  public Initializer *next;  ctor next=NULL;       // FakeList link

  // check that the initializer is well-typed, given the type of
  // the thing it initializes
  //pure_virtual void tcheck(Env &env, Type const *type);

  -> IN_expr(Expression e);
  
  // using ASTList for performance; some files have initializers
  // with thousands of elements
  -> IN_compound(ASTList<Initializer> inits);
  
  pure_virtual void tcheck(Env &env);
}

// gnu extension to attach particular elements of an initializer list
// to particular fields of the structure or array being initialized
class InitLabel {
  -> IL_element(Expression index);
  -> IL_range(Expression low, Expression high);   // inclusive
  -> IL_field(StringRef name);
  -> IL_elementField(Expression index, StringRef name);
}


// --------------------- notes ------------------

/* 
  SpecialDeclarator:

  Why split out the various overloadable operators (c++ spec section
  A.11) into various OD_XXX classes, instead of using just one
  OD_overload?  Well, in any case, code which interprets overloaded
  operator declarators will have to map to/from the other operator
  names, so reusing those names may simplify some of that code.  Also,
  reuse means I get debug printing for free.  Finally, it's easy to
  write a simple is-overload test for SimpleDeclarator, which
  accomplishes everything that aggregating them would.
*/

