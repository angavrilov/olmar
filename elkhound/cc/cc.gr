// cc.gr            see license.txt for copyright and terms of use
// grammar for C++


// A word of warning: there are three sources of names running
// around here:
//   (1) the c++ standard's grammar's names
//   (2) my modified grammar's names
//   (3) names of AST nodes
// (1) and (2) correspond everywhere except in places where I want
// the grammar to do more parsing work than the standard's (mainly
// for declarators) and where I've chosen to fold in "opt".  The
// names in (3) are often different because later phases of analysis
// want to see different conceptual structure.  Anyway, the point is
// to be aware of which kind of name a given thing is.


// Note about destructive actions: because semantic values can be
// yielded to more than one reduction action (a phenomenon I call
// "multi-yield"), actions which modify one of their subtree semantic
// values are dangerous, because you can have actions from one
// interpretation interfering with actions from another
// interpretation.
//
// Therefore, to the extent reasonable, I avoid destructive actions.
// 
// However there are a few places where I want destructive actions
// anyway, and there are two broad strategies employed for managing
// them:                                                   
//
//   (1) Disable multi-yield for the modified subtrees.  If an action
//       modifies subtree nonterminal 'A', then in the definition of
//       'A' I say "dup(n) [ return NULL; ]" to ensure that once the
//       value is yielded once, it can't be yielded again.  Thus, if
//       in fact it *is* yielded a second time, I'll get a segfault
//       which will alert me to the design flaw in my rules.
//       (DeclSpecifier is a good example of this.)
//
//   (2) Design the actions to that multiple modifications are
//       checked for bad interactions.  In this grammar that is what
//       I do for FakeLists, where I either (a) prevent putting a
//       node at the head of two lists, or else (b) make sure that
//       the two lists are in fact the same list both times.  For
//       potentially-ambiguous nodes with FakeList links (Expression
//       and Declarator), additional measures are taken to ensure
//       the consistency of interaction with the ambiguity links.
//       (See Expression::addAmbiguity and Expression::setNext in
//       cc_ast_aux.cc.)
//
// Every place there's a destructive modification which isn't handled
// by FakeLists is marked by the phrase 'destructive action'.


// this makes it so that, by default, dup() is the identity function,
// and del() is a no-op
option useGCDefaults;

// if I don't specify a merge(), and we want to merge(),
// then abort
option defaultMergeAborts;

verbatim CCGr [

#include "strtable.h"     // StringRef (r)
#include "cc_type.h"      // type identifiers like ST_CHAR (r)
#include "lexer2.h"       // lexer2's token ids for classify()
#include "ccparse.h"      // ParseEnv
#include "trace.h"        // trace
#include "cc.ast.gen.h"   // C++ abstract syntax
#include "cc_lang.h"      // CCLang

#define D(msg) \
  trace("cc") << msg << endl

class CCGr : public UserActions, public ParseEnv {
public:    // data
  StringRef strRefAttr;         // "attr"
  CCLang &lang;

public:    // funcs
  CCGr(StringTable &table, CCLang &alang)
    : ParseEnv(table),
      strRefAttr(table.add("attr")),
      lang(alang) {}

private:
  #include "cc.gr.gen.h"

  // retained for now in case I decide to try lexer hack with C++  
  void declareClassTag(PQName const *tagName);
};

UserActions *makeUserActions(StringTable &table, CCLang &lang)
{
  return new CCGr(table, lang);
}

// when this is the last element in a parameter list, the function
// is a vararg function
ASTTypeId *ellipsisTypeId()
{
  return new ASTTypeId(new TS_simple(ST_ELLIPSIS),
                       new Declarator(new D_name(SourceLocation(), NULL /*name*/),
                                      NULL /*init*/));
}

void CCGr::declareClassTag(PQName const *tagName)
{
  // TYPE/NAME
  if (lang.tagsAreTypes) {
    D("defined new struct/class tag as type " << tagName->toString());
    addType(tagName);
  }
}

]


terminals {
  // grab list generated by lexer
  include("cc/cc.tok")

  token[int] L2_INT_LITERAL ;

  token[float*] L2_FLOAT_LITERAL {
    // yields are destructive
    dup(f) [ return new float(*f); ]
    del(f) [ delete f; ]
  }

  token[char] L2_CHAR_LITERAL ;

  token[StringRef] L2_NAME {
    // every time I pull an L2_NAME from the lexer, this code is
    // run to possibly reclassify the token kind; the semantic
    // value is passed (and ParseEnv is available as context), but
    // the same semantic value will be used

    // -- no lexer hack now --
    // I mark this, and all places the deal with resolving the
    // type-name vs variable-name ambiguity, with "TYPE/NAME"
    //classify(s) [
    //  if (isType(s)) {
    //    return L2_TYPE_NAME;
    //  }
    //  else {
    //    return L2_VARIABLE_NAME;
    //  }
    //]

    dup(n) [ return n; ]
    del(n) []
  }

  token[StringRef] L2_TYPE_NAME;
  token[StringRef] L2_VARIABLE_NAME;

  token[StringRef] L2_STRING_LITERAL ;

  precedence {
    // high precedence
    prec L2_PREFER_REDUCE;
    prec "const" "volatile" "owner" "__attribute__" "else" "[";

    right ".*" "->*";
    left "*" "/" "%";
    left "+" "-";
    left "<<" ">>";
    left "<" ">" "<=" ">=";
    left "==" "!=";
    left "&";
    left "^";
    left "|";
    left "&&";
    left "||";
    right "==>";    // ESC's user manual specifies a precedence but not an associativity for "==>"

    prec L2_PREFER_SHIFT;
    // low precedence
  }
}


nonterm[TranslationUnit*] File -> EnterScope t:TranslationUnit LeaveScope
  [ return t; ]

// scoping
nonterm EnterScope -> empty    [
  D("entering scope");
  enterScope();
  return 0;
]

nonterm LeaveScope -> empty     [
  D("exiting scope");
  leaveScope();
  return 0;
]


// ------------- identifiers -------------------
// simple string of characters
nonterm[StringRef] Identifier {
  dup(n) [ return n; ]
  del(n) []
  -> n:L2_NAME          [ return n; ]
}

// another name that comes up in a few places; it's supposed
// to refer to a type, but the typechecker will have to enforce
// that later
nonterm[StringRef] TypeName {
  -> id:Identifier      [ return id; ]
}


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document

// ------ A.3 Basic Concepts ------
nonterm[TranslationUnit*] TranslationUnit {
  dup(n) [ return NULL; ]    // prevent multi-yield

  -> empty                                [ return new TranslationUnit(NULL); ]

  // destructive action on 't'
  -> t:TranslationUnit d:Declaration      [ t->topForms.append(d); return t; ]
}

// ------ A.4 Expressions ------
nonterm[Expression*] PrimaryExpression {
  -> e:Literal
       [ return e; ]

  -> "this"
       [ return new E_variable(new PQ_name(str("this"))); ]

  -> "(" e:Expression ")"
       [ return e; ]

  -> e:IdExpression
       [ return new E_variable(e); ]

  // GNU extension
  //-> "(" s:CompoundStatement ")" ;

  // gnu extension: "constructor expression"
  // (notation for literal struct values)
  // e.g.:
  //   struct Foo { int x; int y; };
  //   struct Foo myfoo;
  //   myfoo = (struct Foo) { 4, 5 };        <-- here
  // which would assign x=4 and y=5 in 'myfoo'
  //-> "(" t:TypeId ")" i:CompoundInitializer
  //     [ return new E_structLit(t, i); ]
}

nonterm[Expression*] Literal {
  -> i:L2_INT_LITERAL    [ return new E_intLit(i); ]
  // destructive action on 'f'
  -> f:L2_FLOAT_LITERAL  [ E_floatLit *ret = new E_floatLit(*f); delete f; return ret; ]
  -> s:StringLiteral     [ return new E_stringLit(s); ]
  -> c:L2_CHAR_LITERAL   [ return new E_charLit(c); ]
  -> L2_TRUE             [ return new E_boolLit(true); ]
  -> L2_FALSE            [ return new E_boolLit(false); ]
}

// gnu: this is to handle gnu's f'd up pseduo-symbols, which
// have the annoying property that they have to concatenate
// with string literals (so I can't just, say, declare them
// to be char* and be done with it)
nonterm[StringRef] StringLiteral {
  -> s:L2_STRING_LITERAL  [ return s; ]
  //-> StringLiteral L2_STRING_LITERAL ;
  //-> StringLiteral "__FUNCTION__" ;
  //-> StringLiteral "__PRETTY_FUNCTION__" ;
}


// possibly-qualified name
nonterm[PQName*] IdExpression {
  -> id:PQualifiedId              [ return id; ]

  // a bare "::" qualifier can only appear at the start of a qualifier
  // sequence; I'm enforcing it a little bit differently than the std
  // does
  -> "::" id:PQualifiedId
       [ return new PQ_qualifier(NULL /*qualifier*/, NULL /*targs*/, id); ]
}

// names that are not qualified
nonterm[PQName*] UnqualifiedId {
  -> id:Identifier                [ return new PQ_name(id); ]
  -> id:OperatorFunctionId        [ return new PQ_operator(id, str(id->getOperatorName())); ]
  -> id:ConversionFunctionId      [ return new PQ_operator(id, str(id->getOperatorName())); ]

  // std has `"~" ClassName' here, but I've chosen to separate out
  // the places that a destructor name can occur, since it avoids
  // an ambiguity with the "~" unary operator

  -> id:TemplateId                [ return id; ]
}

// optional qualifier sequence (with no bare "::"), then an
// UnqualifiedId
nonterm[PQName*] PQualifiedId {
  -> id:UnqualifiedId
       [ return id; ]

  -> n:TypeName "::" id:PQualifiedId
       [ return new PQ_qualifier(n, NULL /*targs*/, id); ]

  -> n:TypeName "<" targs:TemplateArgumentList ">" "::" id:PQualifiedId
       [ return new PQ_qualifier(n, targs, id); ]

  // TODO: cppstd has a couple places where "template" occurs, I'm
  // leaving those out for now..
}

// variant of IdExpression which doesn't allow leading "::"; this is
// to temporarily remove the ambiguity with defining functions
// declared in the global namespace
nonterm[PQName*] IdExpression_no_colon_colon {
  -> id:PQualifiedId                  [ return id; ]
}


nonterm[Expression*] PostfixExpression {
  // ambiguous:
  //   x(y)
  // can either be a function call (x is a function)
  // or a constructor call (x is a type)
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:PrimaryExpression 
       [ return e; ]

  // array access
  -> a:PostfixExpression "[" e:Expression "]"
       [ return new E_deref(new E_binary(a, BIN_PLUS, e)); ]

  // fn call
  -> f:PostfixExpression "(" e:ExpressionListOpt ")"
       [ return new E_funCall(f, e); ]

  // function-style cast, or (equivalently) call to constructor; will
  // almost always be ambiguous with function call, so the distinction
  // will have to be delayed until typechecking
  -> spec:CtorExpressionType "(" e:ExpressionListOpt ")"
       [ return new E_constructor(spec, e); ]

  // field access
  -> p:PostfixExpression "."  n:IdExpression
       [ return new E_fieldAcc(p, n); ]

  // deref + field access
  -> p:PostfixExpression "->" n:IdExpression
       [ return new E_fieldAcc(new E_deref(p), n); ]

  -> p:PostfixExpression "++"
       [ return new E_effect(EFF_POSTINC, p); ]
  -> p:PostfixExpression "--"
       [ return new E_effect(EFF_POSTDEC, p); ]

  // explicit dtor call
  -> p:PostfixExpression "." n:PQDtorName
       [ return new E_fieldAcc(p, n); ]
  -> p:PostfixExpression "->" n:PQDtorName
       [ return new E_fieldAcc(p, n); ]

  -> k:CastKeyword "<" t:TypeId ">" "(" e:Expression ")"
       [ return new E_keywordCast(k, t, e); ]

  -> "typeid" "(" e:Expression ")"
       [ return new E_typeidExpr(e); ]
  -> "typeid" "(" t:TypeId ")"
       [ return new E_typeidType(t); ]
}
                                            
// the std calls this SimpleTypeSpecifier, but then also uses that
// name in some other roles; this is only for the name of a class or
// type, used as a constructor name
nonterm[TypeSpecifier*] CtorExpressionType {
  //-> ColonColonOpt NestedNameSpecifier "template" TemplateId;

  -> n:PQTypeName        [ return new TS_name(n); ]
  -> "char"              [ return new TS_simple(ST_CHAR); ]
  -> "wchar_t"           [ return new TS_simple(ST_WCHAR_T); ]
  -> "bool"              [ return new TS_simple(ST_BOOL); ]
  -> "short"             [ return new TS_simple(ST_SHORT_INT); ]
  -> "int"               [ return new TS_simple(ST_INT); ]
  -> "long"              [ return new TS_simple(ST_LONG_INT); ]
  -> "signed"            [ return new TS_simple(ST_INT); ]
  -> "unsigned"          [ return new TS_simple(ST_UNSIGNED_INT); ]
  -> "float"             [ return new TS_simple(ST_FLOAT); ]
  -> "double"            [ return new TS_simple(ST_DOUBLE); ]

  // std has this, but I don't think it makes sense
  //-> "void"
}

nonterm[CastKeyword] CastKeyword {
  -> "dynamic_cast"      [ return CK_DYNAMIC; ]
  -> "static_cast"       [ return CK_STATIC; ]
  -> "reinterpret_cast"  [ return CK_REINTERPRET; ]
  -> "const_cast"        [ return CK_CONST; ]
}

// here, and everywhere else that FakeList is used, I use right
// recursion to construct the list; this does mean the stack size
// is linear in the size of the list, but the benefit of not
// having to reverse the list of use ASTList (which is difficult
// to share) is worth it
nonterm[FakeList<Expression>*] ExpressionList {
  -> a:AssignmentExpression
       [ return FakeList<Expression>::makeList(a); ]
  -> a:AssignmentExpression "," e:ExpressionList
       [ a->setNext(e->first()); 
         return FakeList<Expression>::makeList(a); ]
}

nonterm[FakeList<Expression>*] ExpressionListOpt {
  -> empty               [ return FakeList<Expression>::emptyList(); ]
  -> e:ExpressionList    [ return e; ]
}

// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName
//PseudoDestructorName -> Qualifier PseudoDestructorName

nonterm[Expression*] UnaryExpression {
  // ambiguous:
  //   sizeof(x)
  // could either be size of an expression 'x', or
  // size of a type called 'x'
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:PostfixExpression         [ return e; ]

  -> "++" e:CastExpression       [ return new E_effect(EFF_PREINC, e); ]
  -> "--" e:CastExpression       [ return new E_effect(EFF_PREDEC, e); ]

  // size of expression
  -> "sizeof" e:UnaryExpression  [ return new E_sizeof(e); ]

  -> e:DeleteExpression          [ return e; ]

  // dereference, addrof
  -> "*" e:CastExpression        [ return new E_deref(e); ]
  -> "&" e:CastExpression        [ return new E_addrOf(e); ]

  // other unary operators
  -> "+" e:CastExpression        [ return new E_unary(UNY_PLUS, e); ]
  -> "-" e:CastExpression        [ return new E_unary(UNY_MINUS, e); ]
  -> "!" e:CastExpression        [ return new E_unary(UNY_NOT, e); ]
  -> "~" e:CastExpression        [ return new E_unary(UNY_BITNOT, e); ]
                                               
  // size of type
  -> "sizeof" "(" t:TypeId ")"   [ return new E_sizeofType(t); ]

  -> e:NewExpression             [ return e; ]
}


// ---------------- "new" and "delete" expressions --------------
nonterm[bool] ColonColonOpt {
  -> empty     [ return false; ]
  -> "::"      [ return true; ]
}

nonterm[E_new*] NewExpression {
  -> c:ColonColonOpt "new" p:NewPlacementOpt t:NewTypeId i:NewInitializerOpt
       [ return new E_new(c, p, t, i); ]
  -> c:ColonColonOpt "new" p:NewPlacementOpt "(" t:TypeId ")" i:NewInitializerOpt
       [ return new E_new(c, p, t, i); ]
}

nonterm[FakeList<Expression>*] NewPlacementOpt {
  -> empty                          [ return FakeList<Expression>::emptyList(); ]
  -> "(" lst:ExpressionList ")"     [ return lst; ]
}

nonterm[ASTTypeId*] NewTypeId {
  -> spec:TypeSpecifier decl:NewDeclaratorOpt
       [ return new ASTTypeId(spec, new Declarator(decl, NULL)); ]
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]"  ("[" ConstExpression "]")* )?
// where PtrOperator is
//   "*" CVQualifierSeqOpt, or
//   "&"
// though I cannot find any explanation in the spec of whether "&" is
// in fact allowed (it doesn't make sense to me) so I do not allow it
// (so I'll see the counterexample syntax if it exists)
nonterm[IDeclarator*] NewDeclaratorOpt {
  -> empty
       [ return new D_name(loc, NULL); ]

  // pointers
  -> "*" cv:CVQualifierSeqOpt d:NewDeclaratorOpt
       [ return new D_pointer(true /*isPtr*/, cv, d); ]

  // commit to at least one "[" ... "]"
  -> d:DirectNewDeclarator               [ return d; ]
}
nonterm[IDeclarator*] DirectNewDeclarator {
  -> /*abstract declarator*/ "[" sz:Expression "]"
       [ return new D_array(new D_name(loc, NULL), sz); ]
  -> d:DirectNewDeclarator "[" sz:ConstantExpression "]"
       [ return new D_array(d, sz); ]
}

nonterm[ExpressionListOpt*] NewInitializerOpt {
  -> empty                            [ return NULL; ]
  -> "(" lst:ExpressionListOpt ")"    [ return new ExpressionListOpt(lst); ]
}

nonterm[Expression*] DeleteExpression {
  -> c:ColonColonOpt "delete" e:CastExpression
       [ return new E_delete(c, false /*array*/, e); ]
  -> c:ColonColonOpt "delete" "[" "]" e:CastExpression
       [ return new E_delete(c, true /*array*/, e); ]
}
// ------------ end of "new" and "delete" expressions -------------


nonterm[Expression*] CastExpression {
  // ambiguous:
  //   (x)(y)
  // could either be a call to function 'x' with argument 'y', or
  // it could be a cast to type 'x' of the expression 'y'
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:UnaryExpression
       [ return e; ]
  -> "(" t:TypeId ")" e:CastExpression
       [ return new E_cast(t, e); ]
}

// ++++ binary operator expression ++++
// primary expressions
nonterm[Expression*] BinaryExpression {
  // ambiguous:
  //   (x) & (y)
  // could either be the bitwise AND of expressions x and y, or
  // it could be the address of expression y, cast to type x
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:CastExpression                                    [ return e; ]

  -> left:BinaryExpression ".*"  right:BinaryExpression  [ return new E_binary(left, BIN_DOT_STAR, right); ]
  -> left:BinaryExpression "->*" right:BinaryExpression  [ return new E_binary(left, BIN_ARROW_STAR, right); ]

  -> left:BinaryExpression "*"  right:BinaryExpression   [ return new E_binary(left, BIN_MULT, right); ]
  -> left:BinaryExpression "/"  right:BinaryExpression   [ return new E_binary(left, BIN_DIV, right); ]
  -> left:BinaryExpression "%"  right:BinaryExpression   [ return new E_binary(left, BIN_MOD, right); ]
  -> left:BinaryExpression "+"  right:BinaryExpression   [ return new E_binary(left, BIN_PLUS, right); ]
  -> left:BinaryExpression "-"  right:BinaryExpression   [ return new E_binary(left, BIN_MINUS, right); ]
  -> left:BinaryExpression "<<" right:BinaryExpression   [ return new E_binary(left, BIN_LSHIFT, right); ]
  -> left:BinaryExpression ">>" right:BinaryExpression   [ return new E_binary(left, BIN_RSHIFT, right); ]
  -> left:BinaryExpression "<"  right:BinaryExpression   [ return new E_binary(left, BIN_LESS, right); ]
  -> left:BinaryExpression ">"  right:BinaryExpression   [ return new E_binary(left, BIN_GREATER, right); ]
  -> left:BinaryExpression "<=" right:BinaryExpression   [ return new E_binary(left, BIN_LESSEQ, right); ]
  -> left:BinaryExpression ">=" right:BinaryExpression   [ return new E_binary(left, BIN_GREATEREQ, right); ]
  -> left:BinaryExpression "==" right:BinaryExpression   [ return new E_binary(left, BIN_EQUAL, right); ]
  -> left:BinaryExpression "!=" right:BinaryExpression   [ return new E_binary(left, BIN_NOTEQUAL, right); ]
  -> left:BinaryExpression "&"  right:BinaryExpression   [ return new E_binary(left, BIN_BITAND, right); ]
  -> left:BinaryExpression "^"  right:BinaryExpression   [ return new E_binary(left, BIN_BITXOR, right); ]
  -> left:BinaryExpression "|"  right:BinaryExpression   [ return new E_binary(left, BIN_BITOR, right); ]

  -> left:BinaryExpression "&&" right:BinaryExpression   [ return new E_binary(left, BIN_AND, right); ]
  -> left:BinaryExpression "||" right:BinaryExpression   [ return new E_binary(left, BIN_OR, right); ]
}


nonterm[Expression*] ConditionalExpression {
  -> e:BinaryExpression 
       [ return e; ]

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression 
       [ return new E_cond(cond, th, el); ]
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm[Expression*] AssignmentExpression {
  -> e:ConditionalExpression 
       [ return e; ]

  -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression
       [ return new E_assign(e1, op, e2); ]
       
  -> e:ThrowExpression
       [ return e; ]
}

nonterm[enum BinaryOp] AssignmentOperator {
  -> "*="  [ return BIN_MULT; ]
  -> "/="  [ return BIN_DIV; ]
  -> "%="  [ return BIN_MOD; ]
  -> "+="  [ return BIN_PLUS; ]
  -> "-="  [ return BIN_MINUS; ]
  -> ">>=" [ return BIN_RSHIFT; ]
  -> "<<=" [ return BIN_LSHIFT; ]
  -> "&="  [ return BIN_BITAND; ]
  -> "^="  [ return BIN_BITXOR; ]
  -> "|="  [ return BIN_BITOR; ]
  -> "="   [ return BIN_ASSIGN; ]
}


// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
// update: now that I'm doing translation too, the difference
// in the meanings is great enough that I think they should be
// separate, as they are
nonterm[Expression*] Expression {
  -> ae:AssignmentExpression 
       [ return ae; ]

  -> e:Expression "," ae:AssignmentExpression 
       [ return new E_comma(e, ae); ]
}

nonterm[Expression*] ExpressionOpt {
  // empty expression is a nop
  -> empty         [ return new E_intLit(1); ]
  -> e:Expression  [ return e; ]
}

// this is an expression with the additional requirement that
// it be entirely evaluable to an int at compile time
// (the name exists simply to help document that fact; the grammar
// cannot enforce it)
nonterm[Expression*] ConstantExpression -> e:ConditionalExpression 
  [ return e; ]


// ------ A.5 Statements ------
// labeled-statement
nonterm[Statement*] Statement {
  // ambiguous:
  //   x(y);
  // can either be an Expression statement (constructor call)
  // or a BlockDeclaration (declare variable y, of type x)
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> n:Identifier ":" s:Statement 
       [ return new S_label(loc, n, s); ]

  -> "case" e:ConstantExpression ":" s:Statement
       [ return new S_case(loc, e, s); ]

  -> "default" ":" s:Statement
       [ return new S_default(loc, s); ]

  // expression-statement
  -> s:ExpressionStatement
       [ return s; ]

  // compound-statement
  -> s:CompoundStatement
       [ return s; ]

  // selection-statement
  // (prefer to shift "else" over reducing by this rule)
  -> "if" "(" e:Condition ")" s:Statement     precedence(L2_PREFER_SHIFT)
       [ return new S_if(loc, e, s, new S_skip(loc)); ]

  // if-then-else preferred over if-then when ambiguous
  -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement
       [ return new S_if(loc, e, s1, s2); ]

  -> "switch" "(" e:Condition ")" s:Statement
       [ return new S_switch(loc, e, s); ]

  -> "while" "(" e:Condition ")" s:Statement
       [ return new S_while(loc, e, s); ]

  -> "do" s:Statement "while" "(" e:Expression ")" ";"
       [ return new S_doWhile(loc, s, e); ]

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ExpressionOpt ")" s2:Statement
       [ return new S_for(loc, s1, c, e, s2); ]

  -> "break" ";"                        [ return new S_break(loc); ]

  -> "continue" ";"                     [ return new S_continue(loc); ]

  -> "return" e:Expression ";"          [ return new S_return(loc, e); ]

  -> "return" ";"                       [ return new S_return(loc, NULL); ]

  -> "goto" n:Identifier ";"            [ return new S_goto(loc, n); ]

  // declaration-statement
  -> d:BlockDeclaration                 [ return new S_decl(loc, d); ]

  // try-block
  -> s:TryBlock                         [ return s; ]
}

nonterm[Statement*] ExpressionStatement {
  -> ";"                [ return new S_skip(loc); ]
  -> e:Expression ";"   [ return new S_expr(loc, e); ]
}

nonterm[S_compound*] CompoundStatement {
  // I must enter scope immediately upon seeing the open-brace, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> EnterScope seq:CompoundStmtSeq LeaveScope "}"
       [ return seq; ]
}

nonterm[S_compound*] CompoundStmtSeq {
  // I pushed "{" into this nonterminal so the 'loc' would reflect
  // its location, instead of the location of the first statement inside
  // (and in fact since 'empty' has no location, I wouldn't even have
  // been able to get that..)
  -> "{" empty
       [ return new S_compound(loc, NULL); ]
  -> c:CompoundStmtSeq s:Statement
       [ c->stmts.append(s); return c; ]
}

// the guard of e.g. an 'if' statement
nonterm[Condition*] Condition {
  -> e:Expression      
       [ return new CN_expr(e); ]

  // variable declaration in the condition clause
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression
       [ return new CN_decl(new ASTTypeId(spec, 
                                          new Declarator(decl, new IN_expr(e)))); ]
}

nonterm[Condition*] ConditionOpt {
  // an empty condition (e.g. in a for loop) is interpreted as true
  -> empty             [ return new CN_expr(new E_boolLit(true)); ]
  -> c:Condition       [ return c; ]
}

nonterm[Statement*] ForInitStatement {
  // ambiguous:
  //   x * y = z
  // could be an expression or a declaration
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> s:ExpressionStatement     [ return s; ]
  -> s:SimpleDeclaration       [ return new S_decl(loc, s); ]
}


// ----- A.6 Declarations ------
//nonterm[ASTList<Declaration>*] DeclarationSeqOpt {
//  -> empty
//       [ return new ASTList<Declaration>(); ]
//  -> seq:DeclarationSeqOpt d:Declaration
//       [ seq->append(d); return seq; ]
//} 

nonterm[TopForm*] Declaration {
  -> d:BlockDeclaration        [ return new TF_decl(loc, d); ]
  -> f:FunctionDefinition      [ return new TF_func(loc, f); ]
  -> t:TemplateDeclaration     [ return new TF_template(loc, t); ]
  //-> ExplicitInstantiation;
  -> s:ExplicitSpecialization  [ return new TF_template(loc, s); ]
  -> s:LinkageSpecification    [ return s; ]
  //-> NamespaceDefinition;
}

nonterm[Declaration*] BlockDeclaration {
  -> d:SimpleDeclaration     [ return d; ]
  //-> AsmDefinition;
  //-> NamespaceAliasDefinition;
  //-> UsingDeclaration;
  //-> UsingDirective;
}

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
//   (I've moved those guys into more specialized contexts)
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm[Declaration*] SimpleDeclaration {
  // destructive action on 'spec'
  //e.g.: int                x                     ;
  -> spec:DeclSpecifier list:InitDeclaratorListOpt ";"
       [ spec->decllist = list; return spec; ]

  // this is now redundant because DeclSpecifier allows "typedef"
  //-> "typedef" spec:DeclSpecifier list:TypedefDeclaratorList ";"
  //     [
  //       spec->dflags = (DeclFlags)(spec->dflags | DF_TYPEDEF);
  //       spec->decllist = list;
  //       return spec;
  //     ]

  // gnu; specifically for linux printk declaration
  //-> GNUAttribute decl:SimpleDeclaration ;
}


// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

// I return a Declaration object with an empty decllist, as a proxy
// for returning dflags and spec as a pair
nonterm[Declaration*] DeclSpecifier {
  dup(d) [ return NULL; ]    // prevent multi-yield

  -> m:DeclModifierSeq s:TypeSpecifier
       [ return new Declaration(m, s, NULL); ]

  -> s:TypeSpecifier
       [ return new Declaration(DF_NONE, s, NULL); ]
}

// at one point I was trying to make the parser enforce rules about
// which modifiers could go together and the fact that each one can't
// occur more than once, but that got to be unwieldy.. so now I allow
// any sequence, and the typechecker will have to rule out bad
// combinations (and for now no one can enforce the no-duplication
// rule..)
nonterm[enum DeclFlags] DeclModifierSeq {
  // subtle: I originally wrote this as DeclModifierSeqOpt, and that
  // nearly tripled the # of shift/reduce conflicts, because the
  // parser was forced to decide too early whether to do an epsilon
  // reduction; pushing the epsilon choice up one level (where it is
  // no longer an epsilon choice per-se) got me back to 59, which is
  // where it's been hovering.  Of course, because of GLR, this was
  // only a performance optimization.

  -> m:DeclModifier
       [ return m; ]
  -> seq:DeclModifierSeq m:DeclModifier
       [ DeclFlags ret = (DeclFlags)(seq | m);
         if (ret == seq) {
           // this will do for now
           cout << "warning: duplicate decl modifier\n";
         }
         return ret;
       ]
}

nonterm[enum DeclFlags] DeclModifier {
  -> "virtual"     [ return DF_VIRTUAL;  ]
  -> "friend"      [ return DF_FRIEND;   ]
  -> "mutable"     [ return DF_MUTABLE;  ]
  -> "auto"        [ return DF_AUTO;     ]
  -> "register"    [ return DF_REGISTER; ]
  -> "static"      [ return DF_STATIC;   ]
  -> "extern"      [ return DF_EXTERN;   ]
  -> "inline"      [ return DF_INLINE;   ]
  -> "typedef"     [ return DF_TYPEDEF;  ]

  -> "thmprv_predicate"   [ return DF_PREDICATE; ]
}


// plays role of "TypeSpecifierSeq" in std
nonterm[TypeSpecifier*] TypeSpecifier {
  // the existence of this production is part of why parsing C is hard
  -> n:PQTypeName
       [ return new TS_name(n); ]

  -> s:PrimitiveTypeSpecifier            // int
       [ return new TS_simple(s); ]

  -> s:PrimitiveCVTypeSpecifier          // unsigned const char  (not good style, IMO)
       [
         TS_simple *ret = new TS_simple((SimpleTypeId)(s & ST_BITMASK));
         ret->cv = (CVFlags)(s & CV_ALL);
         return ret;
       ]

  -> s:ElaboratedTypeSpecifier        // class foo  or  enum bar
       [ return s; ]

  -> s:ClassSpecifier                 // class { ... }
       [ return s; ]
  -> s:EnumSpecifier                  // enum { ... }
       [ return s; ]

  // the following rules create an ambiguity because they don't
  // say how to parse things like "const int const"; so assign
  // all of them precedence higher than const/volatile/attribute,
  // so we'll just prefer reducing always

  // destructive actions on 's', but since any interpretation will
  // have the same final effect of adding the cv flags to the
  // specifier, I won't disable multi-yield for TypeSpecifier
  -> q:CVQualifier s:TypeSpecifier  precedence(L2_PREFER_REDUCE)   // const int
       [ s->cv = (CVFlags)(s->cv | q); return s; ]
  -> s:TypeSpecifier q:CVQualifier  precedence(L2_PREFER_REDUCE)   // int const
       [ s->cv = (CVFlags)(s->cv | q); return s; ]
}


nonterm[TS_elaborated*] ElaboratedTypeSpecifier {
  -> k:ClassKey n:PQTypeName   [
       declareClassTag(n);
       return new TS_elaborated(loc, k, n);
     ]
  -> "enum" n:PQTypeName        [ return new TS_elaborated(loc, TI_ENUM, n); ]
}


// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here
nonterm[enum SimpleTypeId] PrimitiveTypeSpecifier {
  -> "char"                     [ return ST_CHAR; ]
  -> "unsigned" "char"          [ return ST_UNSIGNED_CHAR; ]
  -> "signed" "char"            [ return ST_SIGNED_CHAR; ]
  -> "bool"                     [ return ST_BOOL; ]
  -> "unsigned"                 [ return ST_UNSIGNED_INT; ]
  -> "unsigned" "int"           [ return ST_UNSIGNED_INT; ]
  -> "signed"                   [ return ST_INT; ]
  -> "signed" "int"             [ return ST_INT; ]
  -> "int"                      [ return ST_INT; ]
  -> "unsigned" "short" "int"   [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short"         [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "long" "int"    [ return ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long"          [ return ST_UNSIGNED_LONG_INT; ]
  -> "signed" "long" "int"      [ return ST_LONG_INT; ]
  -> "signed" "long"            [ return ST_LONG_INT; ]
  -> "long" "int"               [ return ST_LONG_INT; ]
  -> "long"                     [ return ST_LONG_INT; ]
  -> "signed" "short" "int"     [ return ST_SHORT_INT; ]
  -> "signed" "short"           [ return ST_SHORT_INT; ]
  -> "short" "int"              [ return ST_SHORT_INT; ]
  -> "short"                    [ return ST_SHORT_INT; ]
  -> "wchar_t"                  [ return ST_WCHAR_T; ]
  -> "float"                    [ return ST_FLOAT; ]
  -> "double"                   [ return ST_DOUBLE; ]
  -> "long" "double"            [ return ST_LONG_DOUBLE; ]
  -> "void"                     [ return ST_VOID; ]
  
  // GNU extensions
  -> "signed" "long" "long"     [ return ST_LONG_LONG; ]
  -> "long" "long"              [ return ST_LONG_LONG; ]
  -> "unsigned" "long" "long"   [ return ST_UNSIGNED_LONG_LONG; ]

  -> "signed" "long" "long" "int"    [ return ST_LONG_LONG; ]
  -> "long" "long" "int"             [ return ST_LONG_LONG; ]
  -> "unsigned" "long" "long" "int"  [ return ST_UNSIGNED_LONG_LONG; ]
}


// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm[PQName*] PQTypeName {
  -> n:PQTypeName_ncc              
       [ return n; ]
  -> "::" n:PQTypeName_ncc
       [ return new PQ_qualifier(NULL /*qualifier*/, NULL /*targs*/, n); ]
}

// no-colon-colon
nonterm[PQName*] PQTypeName_ncc {
  -> n:TypeName                    
       [ return new PQ_name(n); ]
  -> id:TemplateId
       [ return id; ]

  -> q:TypeName "::" n:PQTypeName_ncc
       [ return new PQ_qualifier(q, NULL /*targs*/, n); ]
  -> q:TypeName "<" targs:TemplateArgumentList ">" "::" n:PQTypeName_ncc
       [ return new PQ_qualifier(q, targs, n); ]
}


// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll probably merge them at some point
//
// I return an 'int' here because it's an OR of CVFlags and SimpleTypeId
nonterm[int] PrimitiveCVTypeSpecifier {
  -> "unsigned" q:CVQualifierSeq "char"         [ return q | ST_UNSIGNED_CHAR; ]
  -> "signed" q:CVQualifierSeq "char"           [ return q | ST_SIGNED_CHAR; ]
  -> "unsigned" q:CVQualifierSeq "int"          [ return q | ST_UNSIGNED_INT; ]
  -> "signed" q:CVQualifierSeq "int"            [ return q | ST_INT; ]
  -> "unsigned" q:CVQualifierSeq "short" "int"  [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short" q:CVQualifierSeq "int"  [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "short"        [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "long" "int"   [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long" q:CVQualifierSeq "int"   [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" q:CVQualifierSeq "long"         [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "int"     [ return q | ST_LONG_INT; ]
  -> "signed" "long" q:CVQualifierSeq "int"     [ return q | ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long"           [ return q | ST_LONG_INT; ]
  -> "long" q:CVQualifierSeq "int"              [ return q | ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "long"    [ return q | ST_LONG_LONG; ]
  -> "unsigned" q:CVQualifierSeq "long" "long"  [ return q | ST_UNSIGNED_LONG_LONG; ]
  -> "signed" q:CVQualifierSeq "short" "int"    [ return q | ST_SHORT_INT; ]
  -> "signed" "short" q:CVQualifierSeq "int"    [ return q | ST_SHORT_INT; ]
  -> "signed" q:CVQualifierSeq "short"          [ return q | ST_SHORT_INT; ]
  -> "short" q:CVQualifierSeq "int"             [ return q | ST_SHORT_INT; ]
  -> "long" q:CVQualifierSeq "double"           [ return q | ST_LONG_DOUBLE; ]
}


nonterm[TS_enumSpec*] EnumSpecifier {
  -> "enum" "{" list:EnumeratorListOpt "}"
       [ return new TS_enumSpec(loc, NULL /*name*/, list); ]
  -> "enum" n:Identifier "{" list:EnumeratorListOpt "}"
       [ return new TS_enumSpec(loc, n, list); ]
}


// rewrote this definition so I can always tell with one token of
// lookahead whether this is the last enumerator definition; this
// allows an optional comma at the end, on purpose
nonterm[FakeList<Enumerator>*] EnumeratorListOpt {
  -> empty
       [ return FakeList<Enumerator>::emptyList(); ]
  -> def:EnumeratorDefinition
       [ return FakeList<Enumerator>::makeList(def); ]
  -> def:EnumeratorDefinition "," list:EnumeratorListOpt
       [ return list->prepend(def); ]
}


nonterm[Enumerator*] EnumeratorDefinition {
  -> name:Identifier
       [ return new Enumerator(loc, name, NULL /*expr*/); ]
  -> name:Identifier "=" expr:ConstantExpression
       [ return new Enumerator(loc, name, expr); ]
}


nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

nonterm[TF_linkage*] LinkageSpecification {
  -> "extern" n:L2_STRING_LITERAL "{" tu:TranslationUnit "}"
       [ return new TF_linkage(loc, n, tu); ]

  -> "extern" n:L2_STRING_LITERAL tf:Declaration
       [ return new TF_linkage(loc, n, new TranslationUnit(new ASTList<TopForm>(tf))); ]
}

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm[FakeList<Declarator>*] InitDeclaratorList {
  -> d:InitDeclarator
       [ return FakeList<Declarator>::makeList(d); ]
  -> d:InitDeclarator "," list:InitDeclaratorList
       [ d->setNext(list->first());
         return FakeList<Declarator>::makeList(d); ]
}

nonterm[FakeList<Declarator>*] InitDeclaratorListOpt {
  -> empty
       [ return FakeList<Declarator>::emptyList(); ]
  -> list:InitDeclaratorList
       [ return list; ]
}


nonterm[Declarator*] InitDeclarator {
  // ambiguous:
  //   int f(x *y);
  // could be declaring a variable called "f" with ctor-initializer "(x*y)",
  // or it could be declaring a function called "f" which accepts a pointer
  // to an 'x' as a parameter
  //
  // another example:
  //   int m(int (n));
  // could be declaring a variable called "m" with ctor-initializer "int (n)"
  // which itself is a call to the constructor for "int", or it could be
  // declaring a function called "m" with an integer parameter called "n",
  // the latter surrounded by a redundant set of parens
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> d:Declarator                       // (int)  x
       [ return new Declarator(d, NULL); ]

  -> d:Declarator i:Initializer         // (int)  x = 5
       [ return new Declarator(d, i); ]
}

nonterm[Initializer*] Initializer {
  -> "=" i:InitializerClause
       [ return i; ]

  -> "(" args:ExpressionList ")"
       [ return new IN_ctor(args); ]
       
  // NOTE: there is no alternative for "(" ")"!  
  // see [cppstd. sec. 8.5 para 8]
}

nonterm[Initializer*] InitializerClause {
  -> e:AssignmentExpression              // scalar
       [ return new IN_expr(e); ]
  -> c:CompoundInitializer               // array/structure initializer
       [ return c; ]
}

nonterm[IN_compound*] CompoundInitializer {
  // array/structure initializer
  -> "{" list:InitializerList CommaOpt "}"  [ return list; ]

  // zero whatever it is
  -> "{" "}"  [ return new IN_compound(NULL); ]
}

// useful syntactic quirk
nonterm CommaOpt {
  -> empty ;
  -> "," ;
}

nonterm[IN_compound*] InitializerList {
  dup(i) [ return NULL; ]     // prevent multi-yield

  -> init:InitializerClause
       [ IN_compound *list = new IN_compound(NULL);
         list->inits.append(init); 
         return list; ]
         
  // destructive action on 'list'
  -> list:InitializerList "," init:InitializerClause
       [ list->inits.append(init); return list; ]
}


// perhaps confusing name correspondence:
//   The AST name "Declarator" corresponds to the grammar name
//   "InitDeclarator"; the AST name "IDeclarator" (inner declarator)
//   corresponds to the grammar name "Declarator"
// this name shift simply reflects the different interests of the
// parser vs. subsequent phases of analysis
//
// regex for this nonterm: (PtrOperator)* DirectDeclarator
nonterm[IDeclarator*] Declarator {
  -> "*" cv:CVQualifierSeqOpt d:Declarator
       [ return new D_pointer(true /*isPtr*/, cv, d); ]
  -> "&" d:Declarator
       [ return new D_pointer(false /*isPtr*/, CV_NONE, d); ]

  -> d:DirectDeclarator
       [ return d; ]
}

nonterm[IDeclarator*] DirectDeclarator {
  // it doesn't matter how this was classified before, because a
  // declarator binds a new name, so it shadows any prior definitions;
  // note: this rule handles constructor names!
  // note: this also handles operator names!
  -> n:IdExpression_no_colon_colon
       [ return new D_name(loc, n); ]

  // dtor
  -> n:PQDtorName
       [ return new D_name(loc, n); ]

  // function declarator; the return type comes from the type
  // specifier that preceeds this
  -> d:DirectDeclarator                        // name of function
     "(" params:ParameterDeclarationClause ")" // parameters
     cv:CVQualifierSeqOpt                      // optional "const"
     e:ExceptionSpecificationOpt               // optional "throw" clause
       [ return new D_func(loc, d, params, cv, e); ]

  // array with optional size
  -> d:DirectDeclarator "[" sz:ConstantExpressionOpt "]"
       [ return new D_array(d, sz); ]

  // precedence grouping
  -> "(" d:Declarator ")"
       [ return d; ]
}

// I choose to encode ctor and dtor names as ordinary PQNames, because
// the parser can't tell them apart from other PQNames; but the dtor
// must be handled specially because if I just allowed "~" before any
// name, then I couldn't tell if the expression "~a" is unary "~" or
// the name of a destructor.  Destructor names are encoded by prepending
// a "~" to them, so later phases of analysis will have to look for that.
// (I notice the standard calls this PseudoDestructorName; I'll stick with
// my terminology.)
nonterm[PQName*] PQDtorName {
  -> "~" n:TypeName              
       [ return new PQ_name(str(stringc << "~" << n)); ]

  // as above for PQName_no_colon_colon, I'm temporarily removing an
  // ambiguity that relates to namespaces (e.g. "::F::~F()")
  //-> q:Qualifier rhs:PQDtorName  [ return new PQ_qualifier(q, rhs); ]
  -> q:TypeName "::" rhs:PQDtorName
       [ return new PQ_qualifier(q, NULL /*targs*/, rhs); ]

  -> q:TypeName "<" targs:TemplateArgumentList ">" "::" rhs:PQDtorName
       [ return new PQ_qualifier(q, targs, rhs); ]

  //-> ColonColonOpt NestedNameSpecifier "template" TemplateId "::" "~" TypeName;
}

nonterm[Expression*] ConstantExpressionOpt {
  -> empty                 [ return NULL; ]
  -> e:ConstantExpression  [ return e; ]
}


// I'll leave this here because it's harmless and the cppstd has it;
// also, it reminds me that every place I've substituted PtrOperator
// into the syntaxes elsewhere has an implicit TODO for the
// pointer-to-member syntax
nonterm PtrOperator {
  -> "*" q:CVQualifierSeqOpt ;
  -> "&"                     ;

  // TODO: pointer to member
  //-> ColonColonOpt NestedNameSpecifier "*" CvQualifierSeqOpt;
}


nonterm[enum CVFlags] CVQualifierSeqOpt {
  -> empty                       [ return CV_NONE; ]
  -> s:CVQualifierSeq            [ return s; ]
}

nonterm[enum CVFlags] CVQualifierSeq {
  -> q:CVQualifier                       [ return q; ]
  -> q:CVQualifier s:CVQualifierSeq      [ return (CVFlags)(q | s); ]
}

nonterm[enum CVFlags] CVQualifier {
  -> "const"        [ return CV_CONST; ]
  -> "volatile"     [ return CV_VOLATILE; ]
  -> "owner"        [ return CV_OWNER; ]
}


// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
nonterm[ASTTypeId*] TypeId {
  -> spec:TypeSpecifier decl:AbstractDeclaratorOpt
       [ return new ASTTypeId(spec, new Declarator(decl, NULL)); ]

  // gnu extension
  //-> "__typeof__" "(" e:Expression ")" ;
}

nonterm[IDeclarator*] AbstractDeclaratorOpt {
  -> empty                 [ return new D_name(loc, NULL); ]
  -> d:AbstractDeclarator  [ return d; ]
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm[IDeclarator*] AbstractDeclarator {
  -> "*" cv:CVQualifierSeqOpt d:AbstractDeclaratorOpt
       [ return new D_pointer(true /*isPtr*/, cv, d); ]
  -> "&" d:AbstractDeclaratorOpt
       [ return new D_pointer(false /*isPtr*/, CV_NONE, d); ]

  -> d:DirectAbstractDeclarator
       [ return d; ]
}

nonterm[IDeclarator*] DirectAbstractDeclaratorOpt {
  -> empty                       [ return new D_name(loc, NULL /*name*/); ]
  -> d:DirectAbstractDeclarator  [ return d; ]
}

// this also must have some ground syntax
nonterm[IDeclarator*] DirectAbstractDeclarator {
  // note: the "opt" in the DirectAbstractDeclarator part of the
  // function type constructor creates an ambiguity:
  //   typedef int x;
  //   int foo(int (x));
  // Is the parameter an int, or a function accepting an 'x'?
  //
  // This is addressed by cppstd 8.2 para 7; the rule given is
  // a little vague, but I believe it's equivalent to always
  // preferring D_func over D_name.  So in the above example,
  // foo's parameter is a function.
  //
  // This ambiguity doesn't show up until ParameterDeclaration, below.

  // function
  -> d:DirectAbstractDeclaratorOpt
     "(" args:ParameterDeclarationClause ")"
     cv:CVQualifierSeqOpt
     e:ExceptionSpecificationOpt
       [ return new D_func(loc, d, args, cv, e); ]

  // array with optional size
  -> d:DirectAbstractDeclaratorOpt "[" sz:ConstantExpressionOpt "]"
       [ return new D_array(d, sz); ]

  // precedence grouping
  -> "(" d:AbstractDeclarator ")"
       [ return d; ]
}


nonterm[FakeList<ASTTypeId>*] ParameterDeclarationClause {
  -> p:ParameterDeclarationList              // some args
       [ return p; ]
  -> empty                                   // no args
       [ return FakeList<ASTTypeId>::emptyList(); ]
}

// little bending over backwards here to accomodate FakeList
nonterm[FakeList<ASTTypeId>*] ParameterDeclarationList {
  // last (and perhaps only) arg is "..."
  -> "..."
       [ return FakeList<ASTTypeId>::makeList(ellipsisTypeId()); ]

  // last arg is "...", and 2nd-to-last is not separated by
  // a comma from the "..."
  -> d:ParameterDeclaration "..."
       [ FakeList<ASTTypeId> *list =
           FakeList<ASTTypeId>::makeList(ellipsisTypeId());
         d->setNext(list->first());
         return FakeList<ASTTypeId>::makeList(d); ]

  // last arg is not "..."
  -> d:ParameterDeclaration
       [ return FakeList<ASTTypeId>::makeList(d); ]

  // argument then "," then arg or "..." or list
  -> d:ParameterDeclaration "," list:ParameterDeclarationList
       [ d->setNext(list->first());
         return FakeList<ASTTypeId>::makeList(d); ]
}

nonterm[ASTTypeId*] ParameterDeclaration {
  // ambiguity:
  //   int (x)
  // is either type "int" with Declarator "(x)", or 
  // it could be type "int (f)(x q)" such that "(x)" is an
  // AbstractDeclaratorOpt
  //
  // I think the right choice is to prefer the function type,
  // which I should be able to take care of by digging down into
  // the 'd' sval and find its type.

  //    merge(L,R) [
  //      if (L->decl->decl->isD_func() &&
  //          R->decl->decl->isD_name()) {
  //        return L;    // prefer D_func
  //      }
  //      else if (R->decl->decl->isD_func() &&
  //               L->decl->decl->isD_name()) {
  //        return R;    // prefer D_func
  //      }
  //      else {
  //        xfailure("unknown ParameterDeclaration ambiguity");
  //        return L;    // silence warning
  //      }
  //    ]

  //    // ensure yield-then-merge won't happen by nullifiying the
  //    // sval, so that merge will segfault
  //    dup(n) [ return NULL; ]
  
  // oops.. turns out yield-then-merge *does* happen (as detected
  // by the above), so we've got to represent the ambiguity
  merge(L,R) [ L->addAmbiguity(R); return L; ]


  -> RegisterOpt s:TypeSpecifier d:Declarator
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> RegisterOpt s:TypeSpecifier d:Declarator "=" e:AssignmentExpression
       [ return new ASTTypeId(s, new Declarator(d, new IN_expr(e))); ]

  -> RegisterOpt s:TypeSpecifier d:AbstractDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> RegisterOpt s:TypeSpecifier d:AbstractDeclarator "=" e:AssignmentExpression
       [ return new ASTTypeId(s, new Declarator(d, new IN_expr(e))); ]
}

// old code uses the keyword "register" in the parameter declarations, but I
// will ignore it when that happens (because my AST has no place to put it)
nonterm RegisterOpt {
  -> empty;
  -> "register";
}


// -- function definition --
nonterm[Function*] FunctionDefinition {
  // whereas the std merges c/dtors and ordinary functions by making
  // the DeclSpecifier optional, I split cases; this way in the common
  // case where I can clearly see a return type, ctor is ruled out;
  // in fact I wonder if there will ever be an ambiguity, since ordinary
  // functions always have at least two words before "(" while ctors
  // always have just one..

  // ambiguous:
  //   F::G() {}
  // can either be a definition of F's constructor (then G equals F), or
  // it can be a definition of a function G in the global scope, with
  // return value F
  //
  // for now I've removed this ambiguity by not allowing declarator
  // D_names to have the "::" qualifier (but E_variables still can),
  // but I'll have to reintroduce it to handle namespaces
  merge(L,R) [ xfailure("attempt to merge function defns"); return L; ]


  // destructive action on 'r'

  // ordinary function:
  // return type      name/params   body
  -> r:DeclSpecifier  d:Declarator  b:FunctionBody
       [
         Function *ret = new Function(
           r->dflags,                // decl flags (static, extern, etc.)
           r->spec,                  // type specifier for return value
           new Declarator(d, NULL),  // declarator with fn name, params
           NULL,                     // ctor member inits
           b,                        // function body statement
           NULL                      // exception handlers
         );
         r->spec = NULL;    // stole it above (ownership transfer)
         delete r;          // was just a carrier of dflags/spec
         return ret;
       ]

  // constructor, destructor or conversion operator
  // "explicit"?      name/params   member inits          body
  -> m:CDtorModifier  d:Declarator  c:CtorInitializerOpt  b:FunctionBody
       [
         return new Function(
           m,                        // decl flags: explicit, virtual, or none
           new TS_simple(ST_CDTOR),  // type specifier: ctor or dtor
           new Declarator(d, NULL),  // declarator with fn name, params
           c,                        // ctor member inits
           b,                        // function body statement
           NULL                      // exception handlers
         );
       ]

  // ctor with a try block
  // "explicit"?   name/params        member inits         body           handlers
  -> e:ExplicitOpt d:Declarator "try" c:CtorInitializerOpt b:FunctionBody h:HandlerSeq
       [
         return new Function(
           e,                        // decl flags: explicit is only possibility
           new TS_simple(ST_CDTOR),  // type specifier: ctor or dtor
           new Declarator(d, NULL),  // declarator with fn name, params
           c,                        // ctor member inits
           b,                        // function body statement
           h                         // exception handlers
         );
       ]
}

nonterm[S_compound*] FunctionBody -> s:CompoundStatement
  [ return s; ]

// it turns out "inline" also can appear here, at least according
// to my streambuf.h
nonterm[DeclFlags] ExplicitOpt {
  -> "explicit" e:ExplicitOpt   [ return (DeclFlags)(e | DF_EXPLICIT); ]
  -> "inline" e:ExplicitOpt     [ return (DeclFlags)(e | DF_INLINE); ]
  -> empty                      [ return DF_NONE; ]
}

nonterm[FakeList<MemberInit>*] CtorInitializerOpt {
  -> empty                        [ return FakeList<MemberInit>::emptyList(); ]
  -> ":" list:MemInitializerList  [ return list; ]
}


// ------ A.8 Classes ------
nonterm[TS_classSpec*] ClassSpecifier {
  -> k:ClassKey n:ClassHeadNameOpt b:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}"
       [ return new TS_classSpec(loc, k, n, b, memb); ]
}

// this is the name portion of what the standard calls "ClassHead"
nonterm[PQName*] ClassHeadNameOpt {
  -> empty               [ return NULL; ]
  -> n:ClassHeadName     [ return n; ]
}

// a possibly-qualified Identifier or TemplateId
nonterm[PQName*] ClassHeadName {
  -> n:Identifier        [ return new PQ_name(n); ]
  -> t:TemplateId        [ return t; ]

  -> n:TypeName "::" rest:ClassHeadName
       [ return new PQ_qualifier(n, NULL /*targs*/, rest); ]
  -> n:TypeName "<" targs:TemplateArgumentList ">" "::" rest:ClassHeadName
       [ return new PQ_qualifier(n, targs, rest); ]
       
  // TODO: as in PQualifiedId, I'm omitting the keyword "template"
}

nonterm[enum TypeIntr] ClassKey {
  -> "class"       [ return TI_CLASS; ]
  -> "struct"      [ return TI_STRUCT; ]
  -> "union"       [ return TI_UNION; ]
}


// I'm using an encapsulated ASTList to avoid right recursion,
// since there are often many members of classes
nonterm[MemberList*] MemberDeclarationSeqOpt {
  dup(m) [ return NULL; ]       // prevent multi-yield

  -> empty
       [ return new MemberList(NULL); ]

  // destructive actions on 'list'
  -> list:MemberDeclarationSeqOpt decl:MemberDeclaration
       [ list->list.append(decl); return list; ]

  // explicitly include access specifiers in the AST, instead of
  // propagating them in the parser, to avoid the complexities of
  // maintaining the state in the parser context
  -> list:MemberDeclarationSeqOpt k:AccessSpecifier ":"
       [ list->list.append(new MR_access(k)); return list; ]
}

nonterm[AccessKeyword] AccessSpecifier {
  -> "public"     [ return AK_PUBLIC; ]
  -> "private"    [ return AK_PRIVATE; ]
  -> "protected"  [ return AK_PROTECTED; ]
}

nonterm SemicolonOpt {
  -> empty ;
  -> ";" ; 
}

nonterm[Member*] MemberDeclaration {
  keep(m) [ return m!=NULL; ]

  // destructive action on 'spec'
  // member fn decl, or data member
  -> spec:DeclSpecifier list:MemberDeclaratorList ";"
       [ spec->decllist = list;
         return new MR_decl(spec); ]

  // inner class or enum with no instance defined
  -> spec:DeclSpecifier ";"
       [ // if the type specifier doesn't start with 'class'
         // or 'enum' then this is useless, and might be
         // ambiguous with superclass member publication, so
         // cancel it
         if (spec->spec->isTS_elaborated() ||
             spec->spec->isTS_classSpec() ||
             spec->spec->isTS_enumSpec()) {
           // ok
           return new MR_decl(spec);
         }
         else {
           trace("cancel") << loc 
             << ": bare DeclSpecifier not starting with type keyword\n";
           return NULL;
         }
       ]

  // publishing a superclass member; ambiguous with inner class
  // declaration (above) and ctor declaration (below), hence the
  // need for cancellation in both of those two
  -> n:PQualifiedId ";"                              
       [ return new MR_publish(n); ]

  // inline function definition; includes c/dtor definitions
  -> f:FunctionDefinition SemicolonOpt
       [ return new MR_func(f); ]

  // declaration (with no definition) of a c/dtor or conversion
  // operator function
  // Q: what about pure virtual?
  // A: it's part of the MemberDeclarator
  -> flags:CDtorModifier d:MemberDeclarator ";"
       [ // 'd' is a Declarator

         //cout << "------ MemberDeclarator ----\n";
         //d->debugPrint(cout, 0);

         // does the declarator construct a function type?
         // if not, this might be ambiguous (superclass
         // member publication), so cancel the entire reduction
         if (!d->decl->isD_func()) {
           trace("cancel") << loc << ": non-function c/dtor\n";
           return NULL;
         }

         return new MR_decl(
           new Declaration(
             flags,
             new TS_simple(ST_CDTOR),
             FakeList<Declarator>::makeList(d)
           )
         );
       ]

  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

nonterm[FakeList<Declarator>*] MemberDeclaratorList {
  -> d:MemberDeclarator
       [ return FakeList<Declarator>::makeList(d); ]
  -> d:MemberDeclarator "," list:MemberDeclaratorList
       [ d->setNext(list->first());
         return FakeList<Declarator>::makeList(d); ]
}

// this returns a full Declarator, instead of an IDeclarator, because
// the grammar doesn't nest MemberDeclarators, and because that way I
// have a place to return the "=0" of a pure virtual function, and also
// a place to put member initializers
nonterm[Declarator*] MemberDeclarator {
  -> d:Declarator
       [ return new Declarator(d, NULL /*init*/); ]

  // here I merge two cases (PureSpecifier and ConstantInitializer) that
  // the std splits; given that the parser doesn't track at this level
  // whether 'd' is a function type or not, and it can't tell the
  // difference between PureSpecifier and ConstantInitializer just by
  // looking at their syntax, we'd be disambiguating this later anyway
  -> d:Declarator "=" e:ConstantExpression     // pure, and member inits
       [ return new Declarator(d, new IN_expr(e)); ]

  -> n:IdentifierOpt ":" e:ConstantExpression     // bitfield
       [ return new Declarator(new D_bitfield(loc, n? new PQ_name(n) : NULL, e),
                               NULL /*init*/); ]
}

nonterm[StringRef] IdentifierOpt {
  -> empty         [ return NULL; ]
  -> n:Identifier  [ return n; ]
}

// modifier flags allowed in front of constructors ("explicit"),
// destructors ("virtual") and conversion functions (none); plus,
// "inline" is allowed with any of them..
nonterm[DeclFlags] CDtorModifier {
  -> empty                         [ return DF_NONE; ]
  -> m:CDtorModifier "explicit"    [ return (DeclFlags)(m | DF_EXPLICIT); ]
  -> m:CDtorModifier "virtual"     [ return (DeclFlags)(m | DF_VIRTUAL); ]
  -> m:CDtorModifier "inline"      [ return (DeclFlags)(m | DF_INLINE); ]
}


// ------ A.9 Derived classes ------
nonterm[FakeList<BaseClassSpec>*] BaseClauseOpt {
  -> empty                      [ return FakeList<BaseClassSpec>::emptyList(); ]
  -> ":" b:BaseSpecifierList    [ return b; ]
}

nonterm[FakeList<BaseClassSpec>*] BaseSpecifierList {
  -> b:BaseSpecifier
       [ return FakeList<BaseClassSpec>::makeList(b); ]
  -> b:BaseSpecifier "," list:BaseSpecifierList
       [ return list->prepend(b); ]
}


// TODO: spec allows leading "::" on the PQClassName
nonterm[BaseClassSpec*] BaseSpecifier {
  -> n:PQClassName
       [ return new BaseClassSpec(false /*virtual*/, AK_UNSPECIFIED, n); ]
  -> "virtual" a:AccessSpecifierOpt n:PQClassName
       [ return new BaseClassSpec(true /*virtual*/, a, n); ]
  -> a:AccessSpecifier v:VirtualOpt n:PQClassName
       [ return new BaseClassSpec(v, a, n); ]
}

nonterm[bool] VirtualOpt {
  -> empty      [ return false; ]
  -> "virtual"  [ return true; ]
}

// if the access specifier is missing, then it defaults to private
// when inherited by a class, and public when inherited by a struct;
// typechecking will replace AK_UNSPECIFIED with the right thing later
nonterm[AccessKeyword] AccessSpecifierOpt {
  -> empty              [ return AK_UNSPECIFIED; ]
  -> k:AccessSpecifier  [ return k; ]
}

nonterm[PQName*] PQClassName {
  -> n:PQTypeName                 [ return n; ]
}


// ------ A.10 Special member functions ------
nonterm[OperatorName*] ConversionFunctionId {
  -> "operator" t:ConversionTypeId  [ return new ON_conversion(t); ]
}

nonterm[ASTTypeId*] ConversionTypeId {
  -> s:TypeSpecifier d:ConversionDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
}

// collects the stars that might follow a type specifier in a
// conversion function (for converting to pointer type)
nonterm[IDeclarator*] ConversionDeclaratorOpt {
  -> empty                                    
       [ return new D_name(loc, NULL /*name*/); ]
       
  -> "*" cv:CVQualifierSeqOpt d:ConversionDeclaratorOpt
       [ return new D_pointer(true /*isPtr*/, cv, d); ]
  -> "&" d:ConversionDeclaratorOpt
       [ return new D_pointer(false /*isPtr*/, CV_NONE, d); ]
}


nonterm[FakeList<MemberInit>*] MemInitializerList {
  -> i:MemInitializer
       [ return FakeList<MemberInit>::makeList(i); ]
  -> i:MemInitializer "," list:MemInitializerList
       [ return list->prepend(i); ]
}

nonterm[MemberInit*] MemInitializer {
  -> n:MemInitializerId "(" e:ExpressionListOpt ")"
       [ return new MemberInit(n, e); ]
}

// the std splits cases on whether we're calling a base class ctor
// or initializing a field; I'll simply call both a PQName, and
// then in typechecking make sure that the latter case does not
// have any qualifiers (because in most cases the parser can't make
// the distinction so it would fall through to typechecking anyway)
nonterm[PQName*] MemInitializerId {
  // data member or base class
  -> id:Identifier
       [ return new PQ_name(id); ]
       
  // base class which is a template
  -> n:TypeName "<" targs:TemplateArgumentList ">"
       [ return new PQ_template(n, targs); ]

  -> n:TypeName "::" id:MemInitializerId   
       [ return new PQ_qualifier(n, NULL /*targs*/, id); ]
  -> n:TypeName "<" targs:TemplateArgumentList ">" "::" id:MemInitializerId
       [ return new PQ_qualifier(n, targs, id); ]
}


// ------ A.11 Overloading ------
nonterm[OperatorName*] OperatorFunctionId {
  -> "operator" od:Operator  [ return od; ]
}

// this nonterm is only used in the OperatorFunctionId context,
// so go ahead and have it return a full OperatorName
nonterm[OperatorName*] Operator {
  // ambiguity:
  //   void operator delete [] () ;
  // could be operator "delete[]", or
  // it could be an array of operator "delete"
  //
  // to resolve this I'll specify that the parser should always
  // prefer to shift when it has seen "new" or "delete" and the
  // lookahead token is "["

  -> "new"                    precedence(L2_PREFER_SHIFT)
       [ return new ON_newDel(true /*isNew*/, false /*isArray*/); ]
  -> "delete"                 precedence(L2_PREFER_SHIFT)
       [ return new ON_newDel(false, false); ]
  -> "new" "[" "]"
       [ return new ON_newDel(true, true); ]
  -> "delete" "[" "]"
       [ return new ON_newDel(false, true); ]

  -> "*"  [ return new ON_binary(BIN_MULT); ]
  -> "/"  [ return new ON_binary(BIN_DIV); ]
  -> "%"  [ return new ON_binary(BIN_MOD); ]
  -> "+"  [ return new ON_binary(BIN_PLUS); ]
  -> "-"  [ return new ON_binary(BIN_MINUS); ]
  -> "<<" [ return new ON_binary(BIN_LSHIFT); ]
  -> ">>" [ return new ON_binary(BIN_RSHIFT); ]
  -> "<"  [ return new ON_binary(BIN_LESS); ]
  -> ">"  [ return new ON_binary(BIN_GREATER); ]
  -> "<=" [ return new ON_binary(BIN_LESSEQ); ]
  -> ">=" [ return new ON_binary(BIN_GREATEREQ); ]
  -> "==" [ return new ON_binary(BIN_EQUAL); ]
  -> "!=" [ return new ON_binary(BIN_NOTEQUAL); ]
  -> "&"  [ return new ON_binary(BIN_BITAND); ]
  -> "^"  [ return new ON_binary(BIN_BITXOR); ]
  -> "|"  [ return new ON_binary(BIN_BITOR); ]
  -> "&&" [ return new ON_binary(BIN_AND); ]
  -> "||" [ return new ON_binary(BIN_OR); ]

  -> op:AssignmentOperator  [ return new ON_assign(op); ]

  -> "!"  [ return new ON_unary(UNY_NOT); ]
  -> "~"  [ return new ON_unary(UNY_BITNOT); ]

  -> "++" [ return new ON_effect(EFF_PREINC); ]
  -> "--" [ return new ON_effect(EFF_PREDEC); ]

  -> ","     [ return new ON_overload(OVL_COMMA); ]
  -> "->"    [ return new ON_overload(OVL_ARROW); ]
  -> "(" ")" [ return new ON_overload(OVL_PARENS); ]
  -> "[" "]" [ return new ON_overload(OVL_BRACKETS); ]
}


// ------ A.12 Templates ------
// I recognize this syntax, but ignore it
nonterm ExportOpt {
  -> empty;
  -> "export";
}

nonterm[TemplateDeclaration*] TemplateDeclaration {
  // this is the std's rule
  //-> ExportOpt "template" "<" TemplateParameterList ">" Declaration;

  // I have expanded 'Declaration' as appropriate, which cuts down on
  // the filtering work and also makes the semantic values available
  // in a more convenient context.  In particular, I dug down several
  // levels to get 'ClassSpecifier' for template classes, which
  // dramatically cuts down on the vestigial stuff the std's grammar
  // would have potentially included.

  // template function
  -> ExportOpt "template" "<" plist:TemplateParameterList ">" def:FunctionDefinition
       [ return new TD_func(plist, def); ]

  // definition of a template classe
  -> ExportOpt "template" "<" plist:TemplateParameterList ">" spec:ClassSpecifier ";"
       [ return new TD_class(plist, spec); ]

  // forward declarations of a template classe
  -> ExportOpt "template" "<" plist:TemplateParameterList ">" spec:ElaboratedTypeSpecifier ";"
       [ return new TD_class(plist, spec); ]
}

nonterm[FakeList<TemplateParameter>*] TemplateParameterList {
  -> p:TemplateParameter
       [ return FakeList<TemplateParameter>::makeList(p); ]
  -> p:TemplateParameter "," list:TemplateParameterList
       [ return list->prepend(p); ]
}


nonterm[TemplateParameter*] TemplateParameter {
  -> p:TemplateTypeParameter  [ return p; ]

  // for now, don't allow this
  //-> ParameterDeclaration;
}

// called "TypeParameter" in std
nonterm[TP_type*] TemplateTypeParameter {
  // for now, only allow some of these forms
  -> "class" i:IdentifierOpt                  [ return new TP_type(loc, i, NULL /*default*/); ]
  -> "class" i:IdentifierOpt "=" t:TypeId     [ return new TP_type(loc, i, t); ]
  -> "typename" i:IdentifierOpt               [ return new TP_type(loc, i, NULL /*default*/); ]
  -> "typename" i:IdentifierOpt "=" t:TypeId  [ return new TP_type(loc, i, t); ]

  //-> "template" "<" TemplateParameterList ">" "class" IdentifierOpt;
  //-> "template" "<" TemplateParameterList ">" "class" IdentifierOpt "=" IdExpression;
}

nonterm[FakeList<TemplateArgument>*] TemplateArgumentListOpt {
  -> empty                       [ return FakeList<TemplateArgument>::emptyList(); ]
  -> list:TemplateArgumentList   [ return list; ]
}

nonterm[PQName*] TemplateId {
  -> n:Identifier "<" list:TemplateArgumentListOpt ">"
       [ return new PQ_template(n, list); ]
}

nonterm[FakeList<TemplateArgument>*] TemplateArgumentList {
  -> a:TemplateArgument
       [ return FakeList<TemplateArgument>::makeList(a); ]
  -> a:TemplateArgument "," list:TemplateArgumentList
       [ return list->prepend(a); ]
}

nonterm[TemplateArgument*] TemplateArgument {
  //-> AssignmentExpression;
  
  // this is the only one I want for now
  -> t:TypeId    [ return new TA_type(t); ]

  // is this for template args that are templates, or what?
  //-> IdExpression;
}

//nonterm ExplicitInstantiation {
//  -> "template" Declaration;
//}

nonterm[TemplateDeclaration*] ExplicitSpecialization {
  // rule from std:
  //   -> "template" "<" ">" Declaration;
  // as in TemplateDeclaration, I've expanded the Declaration nonterminal

  -> "template" "<" ">" def:FunctionDefinition
       [ return new TD_func(FakeList<TemplateParameter>::emptyList(), def); ]

  -> "template" "<" ">" spec:ClassSpecifier ";"
       [ return new TD_class(FakeList<TemplateParameter>::emptyList(), spec); ]

  -> "template" "<" ">" spec:ElaboratedTypeSpecifier ";"
       [ return new TD_class(FakeList<TemplateParameter>::emptyList(), spec); ]
}


// ------ A.13 Exception handling ------
nonterm[S_try*] TryBlock {
  -> "try" s:CompoundStatement h:HandlerSeq  [ return new S_try(loc, s, h); ]
}

nonterm[FakeList<Handler>*] HandlerSeq {
  -> h:Handler                 [ return FakeList<Handler>::makeList(h); ]
  -> h:Handler seq:HandlerSeq  [ return seq->prepend(h); ]
}

nonterm[Handler*] Handler {
  -> "catch" "(" d:HandlerParameter ")" s:CompoundStatement
       [ return new HR_type(s, d); ]

  -> "catch" "(" "..." ")" s:CompoundStatement
       [ return new HR_default(s); ]
}

nonterm[ASTTypeId*] HandlerParameter {
  -> s:TypeSpecifier d:Declarator
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> s:TypeSpecifier d:AbstractDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
}


nonterm[E_throw*] ThrowExpression {
  -> "throw"                         [ return new E_throw(NULL); ]
  -> "throw" e:AssignmentExpression  [ return new E_throw(e); ]
}


nonterm[ExceptionSpec*] ExceptionSpecificationOpt {
  -> empty                            
       [ return NULL; ]
  -> "throw" "(" ")"                  
       [ return new ExceptionSpec(FakeList<ASTTypeId>::emptyList()); ]
  -> "throw" "(" list:TypeIdList ")"
       [ return new ExceptionSpec(list); ]
}

nonterm[FakeList<ASTTypeId>*] TypeIdList {
  -> t:TypeId                      
       [ return FakeList<ASTTypeId>::makeList(t); ]
  -> t:TypeId "," list:TypeIdList  
       [ t->setNext(list->first());
         return FakeList<ASTTypeId>::makeList(t); ]
}
