// cc.gr            see license.txt for copyright and terms of use
// grammar for C++

// A word of warning: there are three sources of names running
// around here:
//   (1) the c++ standard's grammar's names
//   (2) my modified grammar's names
//   (3) names of AST nodes
// (1) and (2) correspond everywhere except in places where I want
// the grammar to do more parsing work than the standard's (mainly
// for declarators) and where I've chosen to fold in "opt".  The
// names in (3) are often different because later phases of analysis
// want to see different conceptual structure.  Anyway, the point is
// to be aware which kind of name a given thing is.

// this makes it so that, by default, dup() is the identity function,
// and del() is a no-op
option useGCDefaults;

verbatim CCGr [

#include "strtable.h"     // StringRef (r)
#include "cc_type.h"      // type identifiers like ST_CHAR (r)
#include "lexer2.h"       // lexer2's token ids for classify()
#include "ccparse.h"      // ParseEnv
#include "trace.h"        // trace
#include "cc.ast.gen.h"   // C++ abstract syntax
#include "cc_lang.h"      // CCLang

#define D(msg) \
  trace("cc") << msg << endl

class CCGr : public UserActions, public ParseEnv {
public:    // data
  StringRef strRefAttr;         // "attr"
  CCLang &lang;

public:    // funcs
  CCGr(StringTable &table, CCLang &alang)
    : ParseEnv(table),
      strRefAttr(table.add("attr")),
      lang(alang) {}

private:
  #include "cc.gr.gen.h"

  // retained for now in case I decide to try lexer hack with C++  
  void declareClassTag(PQName const *tagName);
};

UserActions *makeUserActions(StringTable &table, CCLang &lang)
{
  return new CCGr(table, lang);
}

// when this is the last element in a parameter list, the function
// is a vararg function
ASTTypeId *ellipsisTypeId()
{
  return new ASTTypeId(new TS_simple(ST_ELLIPSIS),
                       new Declarator(new D_name(SourceLocation(), NULL /*name*/),
                                      NULL /*init*/));
}

void CCGr::declareClassTag(PQName const *tagName)
{
  // TYPE/NAME
  if (lang.tagsAreTypes) {
    D("defined new struct/class tag as type " << tagName->name);
    addType(tagName);
  }
}

]


terminals {
  // grab list generated by lexer
  include("cc/cc.tok")

  token[int] L2_INT_LITERAL ;

  token[float*] L2_FLOAT_LITERAL ;

  token[char] L2_CHAR_LITERAL ;

  token[StringRef] L2_NAME {
    // every time I pull an L2_NAME from the lexer, this code is
    // run to possibly reclassify the token kind; the semantic
    // value is passed (and ParseEnv is available as context), but
    // the same semantic value will be used
      
    // -- no lexer hack now --
    // I mark this, and all places the deal with resolving the
    // type-name vs variable-name ambiguity, with "TYPE/NAME"
    //classify(s) [
    //  if (isType(s)) {
    //    return L2_TYPE_NAME;
    //  }
    //  else {
    //    return L2_VARIABLE_NAME;
    //  }
    //]
    
    dup(n) [ return n; ]
    del(n) []
  }

  token[StringRef] L2_TYPE_NAME;
  token[StringRef] L2_VARIABLE_NAME;

  token[StringRef] L2_STRING_LITERAL ;

  precedence {
    // high precedence
    prec L2_PREFER_REDUCE;
    prec "const" "volatile" "owner" "__attribute__" "else";

    right ".*" "->*";
    left "*" "/" "%";
    left "+" "-";
    left "<<" ">>";
    left "<" ">" "<=" ">=";
    left "==" "!=";
    left "&";
    left "^";
    left "|";
    left "&&";
    left "||";
    right "==>";    // ESC's user manual specifies a precedence but not an associativity for "==>"

    prec L2_PREFER_SHIFT;
    // low precedence
  }
}


nonterm[TranslationUnit*] File -> EnterScope t:TranslationUnit LeaveScope
  [ return t; ]

// scoping
nonterm EnterScope -> empty    [
  D("entering scope");
  enterScope();
  return 0;
]

nonterm LeaveScope -> empty     [
  D("exiting scope");
  leaveScope();
  return 0;
]


// ------------- identifier ambiguity -------------------
// identifiers can play two primary roles, and this is the
// source of problems parsing C and C++

// name of a type; introduced by class, struct, union, enum, typedef
nonterm[StringRef] TypeName {
  dup(n) [ return n; ]
  del(n) []
  -> n:L2_TYPE_NAME     [ return n; ]
  -> n:L2_NAME          [ return n; ]    // for when not using lexer hack
}

// name of a variable or function; introduced by a declaration
nonterm[StringRef] VariableName {
  dup(n) [ return n; ]
  del(n) []
  -> n:L2_VARIABLE_NAME [ return n; ]
  -> n:L2_NAME          [ return n; ]    // for when not using lexer hack
}

// names for situations where it does not matter what its previous
// meaning may have been
nonterm[StringRef] AnyName {
  -> n:L2_TYPE_NAME     [ return n; ]
  -> n:L2_VARIABLE_NAME [ return n; ]
  -> n:L2_NAME          [ return n; ]    // for when not using lexer hack
}


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------
nonterm[TranslationUnit*] TranslationUnit {
  -> empty                                [ return new TranslationUnit(NULL); ]

  -> t:TranslationUnit d:Declaration      [ t->topForms.append(d); return t; ]
}

// ------ A.4 Expressions ------
nonterm[Expression*] PrimaryExpression {
  -> e:Literal
       [ return e; ]

  -> "this"
       [ return new E_variable(new PQName(str("this"))); ]

  -> "(" e:Expression ")"
       [ return e; ]

  -> e:PQVarName
       [ return new E_variable(e); ]

  // GNU extension
  //-> "(" s:CompoundStatement ")" ;

  // gnu extension: "constructor expression"
  // (notation for literal struct values)
  // e.g.:
  //   struct Foo { int x; int y; };
  //   struct Foo myfoo;
  //   myfoo = (struct Foo) { 4, 5 };        <-- here
  // which would assign x=4 and y=5 in 'myfoo'
  //-> "(" t:TypeId ")" i:CompoundInitializer
  //     [ return new E_structLit(t, i); ]
}

nonterm[Expression*] Literal {
  -> i:L2_INT_LITERAL    [ return new E_intLit(i); ]
  -> f:L2_FLOAT_LITERAL  [ E_floatLit *ret = new E_floatLit(*f); delete f; return ret; ]
  -> s:StringLiteral     [ return new E_stringLit(s); ]
  -> c:L2_CHAR_LITERAL   [ return new E_charLit(c); ]
  -> L2_TRUE             [ return new E_boolLit(true); ]
  -> L2_FALSE            [ return new E_boolLit(false); ]
}

// gnu: this is to handle gnu's f'd up pseduo-symbols, which
// have the annoying property that they have to concatenate
// with string literals (so I can't just, say, declare them
// to be char* and be done with it)
nonterm[StringRef] StringLiteral {
  -> s:L2_STRING_LITERAL  [ return s; ]
  //-> StringLiteral L2_STRING_LITERAL ;
  //-> StringLiteral "__FUNCTION__" ;
  //-> StringLiteral "__PRETTY_FUNCTION__" ;
}


// possibly-qualified name; essentially spec's id-expression
// missing: template-id because I don't know what that is
nonterm[PQName*] PQVarName {
  -> n:VariableName               [ return new PQName(n); ]

  -> q:Qualifier rhs:PQVarName    [ rhs->prependQualifier(q); return rhs; ]

  //-> OperatorFunctionId ;
  //-> ConversionFunctionId ;
  //-> "~" TypeName ;
}

// similar for AnyName {
nonterm[PQName*] PQName {
  -> n:AnyName                    [ return new PQName(n); ]
  -> q:Qualifier rhs:PQName       [ rhs->prependQualifier(q); return rhs; ]
}

nonterm[StringRef] Qualifier {
  -> "::"             [ return NULL; ]    // "::" alone is encoded this way
  -> n:TypeName "::"  [ return n; ]
}


nonterm[Expression*] PostfixExpression {
  // ambiguity:
  //   x(y)
  // can either be a function call (x is a function)
  // or a constructor call (x is a type)
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:PrimaryExpression 
       [ return e; ]

  // array access
  -> a:PostfixExpression "[" e:Expression "]"
       [ return new E_deref(new E_binary(a, BIN_PLUS, e)); ]

  // fn call
  -> f:PostfixExpression "(" e:ExpressionListOpt ")"
       [ return new E_funCall(f, e); ]

  // function-style cast, or (equivalently) call to constructor; will
  // almost always be ambiguous with function call, so the distinction
  // will have to be delayed until typechecking
  -> spec:CtorExpressionType "(" e:ExpressionListOpt ")"
       [ return new E_constructor(spec, e); ]

  // field access
  -> p:PostfixExpression "."  n:PQVarName
       [ return new E_fieldAcc(p, n); ]

  // deref + field access
  -> p:PostfixExpression "->" n:PQVarName
       [ return new E_fieldAcc(new E_deref(p), n); ]

  -> p:PostfixExpression "++" 
       [ return new E_effect(EFF_POSTINC, p); ]
  -> p:PostfixExpression "--"
       [ return new E_effect(EFF_POSTDEC, p); ]

  // explicit dtor call
  -> p:PostfixExpression "." n:PQDtorName
       [ return new E_fieldAcc(p, n); ]
  -> p:PostfixExpression "->" n:PQDtorName
       [ return new E_fieldAcc(p, n); ]

  -> k:CastKeyword "<" t:TypeId ">" "(" e:Expression ")"
       [ return new E_keywordCast(k, t, e); ]

  -> "typeid" "(" e:Expression ")"
       [ return new E_typeidExpr(e); ]
  -> "typeid" "(" t:TypeId ")"
       [ return new E_typeidType(t); ]
}
                                            
// the std calls this SimpleTypeSpecifier, but then also uses that
// name in some other roles; this is only for the name of a class or
// type, used as a constructor name
nonterm[TypeSpecifier*] CtorExpressionType {
  //-> ColonColonOpt NestedNameSpecifier "template" TemplateId;

  -> n:PQTypeName        [ return new TS_name(n); ]
  -> "char"              [ return new TS_simple(ST_CHAR); ]
  -> "wchar_t"           [ return new TS_simple(ST_WCHAR_T); ]
  -> "bool"              [ return new TS_simple(ST_BOOL); ]
  -> "short"             [ return new TS_simple(ST_SHORT_INT); ]
  -> "int"               [ return new TS_simple(ST_INT); ]
  -> "long"              [ return new TS_simple(ST_LONG_INT); ]
  -> "signed"            [ return new TS_simple(ST_INT); ]
  -> "unsigned"          [ return new TS_simple(ST_UNSIGNED_INT); ]
  -> "float"             [ return new TS_simple(ST_FLOAT); ]
  -> "double"            [ return new TS_simple(ST_DOUBLE); ]

  // std has this, but I don't think it makes sense
  //-> "void"
}

nonterm[CastKeyword] CastKeyword {
  -> "dynamic_cast"      [ return CK_DYNAMIC; ]
  -> "static_cast"       [ return CK_STATIC; ]
  -> "reinterpret_cast"  [ return CK_REINTERPRET; ]
  -> "const_cast"        [ return CK_CONST; ]
}

// here, and everywhere else that FakeList is used, I use right
// recursion to construct the list; this does mean the stack size
// is linear in the size of the list, but the benefit of not
// having to reverse the list of use ASTList (which is difficult
// to share) is worth it
nonterm[FakeList<Expression>*] ExpressionList {
  -> a:AssignmentExpression
       [ return FakeList<Expression>::makeList(a); ]
  -> a:AssignmentExpression "," e:ExpressionList
       [ a->setNext(e->first()); 
         return FakeList<Expression>::makeList(a); ]
}

nonterm[FakeList<Expression>*] ExpressionListOpt {
  -> empty               [ return FakeList<Expression>::emptyList(); ]
  -> e:ExpressionList    [ return e; ]
}

// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName
//PseudoDestructorName -> Qualifier PseudoDestructorName

nonterm[Expression*] UnaryExpression {
  // ambiguous:
  //   sizeof(x)
  // could either be size of an expression 'x', or
  // size of a type called 'x'
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:PostfixExpression         [ return e; ]

  -> "++" e:CastExpression       [ return new E_effect(EFF_PREINC, e); ]
  -> "--" e:CastExpression       [ return new E_effect(EFF_PREDEC, e); ]

  // size of expression
  -> "sizeof" e:UnaryExpression  [ return new E_sizeof(e); ]

  -> e:DeleteExpression          [ return e; ]

  // dereference, addrof
  -> "*" e:CastExpression        [ return new E_deref(e); ]
  -> "&" e:CastExpression        [ return new E_addrOf(e); ]

  // other unary operators
  -> "+" e:CastExpression        [ return new E_unary(UNY_PLUS, e); ]
  -> "-" e:CastExpression        [ return new E_unary(UNY_MINUS, e); ]
  -> "!" e:CastExpression        [ return new E_unary(UNY_NOT, e); ]
  -> "~" e:CastExpression        [ return new E_unary(UNY_BITNOT, e); ]
                                               
  // size of type
  -> "sizeof" "(" t:TypeId ")"   [ return new E_sizeofType(t); ]

  -> e:NewExpression             [ return e; ]
}


// ---------------- "new" and "delete" expressions --------------
nonterm[bool] ColonColonOpt {
  -> empty     [ return false; ]
  -> "::"      [ return true; ]
}

nonterm[E_new*] NewExpression {
  -> c:ColonColonOpt "new" p:NewPlacementOpt t:NewTypeId i:NewInitializerOpt
       [ return new E_new(c, p, t, i); ]
  -> c:ColonColonOpt "new" p:NewPlacementOpt "(" t:TypeId ")" i:NewInitializerOpt
       [ return new E_new(c, p, t, i); ]
}

nonterm[FakeList<Expression>*] NewPlacementOpt {
  -> empty                          [ return FakeList<Expression>::emptyList(); ]
  -> "(" lst:ExpressionList ")"     [ return lst; ]
}

nonterm[ASTTypeId*] NewTypeId {
  -> spec:TypeSpecifier decl:NewDeclaratorOpt
       [ return new ASTTypeId(spec, new Declarator(decl, NULL)); ]
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]"  ("[" ConstExpression "]")* )?
nonterm[IDeclarator*] NewDeclaratorOpt {
  -> empty                               [ return new D_name(loc, NULL); ]
  -> p:PtrOperator d:NewDeclaratorOpt    [ d->stars = d->stars->prepend(p); return d; ]

  // commit to at least one "[" ... "]"
  -> d:DirectNewDeclarator               [ return d; ]
}
nonterm[IDeclarator*] DirectNewDeclarator {
  -> /*abstract declarator*/ "[" sz:Expression "]"
       [ return new D_array(new D_name(loc, NULL), sz); ]
  -> d:DirectNewDeclarator "[" sz:ConstantExpression "]"
       [ return new D_array(d, sz); ]
}

nonterm[ExpressionListOpt*] NewInitializerOpt {
  -> empty                            [ return NULL; ]
  -> "(" lst:ExpressionListOpt ")"    [ return new ExpressionListOpt(lst); ]
}

nonterm[Expression*] DeleteExpression {
  -> c:ColonColonOpt "delete" e:CastExpression
       [ return new E_delete(c, false /*array*/, e); ]
  -> c:ColonColonOpt "delete" "[" "]" e:CastExpression
       [ return new E_delete(c, true /*array*/, e); ]
}
// ------------ end of "new" and "delete" expressions -------------


nonterm[Expression*] CastExpression {
  // ambiguous:
  //   (x)(y)
  // could either be a call to function 'x' with argument 'y', or
  // it could be a cast to type 'x' of the expression 'y'
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:UnaryExpression
       [ return e; ]
  -> "(" t:TypeId ")" e:CastExpression
       [ return new E_cast(t, e); ]
}

// ++++ binary operator expression ++++
// primary expressions
nonterm[Expression*] BinaryExpression {
  // ambiguous:
  //   (x) & (y)
  // could either be the bitwise AND of expressions x and y, or
  // it could be the address of expression y, cast to type x
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> e:CastExpression                                    [ return e; ]

  -> left:BinaryExpression ".*"  right:BinaryExpression  [ return new E_binary(left, BIN_DOT_STAR, right); ]
  -> left:BinaryExpression "->*" right:BinaryExpression  [ return new E_binary(left, BIN_ARROW_STAR, right); ]

  -> left:BinaryExpression "*"  right:BinaryExpression   [ return new E_binary(left, BIN_MULT, right); ]
  -> left:BinaryExpression "/"  right:BinaryExpression   [ return new E_binary(left, BIN_DIV, right); ]
  -> left:BinaryExpression "%"  right:BinaryExpression   [ return new E_binary(left, BIN_MOD, right); ]
  -> left:BinaryExpression "+"  right:BinaryExpression   [ return new E_binary(left, BIN_PLUS, right); ]
  -> left:BinaryExpression "-"  right:BinaryExpression   [ return new E_binary(left, BIN_MINUS, right); ]
  -> left:BinaryExpression "<<" right:BinaryExpression   [ return new E_binary(left, BIN_LSHIFT, right); ]
  -> left:BinaryExpression ">>" right:BinaryExpression   [ return new E_binary(left, BIN_RSHIFT, right); ]
  -> left:BinaryExpression "<"  right:BinaryExpression   [ return new E_binary(left, BIN_LESS, right); ]
  -> left:BinaryExpression ">"  right:BinaryExpression   [ return new E_binary(left, BIN_GREATER, right); ]
  -> left:BinaryExpression "<=" right:BinaryExpression   [ return new E_binary(left, BIN_LESSEQ, right); ]
  -> left:BinaryExpression ">=" right:BinaryExpression   [ return new E_binary(left, BIN_GREATEREQ, right); ]
  -> left:BinaryExpression "==" right:BinaryExpression   [ return new E_binary(left, BIN_EQUAL, right); ]
  -> left:BinaryExpression "!=" right:BinaryExpression   [ return new E_binary(left, BIN_NOTEQUAL, right); ]
  -> left:BinaryExpression "&"  right:BinaryExpression   [ return new E_binary(left, BIN_BITAND, right); ]
  -> left:BinaryExpression "^"  right:BinaryExpression   [ return new E_binary(left, BIN_BITXOR, right); ]
  -> left:BinaryExpression "|"  right:BinaryExpression   [ return new E_binary(left, BIN_BITOR, right); ]

  -> left:BinaryExpression "&&" right:BinaryExpression   [ return new E_binary(left, BIN_AND, right); ]
  -> left:BinaryExpression "||" right:BinaryExpression   [ return new E_binary(left, BIN_OR, right); ]
}


nonterm[Expression*] ConditionalExpression {
  -> e:BinaryExpression 
       [ return e; ]

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression 
       [ return new E_cond(cond, th, el); ]
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm[Expression*] AssignmentExpression {
  -> e:ConditionalExpression 
       [ return e; ]

  -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression
       [ return new E_assign(e1, op, e2); ]
       
  -> e:ThrowExpression
       [ return e; ]
}

nonterm[enum BinaryOp] AssignmentOperator {
  -> "*="  [ return BIN_MULT; ]
  -> "/="  [ return BIN_DIV; ]
  -> "%="  [ return BIN_MOD; ]
  -> "+="  [ return BIN_PLUS; ]
  -> "-="  [ return BIN_MINUS; ]
  -> ">>=" [ return BIN_RSHIFT; ]
  -> "<<=" [ return BIN_LSHIFT; ]
  -> "&="  [ return BIN_BITAND; ]
  -> "^="  [ return BIN_BITXOR; ]
  -> "|="  [ return BIN_BITOR; ]
  -> "="   [ return BIN_ASSIGN; ]
}


// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
// update: now that I'm doing translation too, the difference
// in the meanings is great enough that I think they should be
// separate, as they are
nonterm[Expression*] Expression {
  -> ae:AssignmentExpression 
       [ return ae; ]

  -> e:Expression "," ae:AssignmentExpression 
       [ return new E_comma(e, ae); ]
}

nonterm[Expression*] ExpressionOpt {
  // empty expression is a nop
  -> empty         [ return new E_intLit(1); ]
  -> e:Expression  [ return e; ]
}

// this is an expression with the additional requirement that
// it be entirely evaluable to an int at compile time
// (the name exists simply to help document that fact; the grammar
// cannot enforce it)
nonterm[Expression*] ConstantExpression -> e:ConditionalExpression 
  [ return e; ]


// ------ A.5 Statements ------
// labeled-statement
nonterm[Statement*] Statement {
  // ambiguity:
  //   x(y);
  // can either be an Expression statement (function call)
  // or a BlockDeclaration (declare variable y, of type x)
  merge(L,R) [ L->addAmbiguity(R); return L; ]

  -> n:AnyName ":" s:Statement 
       [ return new S_label(loc, n, s); ]

  -> "case" e:ConstantExpression ":" s:Statement
       [ return new S_case(loc, e, s); ]

  -> "default" ":" s:Statement
       [ return new S_default(loc, s); ]

  // expression-statement
  -> s:ExpressionStatement
       [ return s; ]

  // compound-statement
  -> s:CompoundStatement
       [ return s; ]

  // selection-statement
  // (prefer to shift "else" over reducing by this rule)
  -> "if" "(" e:Condition ")" s:Statement     precedence(L2_PREFER_SHIFT)
       [ return new S_if(loc, e, s, new S_skip(loc)); ]

  // if-then-else preferred over if-then when ambiguous
  -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement
       [ return new S_if(loc, e, s1, s2); ]

  -> "switch" "(" e:Condition ")" s:Statement
       [ return new S_switch(loc, e, s); ]

  -> "while" "(" e:Condition ")" s:Statement
       [ return new S_while(loc, e, s); ]

  -> "do" s:Statement "while" "(" e:Expression ")" ";"
       [ return new S_doWhile(loc, s, e); ]

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ExpressionOpt ")" s2:Statement
       [ return new S_for(loc, s1, c, e, s2); ]

  -> "break" ";"                        [ return new S_break(loc); ]

  -> "continue" ";"                     [ return new S_continue(loc); ]

  -> "return" e:Expression ";"          [ return new S_return(loc, e); ]

  -> "return" ";"                       [ return new S_return(loc, NULL); ]

  -> "goto" n:AnyName ";"               [ return new S_goto(loc, n); ]

  // declaration-statement
  -> d:BlockDeclaration                 [ return new S_decl(loc, d); ]

  // try-block
  -> s:TryBlock                         [ return s; ]
}

nonterm[Statement*] ExpressionStatement {
  -> ";"                [ return new S_skip(loc); ]
  -> e:Expression ";"   [ return new S_expr(loc, e); ]
}

nonterm[S_compound*] CompoundStatement {
  // I must enter scope immediately upon seeing the open-brace, so
  // that if the first token of the first statement changes or queries
  // the scope, it's in the new one
  -> EnterScope seq:CompoundStmtSeq LeaveScope "}"
       [ return seq; ]
}

nonterm[S_compound*] CompoundStmtSeq {
  // I pushed "{" into this nonterminal so the 'loc' would reflect
  // its location, instead of the location of the first statement inside
  // (and in fact since 'empty' has no location, I wouldn't even have
  // been able to get that..)
  -> "{" empty
       [ return new S_compound(loc, NULL); ]
  -> c:CompoundStmtSeq s:Statement
       [ c->stmts.append(s); return c; ]
}

// the guard of e.g. an 'if' statement
nonterm[Condition*] Condition {
  -> e:Expression      
       [ return new CN_expr(e); ]

  // variable declaration in the condition clause
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression
       [ return new CN_decl(new ASTTypeId(spec, 
                                          new Declarator(decl, new IN_expr(e)))); ]
}

nonterm[Condition*] ConditionOpt {
  // an empty condition (e.g. in a for loop) is interpreted as true
  -> empty             [ return new CN_expr(new E_boolLit(true)); ]
  -> c:Condition       [ return c; ]
}

nonterm[Statement*] ForInitStatement {
  -> s:ExpressionStatement     [ return s; ]
  -> s:SimpleDeclaration       [ return new S_decl(loc, s); ]
}


// ----- A.6 Declarations ------
//nonterm[ASTList<Declaration>*] DeclarationSeqOpt {
//  -> empty
//       [ return new ASTList<Declaration>(); ]
//  -> seq:DeclarationSeqOpt d:Declaration
//       [ seq->append(d); return seq; ]
//} 

nonterm[TopForm*] Declaration {
  -> d:BlockDeclaration      [ return new TF_decl(loc, d); ]
  -> f:FunctionDefinition    [ return new TF_func(loc, f); ]
  //-> TemplateDeclaration ;
  //-> d:LinkageSpecification ;
}

// C++ has other alternatives..
nonterm[Declaration*] BlockDeclaration {
  -> d:SimpleDeclaration     [ return d; ]
}

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
//   (I've moved those guys into more specialized contexts)
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm[Declaration*] SimpleDeclaration {
  //e.g.: int                x                     ;
  -> spec:DeclSpecifier list:InitDeclaratorListOpt ";"
       [ spec->decllist = list; return spec; ]

  -> "typedef" spec:DeclSpecifier list:TypedefDeclaratorList ";"
       [
         spec->dflags = (DeclFlags)(spec->dflags | DF_TYPEDEF);
         spec->decllist = list;
         return spec;
       ]

  // gnu; specifically for linux printk declaration
  //-> GNUAttribute decl:SimpleDeclaration ;
}


// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

// I return a Declaration object with an empty decllist, as a proxy
// for returning dflags and spec as a pair
nonterm[Declaration*] DeclSpecifier {
  -> "inline" m:DeclModifier s:TypeSpecifier
       [ return new Declaration((DeclFlags)(DF_INLINE | m), s, NULL); ]

  -> m:DeclModifier "inline" s:TypeSpecifier
       [ return new Declaration((DeclFlags)(DF_INLINE | m), s, NULL); ]

  -> m:DeclModifier s:TypeSpecifier
       [ return new Declaration(m, s, NULL); ]

  -> "inline" s:TypeSpecifier
       [ return new Declaration(DF_INLINE, s, NULL); ]

  -> s:TypeSpecifier 
       [ return new Declaration(DF_NONE, s, NULL); ]
}

// my analysis (informal and ad-hoc) indicates that none of these can
// be used together; "inline" is pulled out because it can be used
// with "virtual", "static", "friend", and possibly "extern"; I
// consider all this preferable to just allowing a "word soup"
nonterm[enum DeclFlags] DeclModifier {
  -> "virtual"     [ return DF_VIRTUAL;  ]
  -> "friend"      [ return DF_FRIEND;   ]
  -> "mutable"     [ return DF_MUTABLE;  ]
  -> "auto"        [ return DF_AUTO;     ]
  -> "register"    [ return DF_REGISTER; ]
  -> "static"      [ return DF_STATIC;   ]
  -> "extern"      [ return DF_EXTERN;   ]

  -> "thmprv_predicate"   [ return DF_PREDICATE; ]
}


// plays role of "TypeSpecifierSeq" in std
nonterm[TypeSpecifier*] TypeSpecifier {
  // the existence of this production is part of why parsing C is hard
  -> n:PQTypeName 
       [ return new TS_name(n); ]

  -> s:PrimitiveTypeSpecifier            // int
       [ return new TS_simple(s); ]

  -> s:PrimitiveCVTypeSpecifier          // unsigned const char  (not good style, IMO)
       [
         TS_simple *ret = new TS_simple((SimpleTypeId)(s & ST_BITMASK));
         ret->cv = (CVFlags)(s & CV_ALL);
         return ret;
       ]

  -> s:ElaboratedTypeSpecifier        // class foo  or  enum bar
       [ return s; ]

  -> s:ClassSpecifier                 // class { ... }
       [ return s; ]
  -> s:EnumSpecifier                  // enum { ... }
       [ return s; ]

  // the following rules create an ambiguity because they don't
  // say how to parse things like "const int const"; so assign
  // all of them precedence higher than const/volatile/attribute,
  // so we'll just prefer reducing always

  -> q:CVQualifier s:TypeSpecifier  precedence(L2_PREFER_REDUCE)   // const int
       [ s->cv = (CVFlags)(s->cv | q); return s; ]
  -> s:TypeSpecifier q:CVQualifier  precedence(L2_PREFER_REDUCE)   // int const
       [ s->cv = (CVFlags)(s->cv | q); return s; ]
}


nonterm[TS_elaborated*] ElaboratedTypeSpecifier {
  -> k:ClassKey n:PQName   [
       declareClassTag(n);
       return new TS_elaborated(loc, k, n);
     ]
  -> "enum" n:PQName            [ return new TS_elaborated(loc, TI_ENUM, n); ]
}


// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here
nonterm[enum SimpleTypeId] PrimitiveTypeSpecifier {
  -> "char"                     [ return ST_CHAR; ]
  -> "unsigned" "char"          [ return ST_UNSIGNED_CHAR; ]
  -> "signed" "char"            [ return ST_SIGNED_CHAR; ]
  -> "bool"                     [ return ST_BOOL; ]
  -> "unsigned"                 [ return ST_UNSIGNED_INT; ]
  -> "unsigned" "int"           [ return ST_UNSIGNED_INT; ]
  -> "signed"                   [ return ST_INT; ]
  -> "signed" "int"             [ return ST_INT; ]
  -> "int"                      [ return ST_INT; ]
  -> "unsigned" "short" "int"   [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short"         [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "long" "int"    [ return ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long"          [ return ST_UNSIGNED_LONG_INT; ]
  -> "signed" "long" "int"      [ return ST_LONG_INT; ]
  -> "signed" "long"            [ return ST_LONG_INT; ]
  -> "long" "int"               [ return ST_LONG_INT; ]
  -> "long"                     [ return ST_LONG_INT; ]
  -> "signed" "long" "long"     [ return ST_LONG_LONG; ]
  -> "long" "long"              [ return ST_LONG_LONG; ]
  -> "unsigned" "long" "long"   [ return ST_UNSIGNED_LONG_LONG; ]
  -> "signed" "short" "int"     [ return ST_SHORT_INT; ]
  -> "signed" "short"           [ return ST_SHORT_INT; ]
  -> "short" "int"              [ return ST_SHORT_INT; ]
  -> "short"                    [ return ST_SHORT_INT; ]
  -> "wchar_t"                  [ return ST_WCHAR_T; ]
  -> "float"                    [ return ST_FLOAT; ]
  -> "double"                   [ return ST_DOUBLE; ]
  -> "long" "double"            [ return ST_LONG_DOUBLE; ]
  -> "void"                     [ return ST_VOID; ]
}


// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm[PQName*] PQTypeName {
  -> n:TypeName                [ return new PQName(n); ]
  -> q:Qualifier n:PQTypeName  [ n->prependQualifier(q); return n; ]

  //-> TemplateId ;
}

// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll probably merge them at some point
//
// I return an 'int' here because it's an OR of CVFlags and SimpleTypeId
nonterm[int] PrimitiveCVTypeSpecifier {
  -> "unsigned" q:CVQualifierSeq "char"         [ return q | ST_UNSIGNED_CHAR; ]
  -> "signed" q:CVQualifierSeq "char"           [ return q | ST_SIGNED_CHAR; ]
  -> "unsigned" q:CVQualifierSeq "int"          [ return q | ST_UNSIGNED_INT; ]
  -> "signed" q:CVQualifierSeq "int"            [ return q | ST_INT; ]
  -> "unsigned" q:CVQualifierSeq "short" "int"  [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short" q:CVQualifierSeq "int"  [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "short"        [ return q | ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "long" "int"   [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long" q:CVQualifierSeq "int"   [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" q:CVQualifierSeq "long"         [ return q | ST_UNSIGNED_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "int"     [ return q | ST_LONG_INT; ]
  -> "signed" "long" q:CVQualifierSeq "int"     [ return q | ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long"           [ return q | ST_LONG_INT; ]
  -> "long" q:CVQualifierSeq "int"              [ return q | ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "long"    [ return q | ST_LONG_LONG; ]
  -> "unsigned" q:CVQualifierSeq "long" "long"  [ return q | ST_UNSIGNED_LONG_LONG; ]
  -> "signed" q:CVQualifierSeq "short" "int"    [ return q | ST_SHORT_INT; ]
  -> "signed" "short" q:CVQualifierSeq "int"    [ return q | ST_SHORT_INT; ]
  -> "signed" q:CVQualifierSeq "short"          [ return q | ST_SHORT_INT; ]
  -> "short" q:CVQualifierSeq "int"             [ return q | ST_SHORT_INT; ]
  -> "long" q:CVQualifierSeq "double"           [ return q | ST_LONG_DOUBLE; ]
}


nonterm[TS_enumSpec*] EnumSpecifier {
  -> "enum" "{" list:EnumeratorListOpt "}"
       [ return new TS_enumSpec(NULL /*name*/, list); ]
  -> "enum" n:AnyName "{" list:EnumeratorListOpt "}"
       [ return new TS_enumSpec(n, list); ]
}


// rewrote this definition so I can always tell with one token of
// lookahead whether this is the last enumerator definition; this
// allows an optional comma at the end, on purpose
nonterm[FakeList<Enumerator>*] EnumeratorListOpt {
  -> empty
       [ return FakeList<Enumerator>::emptyList(); ]
  -> def:EnumeratorDefinition
       [ return FakeList<Enumerator>::makeList(def); ]
  -> def:EnumeratorDefinition "," list:EnumeratorListOpt
       [ return list->prepend(def); ]
}


nonterm[Enumerator*] EnumeratorDefinition {
  -> name:AnyName 
       [ return new Enumerator(loc, name, NULL /*expr*/); ]
  -> name:AnyName "=" expr:ConstantExpression
       [ return new Enumerator(loc, name, expr); ]
}


nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

//nonterm LinkageSpecification {
//  -> "extern" L2_STRING_LITERAL "{" d:DeclarationSeqOpt "}" ;
//  -> "extern" L2_STRING_LITERAL d:Declaration ;
//} 

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm[FakeList<Declarator>*] InitDeclaratorList {
  -> d:InitDeclarator
       [ return FakeList<Declarator>::makeList(d); ]
  -> d:InitDeclarator "," list:InitDeclaratorList
       [ return list->prepend(d); ]
}

nonterm[FakeList<Declarator>*] InitDeclaratorListOpt {
  -> empty
       [ return FakeList<Declarator>::emptyList(); ]
  -> list:InitDeclaratorList
       [ return list; ]
}


nonterm[Declarator*] InitDeclarator {
  -> d:Declarator                       // (int)  x
       [ return new Declarator(d, NULL); ]

  -> d:Declarator i:Initializer         // (int)  x = 5
       [ return new Declarator(d, i); ]
}

nonterm[Initializer*] Initializer {
  -> "=" i:InitializerClause 
       [ return i; ]

  // this causes an ambiguity with
  //   int fileno(FILE *f);
  // because it could be multiplication.. handling it isn't that
  // hard, but for now let's just take out this rule
  //-> "(" ExpressionList ")" ;          // ctor args
}

nonterm[Initializer*] InitializerClause {
  -> e:AssignmentExpression              // scalar
       [ return new IN_expr(e); ]
  -> c:CompoundInitializer               // array/structure initializer
       [ return c; ]
}

nonterm[IN_compound*] CompoundInitializer {
  // array/structure initializer
  -> "{" list:InitializerList CommaOpt "}"  [ return list; ]

  // zero whatever it is
  -> "{" "}"  [ return new IN_compound(NULL); ]
}

// useful syntactic quirk
nonterm CommaOpt {
  -> empty ;
  -> "," ;
}

nonterm[IN_compound*] InitializerList {
  -> init:InitializerClause
       [ IN_compound *list = new IN_compound(NULL);
         list->inits.append(init); 
         return list; ]
  -> list:InitializerList "," init:InitializerClause
       [ list->inits.append(init); return list; ]
}


// perhaps confusing name correspondence:
//   The AST name "Declarator" corresponds to the grammar name
//   "InitDeclarator"; the AST name "IDeclarator" (inner declarator)
//   corresponds to the grammar name "Declarator"
// this name shift simply reflects the different interests of the
// parser vs. subsequent phases of analysis
nonterm[IDeclarator*] Declarator {
  // (PtrOperator)* DirectDeclarator
  -> p:PtrOperator d:Declarator
       [ d->stars = d->stars->prepend(p); return d; ]

  -> d:DirectDeclarator
       [ return d; ]
}

nonterm[IDeclarator*] DirectDeclarator {
  // it doesn't matter how this was classified before, because a
  // declarator binds a new name, so it shadows any prior definitions;
  // note: this rule handles constructor names!
  -> n:PQName
       [ return new D_name(loc, n); ]

  // dtor
  -> n:PQDtorName
       [ return new D_name(loc, n); ]

  // conversion function
  -> d:ConversionFunctionId
       [ return new D_operator(d); ]

  // operator function
  -> d:OperatorFunctionId
       [ return new D_operator(d); ]

  // function declarator; the return type comes from the type
  // specifier that preceeds this
  -> d:DirectDeclarator                        // name of function
     "(" args:ParameterDeclarationClause ")"   // arguments
     cv:CVQualifierSeqOpt                      // optional "const"
     e:ExceptionSpecificationOpt               // optional "throw" clause
       [ return new D_func(loc, d, args, cv, e); ]

  // array with optional size
  -> d:DirectDeclarator "[" sz:ConstantExpressionOpt "]"
       [ return new D_array(d, sz); ]

  // precedence grouping
  -> "(" d:Declarator ")"
       [ return d; ]
}

// I choose to encode ctor and dtor names as ordinary PQNames, because
// the parser can't tell them apart from other PQNames; but the dtor
// must be handled specially because if I just allowed "~" before any
// name, then I couldn't tell if the expression "~a" is unary "~" or
// the name of a destructor.  Destructor names are encoded by prepending
// a "~" to them, so later phases of analysis will have to look for that.
// (I notice the standard calls this PseudoDestructorName; I'll stick with
// my terminology.)
nonterm[PQName*] PQDtorName {
  -> "~" n:TypeName              [ return new PQName(str(stringc << "~" << n)); ]
  -> q:Qualifier rhs:PQDtorName  [ rhs->prependQualifier(q); return rhs; ]

  //-> ColonColonOpt NestedNameSpecifier "template" TemplateId "::" "~" TypeName;
}

nonterm[Expression*] ConstantExpressionOpt {
  -> empty                 [ return NULL; ]
  -> e:ConstantExpression  [ return e; ]
}


nonterm[PtrOperator*] PtrOperator {
  -> "*" q:CVQualifierSeqOpt   [ return new PtrOperator(q, true /*isPtr*/); ]
  -> "&"                       [ return new PtrOperator(CV_NONE, false /*isPtr*/); ]

  //-> ColonColonOpt NestedNameSpecifier "*" CvQualifierSeqOpt;     // pointer to member
}


nonterm[enum CVFlags] CVQualifierSeqOpt {
  -> empty                       [ return CV_NONE; ]
  -> s:CVQualifierSeq            [ return s; ]
}

nonterm[enum CVFlags] CVQualifierSeq {
  -> q:CVQualifier                       [ return q; ]
  -> q:CVQualifier s:CVQualifierSeq      [ return (CVFlags)(q | s); ]
}

nonterm[enum CVFlags] CVQualifier {
  -> "const"        [ return CV_CONST; ]
  -> "volatile"     [ return CV_VOLATILE; ]
  -> "owner"        [ return CV_OWNER; ]
}


// -- declarators in typedefs --
// these are separated out because the parser wants to track the
// introduction of type names; this is only for the lexer hack,
// so for now the separation is not used
nonterm[FakeList<Declarator>*] TypedefDeclaratorList {
  -> d:TypedefDeclarator
       [ return FakeList<Declarator>::makeList(new Declarator(d, NULL)); ]
  -> d:TypedefDeclarator "," list:TypedefDeclaratorList
       [ return list->prepend(new Declarator(d, NULL)); ]
}

nonterm[IDeclarator*] TypedefDeclarator {
  -> p:PtrOperator d:TypedefDeclarator
       [ d->stars = d->stars->prepend(p); return d; ]
  -> d:DirectTypedefDeclarator
       [ return d; ]
}

nonterm[IDeclarator*] DirectTypedefDeclarator {
  -> n:PQName [
       // TYPE/NAME
       D("defined new typedef name " << n->name);
       addType(n);
       return new D_name(loc, n);
     ]

  -> d:DirectTypedefDeclarator
     "(" args:ParameterDeclarationClause ")"
     cv:CVQualifierSeqOpt
     e:ExceptionSpecificationOpt
       [ return new D_func(loc, d, args, cv, e); ]

  -> d:DirectTypedefDeclarator "[" sz:ConstantExpressionOpt "]"
       [ return new D_array(d, sz); ]

  -> "(" d:TypedefDeclarator ")"
       [ return d; ]
}


// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
nonterm[ASTTypeId*] TypeId {
  -> spec:TypeSpecifier decl:AbstractDeclaratorOpt
       [ return new ASTTypeId(spec, new Declarator(decl, NULL)); ]

  // gnu extension
  //-> "__typeof__" "(" e:Expression ")" ;
}

nonterm[IDeclarator*] AbstractDeclaratorOpt {
  -> empty                 [ return new D_name(loc, NULL); ]
  -> d:AbstractDeclarator  [ return d; ]
}

// an abstract declarator (not opt) must have *some* ground syntax in it
nonterm[IDeclarator*] AbstractDeclarator {
  -> p:PtrOperator d:AbstractDeclaratorOpt
       [ d->stars = d->stars->prepend(p); return d; ]

  -> d:DirectAbstractDeclarator
       [ return d; ]
}

nonterm[IDeclarator*] DirectAbstractDeclaratorOpt {
  -> empty                       [ return new D_name(loc, NULL /*name*/); ]
  -> d:DirectAbstractDeclarator  [ return d; ]
}

// this also must have some ground syntax
nonterm[IDeclarator*] DirectAbstractDeclarator {
  // note: the "opt" in the DirectAbstractDeclarator part of the
  // function type constructor creates an ambiguity:
  //   typedef int x;
  //   int foo(int (x));
  // is the argument an int, or a function accepting an 'x'?
  // My understanding is, to resolve this we use the "if it can be 
  // a declarator than it is" rule, but I don't actually know how
  // to apply that rule..
  
  // HACK: will remove "opt" for now...
  // TODO: find out how to correctly resolve the ambiguity, put "opt"
  // back in and implement that resolution

  // function
  -> d:DirectAbstractDeclarator/*Opt*/
     "(" args:ParameterDeclarationClause ")"
     cv:CVQualifierSeqOpt
     e:ExceptionSpecificationOpt
       [ return new D_func(loc, d, args, cv, e); ]

  // array with optional size
  -> d:DirectAbstractDeclaratorOpt "[" sz:ConstantExpressionOpt "]"
       [ return new D_array(d, sz); ]

  // precedence grouping
  -> "(" d:AbstractDeclarator ")"
       [ return d; ]
}


nonterm[FakeList<ASTTypeId>*] ParameterDeclarationClause {
  -> p:ParameterDeclarationList              // some args
       [ return p; ]
  -> empty                                   // no args
       [ return FakeList<ASTTypeId>::emptyList(); ]
}

// little bending over backwards here to accomodate FakeList
nonterm[FakeList<ASTTypeId>*] ParameterDeclarationList {
  // last (and perhaps only) arg is "..."
  -> "..."
       [ return FakeList<ASTTypeId>::makeList(ellipsisTypeId()); ]

  // last arg is "...", and 2nd-to-last is not separated by
  // a comma from the "..."
  -> d:ParameterDeclaration "..."
       [ FakeList<ASTTypeId> *list =
           FakeList<ASTTypeId>::makeList(ellipsisTypeId());
         return list->prepend(d); ]

  // last arg is not "..."
  -> d:ParameterDeclaration
       [ return FakeList<ASTTypeId>::makeList(d); ]

  // argument then "," then arg or "..." or list
  -> d:ParameterDeclaration "," list:ParameterDeclarationList
       [ return list->prepend(d); ]
}

nonterm[ASTTypeId*] ParameterDeclaration {
  -> RegisterOpt s:TypeSpecifier d:Declarator
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> RegisterOpt s:TypeSpecifier d:Declarator "=" e:AssignmentExpression
       [ return new ASTTypeId(s, new Declarator(d, new IN_expr(e))); ]

  -> RegisterOpt s:TypeSpecifier d:AbstractDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> RegisterOpt s:TypeSpecifier d:AbstractDeclarator "=" e:AssignmentExpression
       [ return new ASTTypeId(s, new Declarator(d, new IN_expr(e))); ]
}

// old code uses the keyword "register" in the parameter declarations, but I
// will ignore it when that happens (because my AST has no place to put it)
nonterm RegisterOpt {
  -> empty;
  -> "register";
}


// -- function definition --
nonterm[Function*] FunctionDefinition {
  // whereas the std merges c/dtors and ordinary functions by making
  // the DeclSpecifier optional, I split cases; this way in the common
  // case where I can clearly see a return type, ctor is ruled out;
  // in fact I wonder if there will ever be an ambiguity, since ordinary
  // functions always have at least two words before "(" while ctors
  // always have just one..

  // ordinary function:
  // return type      name/params   body
  -> r:DeclSpecifier  d:Declarator  b:FunctionBody
       [
         Function *ret = new Function(
           r->dflags,                // decl flags (static, extern, etc.)
           r->spec,                  // type specifier for return value
           new Declarator(d, NULL),  // declarator with fn name, params
           NULL,                     // ctor member inits
           b,                        // function body statement
           NULL                      // exception handlers
         );
         r->spec = NULL;    // stole it above (ownership transfer)
         delete r;          // was just a carrier of dflags/spec
         return ret;
       ]

  // constructor, destructor or conversion operator
  // "explicit"?    name/params   member inits          body
  -> e:ExplicitOpt  d:Declarator  c:CtorInitializerOpt  b:FunctionBody
       [
         return new Function(
           e,                        // decl flags: explicit is only possibility
           new TS_simple(ST_CDTOR),  // type specifier: ctor or dtor
           new Declarator(d, NULL),  // declarator with fn name, params
           c,                        // ctor member inits
           b,                        // function body statement
           NULL                      // exception handlers
         );
       ]

  // ctor with a try block
  // "explicit"?   name/params        member inits         body           handlers
  -> e:ExplicitOpt d:Declarator "try" c:CtorInitializerOpt b:FunctionBody h:HandlerSeq
       [
         return new Function(
           e,                        // decl flags: explicit is only possibility
           new TS_simple(ST_CDTOR),  // type specifier: ctor or dtor
           new Declarator(d, NULL),  // declarator with fn name, params
           c,                        // ctor member inits
           b,                        // function body statement
           h                         // exception handlers
         );
       ]
}

nonterm[S_compound*] FunctionBody -> s:CompoundStatement
  [ return s; ]

nonterm[DeclFlags] ExplicitOpt {
  -> "explicit"    [ return DF_EXPLICIT; ]
  -> empty         [ return DF_NONE; ]
}

nonterm[FakeList<MemberInit>*] CtorInitializerOpt {
  -> empty                        [ return FakeList<MemberInit>::emptyList(); ]
  -> ":" list:MemInitializerList  [ return list; ]
}


// ------ A.8 Classes ------
nonterm[TS_classSpec*] ClassSpecifier ->
  k:ClassKey n:ClassNameOpt b:BaseClauseOpt
    "{" memb:MemberDeclarationSeqOpt "}"
  [
    return new TS_classSpec(loc, k, n, b, memb);
  ]

nonterm[StringRef] ClassNameOpt {
  -> empty     [ return NULL; ]
  -> n:AnyName [
       //declareClassTag(n);   // wrong type.. whatever
       return n;
     ]
}

nonterm[enum TypeIntr] ClassKey {
  -> "class"       [ return TI_CLASS; ]
  -> "struct"      [ return TI_STRUCT; ]
  -> "union"       [ return TI_UNION; ]
}


// I'm using an encapsulated ASTList to avoid right recursion,
// since there are often many members of classes
nonterm[MemberList*] MemberDeclarationSeqOpt {
  -> empty
       [ return new MemberList(NULL); ]

  -> list:MemberDeclarationSeqOpt decl:MemberDeclaration
       [ list->list.append(decl); return list; ]

  // explicitly include access specifiers in the AST, instead of
  // propagating them in the parser, to avoid the complexities of
  // maintaining the state in the parser context
  -> list:MemberDeclarationSeqOpt k:AccessSpecifier ":"
       [ list->list.append(new MR_access(k)); return list; ]
}

nonterm[AccessKeyword] AccessSpecifier {
  -> "public"     [ return AK_PUBLIC; ]
  -> "private"    [ return AK_PRIVATE; ]
  -> "protected"  [ return AK_PROTECTED; ]
}

nonterm SemicolonOpt {
  -> empty ;
  -> ";" ; 
}

nonterm[Member*] MemberDeclaration {
  // member fn decl, or data member
  -> spec:DeclSpecifier list:MemberDeclaratorList ";"
       [ spec->decllist = list; 
         return new MR_decl(AK_UNSPECIFIED, spec); ]

  // inline function definition; includes c/dtor definitions
  -> f:FunctionDefinition SemicolonOpt
       [ return new MR_func(AK_UNSPECIFIED, f); ]
  
  // declaration (with no definition) of a c/dtor or conversion
  // operator function                                         
  // Q: what about pure virtual?
  // A: it's part of the MemberDeclarator
  -> e:ExplicitOpt v:VirtualOpt d:MemberDeclarator ";"
       [ // 'd' is a Declarator
         DeclFlags flags = (DeclFlags)( e | (v? DF_VIRTUAL : DF_NONE) );
         return new MR_decl(
           AK_UNSPECIFIED,
           new Declaration(
             flags,
             new TS_simple(ST_CDTOR),
             FakeList<Declarator>::makeList(d)
           )
         );
       ]

  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

nonterm[FakeList<Declarator>*] MemberDeclaratorList {
  -> d:MemberDeclarator
       [ return FakeList<Declarator>::makeList(d); ]
  -> d:MemberDeclarator "," list:MemberDeclaratorList
       [ return list->prepend(d); ]
}

// this returns a full Declarator, instead of an IDeclarator, because
// the grammar doesn't nest MemberDeclarators, and because that way I
// have a place to return the "=0" of a pure virtual function, and also
// a place to put member initializers
nonterm[Declarator*] MemberDeclarator {
  -> d:Declarator
       [ return new Declarator(d, NULL /*init*/); ]

  // here I merge two cases (PureSpecifier and ConstantInitializer) that
  // the std splits; given that the parser doesn't track at this level
  // whether 'd' is a function type or not, and it can't tell the
  // difference between PureSpecifier and ConstantInitializer just by
  // looking at their syntax, we'd be disambiguating this later anyway
  -> d:Declarator "=" e:ConstantExpression     // pure, and member inits
       [ return new Declarator(d, new IN_expr(e)); ]

  -> n:AnyNameOpt ":" e:ConstantExpression     // bitfield
       [ return new Declarator(new D_bitfield(n, e), NULL /*init*/); ]
}

nonterm[StringRef] AnyNameOpt {
  -> empty      [ return NULL; ]
  -> n:AnyName  [ return n; ]
}


// ------ A.9 Derived classes ------
nonterm[FakeList<BaseClass>*] BaseClauseOpt {
  -> empty                      [ return FakeList<BaseClass>::emptyList(); ]
  -> ":" b:BaseSpecifierList    [ return b; ]
}

nonterm[FakeList<BaseClass>*] BaseSpecifierList {
  -> b:BaseSpecifier
       [ return FakeList<BaseClass>::makeList(b); ]
  -> b:BaseSpecifier "," list:BaseSpecifierList
       [ return list->prepend(b); ]
}


nonterm[BaseClass*] BaseSpecifier {
  -> v:VirtualOpt a:AccessSpecifierOpt n:PQClassName
       [ return new BaseClass(v, a, n); ]
}

nonterm[bool] VirtualOpt {
  -> empty      [ return false; ]
  -> "virtual"  [ return true; ]
}

// if the access specifier is missing, then it defaults to private
// when inherited by a class, and public when inherited by a struct;
// typechecking will replace AK_UNSPECIFIED with the right thing later
nonterm[AccessKeyword] AccessSpecifierOpt {
  -> empty              [ return AK_UNSPECIFIED; ]
  -> k:AccessSpecifier  [ return k; ]
}

nonterm[PQName*] PQClassName {
  -> n:TypeName                   [ return new PQName(n); ]
  -> q:Qualifier rhs:PQClassName  [ rhs->prependQualifier(q); return rhs; ]
}


// ------ A.10 Special member functions ------
nonterm[OperatorDeclarator*] ConversionFunctionId {
  -> "operator" t:ConversionTypeId  [ return new OD_conversion(t); ]
}

nonterm[ASTTypeId*] ConversionTypeId {
  -> s:TypeSpecifier d:ConversionDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
}

// collects the stars that might follow a type specifier in a
// conversion function (for converting to pointer type)
nonterm[IDeclarator*] ConversionDeclaratorOpt {
  -> empty                                    
       [ return new D_name(loc, NULL /*name*/); ]
  -> p:PtrOperator d:ConversionDeclaratorOpt  
       [ d->stars = d->stars->prepend(p); return d; ]
}


nonterm[FakeList<MemberInit>*] MemInitializerList {
  -> i:MemInitializer
       [ return FakeList<MemberInit>::makeList(i); ]
  -> i:MemInitializer "," list:MemInitializerList
       [ return list->prepend(i); ]
}

nonterm[MemberInit*] MemInitializer {
  -> n:MemInitializerId "(" e:ExpressionListOpt ")"
       [ return new MemberInit(n, e); ]
}

// the std splits cases on whether we're calling a base class ctor
// or initializing a field; I'll simply call both a PQName, and
// then in typechecking make sure that the latter case does not
// have any qualifiers (because in most cases the parser can't make
// the distinction so it would fall to typechecking anyway)
nonterm[PQName*] MemInitializerId {
  -> n:PQName  [ return n; ]
}


// ------ A.11 Overloading ------
nonterm[OperatorDeclarator*] OperatorFunctionId {
  -> "operator" od:Operator  [ return od; ]
}

// this nonterm is only used in the OperatorFunctionId context,
// so go ahead and have it return a full OperatorDeclarator
nonterm[OperatorDeclarator*] Operator {
  -> "new"             [ return new OD_newDel(true /*isNew*/, false /*isArray*/); ]
  -> "delete"          [ return new OD_newDel(false, false); ]
  -> "new" "[" "]"     [ return new OD_newDel(true, true); ]
  -> "delete" "[" "]"  [ return new OD_newDel(false, true); ]

  -> "*"  [ return new OD_binary(BIN_MULT); ]
  -> "/"  [ return new OD_binary(BIN_DIV); ]
  -> "%"  [ return new OD_binary(BIN_MOD); ]
  -> "+"  [ return new OD_binary(BIN_PLUS); ]
  -> "-"  [ return new OD_binary(BIN_MINUS); ]
  -> "<<" [ return new OD_binary(BIN_LSHIFT); ]
  -> ">>" [ return new OD_binary(BIN_RSHIFT); ]
  -> "<"  [ return new OD_binary(BIN_LESS); ]
  -> ">"  [ return new OD_binary(BIN_GREATER); ]
  -> "<=" [ return new OD_binary(BIN_LESSEQ); ]
  -> ">=" [ return new OD_binary(BIN_GREATEREQ); ]
  -> "==" [ return new OD_binary(BIN_EQUAL); ]
  -> "!=" [ return new OD_binary(BIN_NOTEQUAL); ]
  -> "&"  [ return new OD_binary(BIN_BITAND); ]
  -> "^"  [ return new OD_binary(BIN_BITXOR); ]
  -> "|"  [ return new OD_binary(BIN_BITOR); ]
  -> "&&" [ return new OD_binary(BIN_AND); ]
  -> "||" [ return new OD_binary(BIN_OR); ]

  -> op:AssignmentOperator  [ return new OD_assign(op); ]

  -> "!"  [ return new OD_unary(UNY_NOT); ]
  -> "~"  [ return new OD_unary(UNY_BITNOT); ]

  -> "++" [ return new OD_effect(EFF_PREINC); ]
  -> "--" [ return new OD_effect(EFF_PREDEC); ]

  -> ","     [ return new OD_overload(OVL_COMMA); ]
  -> "->"    [ return new OD_overload(OVL_ARROW); ]
  -> "(" ")" [ return new OD_overload(OVL_PARENS); ]
  -> "[" "]" [ return new OD_overload(OVL_BRACKETS); ]
}


// ------ A.12 Templates ------
//TemplateParameterList -> TemplateParameter
//TemplateParameterList -> TemplateParameterList "," TemplateParameter

//TemplateParameter -> TypeParameter | ParameterDeclaration


nonterm TemplateId {
  -> TypeName "<" TemplateArgumentList ">" ;
  -> TypeName "<" ">" ;
}

nonterm TemplateArgumentList {
  -> TemplateArgument ;
  -> TemplateArgumentList "," TemplateArgument ;
}

nonterm TemplateArgument {
  // where I have Literal the std has AssignmentExpression...
  // std also mentions IdExpression here, which is my PQVarName.....
  -> Literal ;
  -> TypeId ;
}


// ------ A.13 Exception handling ------
nonterm[S_try*] TryBlock {
  -> "try" s:CompoundStatement h:HandlerSeq  [ return new S_try(loc, s, h); ]
}

nonterm[FakeList<Handler>*] HandlerSeq {
  -> h:Handler                 [ return FakeList<Handler>::makeList(h); ]
  -> h:Handler seq:HandlerSeq  [ return seq->prepend(h); ]
}

nonterm[Handler*] Handler {
  -> "catch" "(" d:HandlerParameter ")" s:CompoundStatement
       [ return new HR_type(s, d); ]

  -> "catch" "(" "..." ")" s:CompoundStatement
       [ return new HR_default(s); ]
}

nonterm[ASTTypeId*] HandlerParameter {
  -> s:TypeSpecifier d:Declarator
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
  -> s:TypeSpecifier d:AbstractDeclaratorOpt
       [ return new ASTTypeId(s, new Declarator(d, NULL /*init*/)); ]
}


nonterm[E_throw*] ThrowExpression {
  -> "throw"                         [ return new E_throw(NULL); ]
  -> "throw" e:AssignmentExpression  [ return new E_throw(e); ]
}


nonterm[ExceptionSpec*] ExceptionSpecificationOpt {
  -> empty                            
       [ return NULL; ]
  -> "throw" "(" ")"                  
       [ return new ExceptionSpec(FakeList<ASTTypeId>::emptyList()); ]
  -> "throw" "(" list:TypeIdList ")"
       [ return new ExceptionSpec(list); ]
}

nonterm[FakeList<ASTTypeId>*] TypeIdList {
  -> t:TypeId                      [ return FakeList<ASTTypeId>::makeList(t); ]
  -> t:TypeId "," list:TypeIdList  [ return list->prepend(t); ]
}
