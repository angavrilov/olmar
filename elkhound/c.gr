# c.gr
# my attempt to implement a grammar for C

# I'm working from the C++ spec, and will write down
# the parts that are in C


# start symbol
StartSymbol -> TranslationUnit $


# ---------------- tokens ----------------------------
# for now I'm just giving a few example members of the
# token sets, and delaying adding a real lexer
Identifier -> a | b | c | f | foo | x | y | z
#StringLiteral -> "foo" | "bar"	     # small issue about Bison output..
StringLiteral -> iAmAString
IntegerLiteral -> 0 | 1 | 2 | 3
Literal -> IntegerLiteral | StringLiteral


# ------------- identifier ambiguity -------------------
# identifiers can play a number of roles, and this is the
# source of problems parsing C and C++
# (here, "variable" means variable or function; it names
# an object that exists at runtime)
TypedefName -> Identifier
EnumName -> Identifier
EnumValueName -> Identifier      # called 'enumerator' in spec
StructName -> Identifier
VariableName -> Identifier
LabelName -> Identifier


# ---------------- higher-level syntax -----------------
# ------ A.3 Basic Concepts ------
TranslationUnit -> empty | Declaration TranslationUnit

# ------ A.4 Expressions ------
PrimaryExpression -> Literal | this | ( Expression ) | VariableName

PostfixExpression -> PrimaryExpression
PostfixExpression -> PostfixExpression [ Expression ]          # array
PostfixExpression -> PostfixExpression ( ExpressionList )      # fn call
PostfixExpression -> PostfixExpression . VariableName          # field access
PostfixExpression -> PostfixExpression -> VariableName         # deref + field access
PostfixExpression -> PostfixExpression ++
PostfixExpression -> PostfixExpression --

ExpressionList -> AssignmentExpression | ExpressionList , AssignmentExpression

UnaryExpression -> PostfixExpression
UnaryExpression -> ++ CastExpression
UnaryExpression -> -- CastExpression
UnaryExpression -> UnaryOperator CastExpression
UnaryExpression -> sizeof UnaryExpression         # size of expression
UnaryExpression -> sizeof ( TypeId )              # size of type

UnaryOperator -> * | & | + | - | ! | ~

CastExpression -> UnaryExpression | ( TypeId ) CastExpression

# here I plan to apply operator precedence and associativity disambiguation
BinaryExpression -> CastExpression
BinaryExpression -> BinaryExpression BinaryOperator BinaryExpression

# all of these operators have left-to-right associativity
# this end has highest precedence
BinaryOperator -> * | / | %
BinaryOperator -> + | -
BinaryOperator -> << | >>
BinaryOperator -> < | > | <= | >=      # association here might trigger warning..
BinaryOperator -> == | !=
BinaryOperator -> &
BinaryOperator -> ^
BinaryOperator -> bitor                # (syntax clash)
BinaryOperator -> &&
BinaryOperator -> ||
# this end has lowest precedence

ConditionalExpression -> BinaryExpression
ConditionalExpression -> BinaryExpression ? Expression : AssignmentExpression

# why is conditional not allowed on left side of = ?  can I confirm
# that in another language spec?  clearly both alternatives would have
# to be like-typed lvalues, but...
AssignmentExpression -> ConditionalExpression
AssignmentExpression -> BinaryExpression AssignmentOperator AssignmentExpression

AssignmentOperator -> = | *= | /= | %= | += | -= | >>= | <<= | &= | ^= | |=
                                               
# this is the same definition as ExpressionList, and perhaps it
# makes sense to collapse them?  the meaning of ',' is quite 
# different in the two cases.. does that matter?
Expression -> AssignmentExpression | Expression , AssignmentExpression
ExpressionOpt -> empty | Expression

# this is an expression with the additional requirement that
# it be entirely evaluatable at compile time
ConstantExpression -> ConditionalExpression

# ------ A.5 Statements ------
# labeled-statement
Statement -> LabelName : Statement
Statement -> case ConstantExpression : Statement
Statement -> default : Statement

# expression-statement
Statement -> ExpressionStatement
ExpressionStatement -> Expression ; | ;

# compound-statement
Statement -> CompoundStatement
CompoundStatement -> { StatementSeqOpt }
StatementSeqOpt -> empty | StatementSeqOpt Statement

# selection-statement
Statement -> if ( Condition ) Statement
Statement -> if ( Condition ) Statement else Statement      # preferred when ambiguous
Statement -> switch ( Condition ) Statement

Condition -> Expression
Condition -> TypeSpecifierSeq Declarator = AssignmentExpression
ConditionOpt -> empty | Condition

# iteration-statement
Statement -> while ( Condition ) Statement
Statement -> do Statement while ( Expression ) ;

# I might like to rework this so both semicolons appear here instead
# of buried in ForInitStatement.  this is also a good rule to use
# inline alternatives
Statement -> for ( ForInitStatement ConditionOpt ; ExpressionOpt ) Statement
ForInitStatement -> ExpressionStatement | SimpleDeclaration

# jump-statement
Statement -> break ;
Statement -> continue ;
Statement -> return Expression ;
Statement -> return ;
Statement -> goto LabelName ;

# declaration-statement
Statement -> BlockDeclaration

# ----- A.6 Declarations ------
DeclarationSeqOpt -> empty | DeclarationSeqOpt Declaration

Declaration -> BlockDeclaration
Declaration -> FunctionDefinition
Declaration -> LinkageSpecification

BlockDeclaration -> SimpleDeclaration      # C++ has other alternatives..

# is the DeclSpecifierSeq optional for implicit-int??
#   no, it's for constructors, destructors, and conversion operators,
#   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
# ok, why is the InitDeclaratorList optional?
SimpleDeclaration -> DeclSpecifierSeq InitDeclaratorListOpt ;

# specifier: the "int" in a declaration like "int x"
DeclSpecifier -> StorageClassSpecifier
DeclSpecifier -> TypeSpecifier
DeclSpecifier -> typedef

DeclSpecifierSeq -> DeclSpecifier | DeclSpecifierSeq DeclSpecifier

StorageClassSpecifier -> auto | register | static | extern

TypeSpecifier -> SimpleTypeSpecifier
TypeSpecifier -> ClassSpecifier
TypeSpecifier -> EnumSpecifier
TypeSpecifier -> CVQualifier

SimpleTypeSpecifier -> char | wchar_t | short | int | long | signed
SimpleTypeSpecifier -> unsigned | float | double | void
SimpleTypeSpecifier -> TypedefName    # this is the tough one!

EnumSpecifier -> enum { EnumeratorListOpt }
EnumSpecifier -> enum EnumName { EnumeratorListOpt }

EnumeratorList -> EnumeratorDefinition
EnumeratorList -> EnumeratorList , EnumeratorDefinition
EnumeratorListOpt -> empty | EnumeratorList

EnumeratorDefinition -> EnumValueName
EnumeratorDefinition -> EnumValueName = ConstantExpression

AsmDefinition -> asm ( StringLiteral ) ;

LinkageSpecification -> extern StringLiteral { DeclarationSeqOpt }
LinkageSpecification -> extern StringLiteral Declaration

# ------ A.7 Declarators ------
# -- declarator --
# declarator: the "x" in a declaration like "int x"

InitDeclaratorList -> InitDeclarator
InitDeclaratorList -> InitDeclaratorList , InitDeclarator
InitDeclaratorListOpt -> empty | InitDeclaratorList

InitDeclarator -> Declarator                    # (int)  x
InitDeclarator -> Declarator Initializer        # (int)  x = 5

# C++ has something here for constructors
Initializer -> = InitializerClause

InitializerClause -> AssignmentExpression       # scalar
InitializerClause -> { InitializerList }        # array initializer
InitializerClause -> { InitializerList , }      # useful syntactic quirk
InitializerClause -> { }                        # ?  does this mean the array is zeroed?

InitializerList -> InitializerClause
InitializerList -> InitializerList , InitializerClause


# (PtrOperator)* DirectDeclarator
Declarator -> PtrOperator Declarator | DirectDeclarator

DirectDeclarator -> VariableName     # this is for declarators
#DirectDeclarator -> empty            # this is for type-ids  REMOVED
DirectDeclarator -> DirectDeclarator ( ParameterDeclarationClause ) CVQualifierSeqOpt  # fn
  #                 ^^ name of fn ^^   ^^^^^^^ arguments ^^^^^^^^   ^^^^ const? ^^^^^
  # the return type comes from the type specifier that preceeds this
DirectDeclarator -> DirectDeclarator [ ConstantExpression ]      # array of specified size
DirectDeclarator -> DirectDeclarator [ ]                         # array of unspecified size
DirectDeclarator -> ( Declarator )                               # precedence grouping

# C++ has more alternatives
PtrOperator -> * CVQualifierSeqOpt

CVQualifierSeqOpt -> empty | CVQualifier CVQualifierSeqOpt

CVQualifier -> const | volatile

# -- type-id --
# a type-id is like a declaration of one thing, but without the variable name;
# it is, for example, what appears inside the parens of a typecast
TypeId -> TypeSpecifierSeq AbstractDeclarator

TypeSpecifierSeq -> TypeSpecifier | TypeSpecifier TypeSpecifierSeq

# I'm modifying the C++ grammar to more directly reflect that type-ids are
# essentially declarators; this way, my code can have a fn to analyze a
# DirectDeclarator and yield a type and optionally a name; the name is for
# declarators and no-name is for type-ids
#AbstractDeclarator -> DirectDeclarator

# this introduces extra ambiguities (like "int (x)" -- integer or fn with
# name omitted?), so I'm going to back to a duplicated structure
AbstractDeclarator -> PtrOperator AbstractDeclarator | DirectAbstractDeclarator

DirectAbstractDeclarator -> empty            # this is for type-ids
DirectAbstractDeclarator -> DirectAbstractDeclarator ( ParameterDeclarationClause ) CVQualifierSeqOpt  # fn
DirectAbstractDeclarator -> DirectAbstractDeclarator [ ConstantExpression ]      # array of specified size
DirectAbstractDeclarator -> DirectAbstractDeclarator [ ]                         # array of unspecified size
DirectAbstractDeclarator -> ( AbstractDeclarator )                               # precedence grouping


# -- parameters in declarations --
ParameterDeclarationClause -> ParameterDeclarationList          # some args
ParameterDeclarationClause -> empty                             # no args
ParameterDeclarationClause -> ParameterDeclarationList ...      # args plus optionally more
ParameterDeclarationClause -> ParameterDeclarationList , ...    # same; alternative syntax
ParameterDeclarationClause -> ...                               # all args are optional

ParameterDeclarationList -> ParameterDeclaration
ParameterDeclarationList -> ParameterDeclarationList , ParameterDeclaration

# here's a place my abstract-declarator = declarator stuff pays off; the
# original spec had four alternatives, since parameters don't have to be
# named
# UPDATE: but now I've split them...
ParameterDeclaration -> DeclSpecifierSeq Declarator
ParameterDeclaration -> DeclSpecifierSeq Declarator = AssignmentExpression
ParameterDeclaration -> DeclSpecifierSeq AbstractDeclarator
ParameterDeclaration -> DeclSpecifierSeq AbstractDeclarator = AssignmentExpression


# -- function definition --
FunctionDefinition -> DeclSpecifierSeq Declarator  FunctionBody
  #                   return type      name/params body

FunctionBody -> CompoundStatement


# ------ A.8 Classes ------
# I'm going to use the "class" terminology throughout, even though
# C only has "struct" and "union"
ClassSpecifier -> ClassHead { MemberSpecificationSeqOpt }

ClassHead -> ClassKeyword Identifier
ClassHead -> ClassKeyword

ClassKeyword -> class | struct | union

MemberSpecificationSeqOpt -> empty | MemberSpecification MemberSpecificationSeqOpt

MemberSpecification -> DeclSpecifierSeq MemberDeclaratorListOpt ;    # why opt?
MemberSpecification -> FunctionDefinition ;
MemberSpecification -> FunctionDefinition      # syntactic tweak

MemberDeclaratorListOpt -> empty | MemberDeclaratorListOpt , MemberDeclarator

MemberDeclarator -> Declarator
MemberDeclarator -> Declarator = ConstantExpression    # pure; and member inits??


