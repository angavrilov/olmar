// absval.ast
// abstract domain values

verbatim {
  #include "strtable.h"     // StringRef
  #include "cc_flags.h"     // UnaryOp, BinaryOp

  class stringBuilder;      // str.h
}

class AbsValue {
  pure_virtual void toSexp(stringBuilder &sb) const;

  // logic variable: unknown but definite integer value;
  // 'why' states what this variable stands for, or why it was created
  -> AVvar(StringRef name, string why);

  // literal integer
  -> AVint(int i);

  // arithmetic expressions built-in to the C language
  -> AVunary(UnaryOp op, AbsValue val);
  -> AVbinary(AbsValue v1, BinaryOp op, AbsValue v2);
  -> AVcond(AbsValue cond, AbsValue th, AbsValue el);

  // function symbols, variously interpreted
  -> AVfunc(StringRef func, ASTList<AbsValue> args);
}

verbatim {
  // some syntactic sugar
  AVfunc *avFunc1(StringRef func, AbsValue *a1);
  AVfunc *avFunc2(StringRef func, AbsValue *a1, AbsValue *a2);
  AVfunc *avFunc3(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3);
  AVfunc *avFunc4(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4);
  AVfunc *avFunc5(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4, AbsValue *a5);
  AVunary *avNot(AbsValue *v);

  // visitor interface
  class AbsValueVisitor {
  public:
    // return true to continue recursing or false to stop visiting children
    virtual bool visitAbsValue(AbsValue const *value);
  };

  void walkAbsValue(AbsValueVisitor &vis, AbsValue const *value);
}


// ------------------- implementation ----------------
impl_verbatim {
  #include "str.h"          // stringBuilder

  void AVvar::toSexp(stringBuilder &sb) const
  {
    sb << (char const*)name;
  }

  void AVint::toSexp(stringBuilder &sb) const
  {
    sb << i;
  }

  void AVunary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "++", "--", "++", "--", "sizeof",    // should not be used
      "uPlus",
      "uMinus",
      "uNot",
      "uBitNot"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_UNARYOPS);

    if (op < UNY_PLUS) {
      cout << "warning: emitting sexp for " << unaryOpNames[op] << endl;
    }

    sb << "(" << names[op] << " ";
    val->toSexp(sb);
    sb << ")";
  }

  void AVbinary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "bEqual",
      "bNotEqual",
      "bLess",
      "bGreater",
      "bLessEq",
      "bGreaterEq",

      "*",       // the three interpreted symbols are special
      "bDiv",
      "bMod",
      "+",
      "-",
      "bLShift",
      "bRShift",
      "bBitAnd",
      "bBitXor",
      "bBitOr",
      "bAnd",
      "bOr",

      "bImplies"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_BINARYOPS);

    sb << "(" << names[op] << " ";
    v1->toSexp(sb);
    sb << " ";     
    v2->toSexp(sb);
    sb << ")";
  }

  void AVcond::toSexp(stringBuilder &sb) const
  {
    sb << "(ifThenElse ";
    cond->toSexp(sb);
    sb << " ";
    th->toSexp(sb);
    sb << " ";
    el->toSexp(sb);
    sb << ")";
  }

  void AVfunc::toSexp(stringBuilder &sb) const
  {
    sb << "(" << func;
    FOREACH_ASTLIST(AbsValue, args, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }
  
  
  // ------------ syntactic sugar ----------------
  AVfunc *avFunc1(StringRef func, AbsValue *a1)
  {
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc2(StringRef func, AbsValue *a1, AbsValue *a2)
  {
    xassert(a1 && a2);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc3(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3)
  {
    xassert(a1 && a2 && a3);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc4(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4)
  {
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a4);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc5(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4, AbsValue *a5)
  {
    xassert(a1 && a2 && a3);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a5);
    f->args.prepend(a4);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVunary *avNot(AbsValue *v)
  {
    return new AVunary(UNY_NOT, v);
  }

  // ------------- visitor ---------------
  bool AbsValueVisitor::visitAbsValue(AbsValue const *value)
  {
    return true;
  }

  void walkAbsValue(AbsValueVisitor &vis, AbsValue const *value)
  {
    if (!vis.visitAbsValue(value)) {
      return;
    }

    ASTSWITCHC(AbsValue, value) {
      ASTCASEC(AVunary, u) {
        walkAbsValue(vis, u->val);
      }

      ASTNEXTC(AVbinary, b) {
        walkAbsValue(vis, b->v1);
        walkAbsValue(vis, b->v2);
      }

      ASTNEXTC(AVcond, c) {
        walkAbsValue(vis, c->cond);
        walkAbsValue(vis, c->th);
        walkAbsValue(vis, c->el);
      }

      ASTNEXTC(AVfunc, f) {
        FOREACH_ASTLIST(AbsValue, f->args, iter) {
          walkAbsValue(vis, iter.data());
        }
      }

      ASTENDCASECD
    }
  }
}
