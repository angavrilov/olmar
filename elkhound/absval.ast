// absval.ast
// abstract domain values

verbatim {                     
  #include "strtable.h"     // StringRef
  #include "cc_flags.h"     // UnaryOp, BinaryOp
  
  class stringBuilder;      // str.h
}

class IntValue {
  pure_virtual void toSexp(stringBuilder &sb) const;

  // logic variable: unknown but definite integer value;
  // 'why' states what this variable stands for, or why it was created
  -> IVvar(StringRef name, string why);

  // literal integer
  -> IVint(int i);

  // arithmetic expressions built-in to the C language
  -> IVunary(UnaryOp op, IntValue val);
  -> IVbinary(IntValue v1, BinaryOp op, IntValue v2);
  -> IVcond(IntValue cond, IntValue th, IntValue el);

  // function symbols, variously interpreted
  -> IVfunc(StringRef func, ASTList<IntValue> args);
}


impl_verbatim {
  #include "str.h"          // stringBuilder

  void IVvar::toSexp(stringBuilder &sb) const
  {
    sb << (char const*)name;
  }

  void IVint::toSexp(stringBuilder &sb) const
  {
    sb << i;
  }

  void IVunary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "++", "--", "++", "--", "sizeof",    // should not be used
      "uPlus",
      "uMinus",
      "uNot",
      "uBitNot"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_UNARYOPS);

    if (op < UNY_PLUS) {
      cout << "warning: emitting sexp for " << unaryOpNames[op] << endl;
    }

    sb << "(" << names[op] << " ";
    val->toSexp(sb);
    sb << ")";
  }

  void IVbinary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "bEqual",
      "bNotEqual",
      "bLess",
      "bGreater",
      "bLessEq",
      "bGreaterEq",

      "*",       // the three interpreted symbols are special
      "bDiv",
      "bMod",
      "+",
      "-",
      "bLShift",
      "bRShift",
      "bBitAnd",
      "bBitXor",
      "bBitOr",
      "bAnd",
      "bOr",

      "bImplies"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_BINARYOPS);

    sb << "(" << names[op] << " ";
    v1->toSexp(sb);
    sb << " ";     
    v2->toSexp(sb);
    sb << ")";
  }

  void IVcond::toSexp(stringBuilder &sb) const
  {
    sb << "(ifThenElse ";
    cond->toSexp(sb);
    sb << " ";
    th->toSexp(sb);
    sb << " ";
    el->toSexp(sb);
    sb << ")";
  }

  void IVfunc::toSexp(stringBuilder &sb) const
  {
    sb << "(" << func;
    FOREACH_ASTLIST(IntValue, args, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }
}
