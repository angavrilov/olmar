// absval.ast
// abstract domain values

// NOTE: I have not worked out a deallocation strategy, so you should
// *never* try to deallocate these!

verbatim {
  #include "strtable.h"     // StringRef
  #include "cc_flags.h"     // UnaryOp, BinaryOp
  #include "variable.h"     // Variable

  class stringBuilder;      // str.h
}

class AbsValue {
  pure_virtual void toSexp(stringBuilder &sb) const;
  public string toString() const;    // calls toSexp
  //private ~AbsValue();      // don't call me! (astgen doesn't quite work with this..)

  // ---------------- general-purpose ----------------
  // logic variable: unknown but definite integer value;
  // 'why' states what this variable stands for, or why it was created
  -> AVvar(StringRef name, string why);

  // literal integer
  -> AVint(int i);

  // arithmetic expressions built-in to the C language
  -> AVunary(UnaryOp op, AbsValue val);
  -> AVbinary(AbsValue v1, BinaryOp op, AbsValue v2);
  -> AVcond(AbsValue cond, AbsValue th, AbsValue el);

  // function symbols, variously interpreted
  -> AVfunc(StringRef func, ASTList<AbsValue> args);

  // --------------- symbolic addresses (lvalues) -------------
  // symbolic address: tells me where in the symbolic register file
  // to find the value, and update it if necessary; NOTE: Simplify
  // never sees these--they must be translated away before giving
  // them to the theorem prover; typically, these are yielded by
  // lvalues
  -> AVlval(Variable const *progVar,    // which register has the value
            AbsValue offset);           // sequence of 'sub' nodes

  // a symbolic subscript; could have an array index or a field number
  -> AVsub(AbsValue index, AbsValue offset);

  // symbolic null subscript: use the containing object in its entirety
  -> AVwhole();
  
  // above, I chose to create dedicated nodes for 'sub' and 'whole'
  // for possible recognition value; I may do the same for some of
  // my other commonly-used functions (sel/upd?)
}

verbatim {
  // some syntactic sugar
  AVfunc *avFunc1(StringRef func, AbsValue *a1);
  AVfunc *avFunc2(StringRef func, AbsValue *a1, AbsValue *a2);
  AVfunc *avFunc3(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3);
  AVfunc *avFunc4(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4);
  AVfunc *avFunc5(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4, AbsValue *a5);
  AVunary *avNot(AbsValue *v);

  // visitor interface
  class AbsValueVisitor {
  public:
    // return true to continue recursing or false to stop visiting children
    virtual bool visitAbsValue(AbsValue const *value);
  };

  void walkAbsValue(AbsValueVisitor &vis, AbsValue const *value);
}


// ------------------- implementation ----------------
impl_verbatim {
  #include "str.h"          // stringBuilder

  //AbsValue::~AbsValue

  string AbsValue::toString() const
  {
    stringBuilder sb;
    toSexp(sb);
    return sb;
  }

  void AVvar::toSexp(stringBuilder &sb) const
  {
    sb << (char const*)name;
  }

  void AVint::toSexp(stringBuilder &sb) const
  {
    sb << i;
  }

  void AVunary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "uPlus",
      "uMinus",
      "uNot",
      "uBitNot"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_UNARYOPS);

    if (op < UNY_PLUS) {
      cout << "warning: emitting sexp for " << unaryOpNames[op] << endl;
    }

    sb << "(" << names[op] << " ";
    val->toSexp(sb);
    sb << ")";
  }

  void AVbinary::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "bEqual",
      "bNotEqual",
      "bLess",
      "bGreater",
      "bLessEq",
      "bGreaterEq",

      "*",       // the three interpreted symbols are special
      "bDiv",
      "bMod",
      "+",
      "-",
      "bLShift",
      "bRShift",
      "bBitAnd",
      "bBitXor",
      "bBitOr",
      "bAnd",
      "bOr",

      "!!!BIN_ASSIGN!!!",    // shouldn't be sent to Simplify

      "bImplies"
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_BINARYOPS);
    xassert(op != BIN_ASSIGN);

    sb << "(" << names[op] << " ";
    v1->toSexp(sb);
    sb << " ";     
    v2->toSexp(sb);
    sb << ")";
  }

  void AVcond::toSexp(stringBuilder &sb) const
  {
    sb << "(ifThenElse ";
    cond->toSexp(sb);
    sb << " ";
    th->toSexp(sb);
    sb << " ";
    el->toSexp(sb);
    sb << ")";
  }

  void AVfunc::toSexp(stringBuilder &sb) const
  {
    sb << "(" << func;
    FOREACH_ASTLIST(AbsValue, args, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void AVlval::toSexp(stringBuilder &sb) const
  {
    // this should not be passed to simplify; but if it does, I want
    // to see the information ("!" is to make Simplify choke)
    sb << "(!AVlval " << progVar->name << " ";
    offset->toSexp(sb);
    sb << ")";
  }

  void AVsub::toSexp(stringBuilder &sb) const
  {
    sb << "(sub ";
    index->toSexp(sb);
    sb << " ";
    offset->toSexp(sb);
    sb << ")";
  }

  void AVwhole::toSexp(stringBuilder &sb) const
  {
    sb << "whole";
  }


  // ------------ syntactic sugar ----------------
  AVfunc *avFunc1(StringRef func, AbsValue *a1)
  {
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc2(StringRef func, AbsValue *a1, AbsValue *a2)
  {
    xassert(a1 && a2);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc3(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3)
  {
    xassert(a1 && a2 && a3);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc4(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4)
  {
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a4);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVfunc *avFunc5(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4, AbsValue *a5)
  {
    xassert(a1 && a2 && a3);
    AVfunc *f = new AVfunc(func, NULL);
    f->args.prepend(a5);
    f->args.prepend(a4);
    f->args.prepend(a3);
    f->args.prepend(a2);
    f->args.prepend(a1);
    return f;
  }

  AVunary *avNot(AbsValue *v)
  {
    return new AVunary(UNY_NOT, v);
  }

  // ------------- visitor ---------------
  bool AbsValueVisitor::visitAbsValue(AbsValue const *value)
  {
    return true;
  }

  void walkAbsValue(AbsValueVisitor &vis, AbsValue const *value)
  {
    if (!vis.visitAbsValue(value)) {
      return;
    }

    ASTSWITCHC(AbsValue, value) {
      ASTCASEC(AVunary, u) {
        walkAbsValue(vis, u->val);
      }

      ASTNEXTC(AVbinary, b) {
        walkAbsValue(vis, b->v1);
        walkAbsValue(vis, b->v2);
      }

      ASTNEXTC(AVcond, c) {
        walkAbsValue(vis, c->cond);
        walkAbsValue(vis, c->th);
        walkAbsValue(vis, c->el);
      }

      ASTNEXTC(AVfunc, f) {
        FOREACH_ASTLIST(AbsValue, f->args, iter) {
          walkAbsValue(vis, iter.data());
        }
      }

      ASTENDCASECD
    }
  }
}
