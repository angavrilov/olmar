// absval.ast
// abstract domain values

// NOTE: I have not worked out a deallocation strategy, so you should
// *never* try to deallocate these!

verbatim {
  #include "strtable.h"     // StringRef
  #include "cc_flags.h"     // UnaryOp, BinaryOp
  #include "variable.h"     // Variable

  class stringBuilder;      // str.h
}

class AbsValue {
  //private ~AbsValue();      // don't call me! (astgen doesn't quite work with this..)

  // simple linear printing
  public string toString() const;          // calls toSexp
  pure_virtual void toSexp(stringBuilder &sb) const;
  pure_virtual int toSexpLen() const;      // length of toSexp string

  // pretty-printing with intentation, etc.
  


  // ---------------- general-purpose ----------------
  // logic variable: unknown but definite integer value;
  // 'why' states what this variable stands for, or why it was created
  -> AVvar(StringRef name, string why);

  // literal integer
  -> AVint(int i);

  // arithmetic expressions built-in to the C language
  -> AVunary(UnaryOp op, AbsValue val);
  -> AVbinary(AbsValue v1, BinaryOp op, AbsValue v2);
  -> AVcond(AbsValue cond, AbsValue th, AbsValue el);

  // function symbols, variously interpreted
  -> AVfunc(StringRef func, ASTList<AbsValue> args);

  // --------------- symbolic addresses (lvalues) -------------
  // symbolic address: tells me where in the symbolic register file
  // to find the value, and update it if necessary; NOTE: Simplify
  // never sees these--they must be translated away before giving
  // them to the theorem prover; typically, these are yielded by
  // lvalues
  -> AVlval(Variable const *progVar,    // which register has the value
            AbsValue offset);           // sequence of 'sub' nodes

  // a symbolic subscript; could have an array index or a field number
  -> AVsub(AbsValue index, AbsValue offset);

  // symbolic null subscript: use the containing object in its entirety
  -> AVwhole();

  // above, I chose to create dedicated nodes for 'sub' and 'whole'
  // for possible recognition value; I may do the same for some of
  // my other commonly-used functions (sel/upd?)
}

verbatim {
  // some syntactic sugar
  AVfunc *avFunc1(StringRef func, AbsValue *a1);
  AVfunc *avFunc2(StringRef func, AbsValue *a1, AbsValue *a2);
  AVfunc *avFunc3(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3);
  AVfunc *avFunc4(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4);
  AVfunc *avFunc5(StringRef func, AbsValue *a1, AbsValue *a2, AbsValue *a3, AbsValue *a4, AbsValue *a5);
  AVunary *avNot(AbsValue *v);

  // visitor interface
  class AbsValueVisitor {
  public:
    // return true to continue recursing or false to stop visiting children
    virtual bool visitAbsValue(AbsValue const *value);
  };

  void walkAbsValue(AbsValueVisitor &vis, AbsValue const *value);
}
