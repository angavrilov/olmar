<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>

<HEAD>
  <TITLE>Elkhound Manual</TITLE>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
</HEAD>

<body>

<center><h2>
Elkhound Manual
</h2></center>

<p>
This page describes the input format for grammars for the Elkhound
parser generator, and the features of that generator.

<p>
Related pages:
<ul>
<li><a href="index.html">Elkhound overview</a>
<li><a href="tutorial.html">Elkhound tutorial</a>
</ul>

<p>
If you'd like to look at a simple grammar while reading this
description, see <a
href="examples/arith/arith.gr">examples/arith/arith.gr</a>, a parser
for simple arithmetic expressions.


<h2>1. Lexical structure</h2>

<p>
The grammar file format is free-form, meaning that all whitespace is
considered equivalent.  In the C tradition, grouping is generally
denoted by enclosing things in braces ("{" and "}").  Strings are
enclosed in double-quotes ("").

<p>
Grammar files may include other grammar files, by writing
include("other_file_name").

<p>
Comments can use the C++ "//" syntax or the C "/**/" syntax.


<h2>2. Context Class</h2>

<p>
The parser's action functions are all members of a C++ context
class.  As the grammar author, you must define the context class.
The class is introduced with the "<tt>context_class</tt>" keyword,
followed by ordinary C++ syntax for classes (ending with "<tt>};</tt>");


<h2>3. Terminals</h2>

The user must declare of all the tokens, also called terminals.  A
block of terminal declarations looks like:
<pre>
  terminals {
    0 : TOK_EOF;
    1 : TOK_NUMBER;              // no alias
    2 : TOK_PLUS     "+";        // alias is "+" (including quotes)
    3 : TOK_MINUS    "-";
    4 : TOK_TIMES    "*";
    5 : TOK_DIVIDE   "/";
    6 : TOK_LPAREN   "(";
    7 : TOK_RPAREN   ")";
  }
</pre>

<p>
Each statement gives a unique numeric code (e.g. 3), a canonical
name (e.g. TOK_MINUS), and an optional alias (e.g. "-").  Either the
name or the alias may appear in the grammar productions, though the
usual style is to use aliases for tokens that always have the same
spelling (like "}"), and the name for others (like TOK_NUMBER).

<p>
Normally it's expected the tokens will be described in their own
file, and the <a href="make-tok">make-tok</a> script will create
the token list seen above.

<h3>3.1 Token Types</h3>

<p>
In addition to declaring the numeric codes and aliases of the tokens,
the user must declare types for semantic values of tokens, if those
values are used by reduction actions (specifically, if their occurence
on a right-hand-side includes a label, denoted with a colon ":").

<p>
The syntax for declaring a token type is
<blockquote>
  <tt>token(</tt><i>type</i><tt>) </tt><i>token_name</i><tt>;</tt>
</blockquote>
or, if specifying terminal functions,
<blockquote>
  <tt>token(</tt><i>type</i><tt>) </tt><i>token_name</i><tt> {</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>terminal_functions</i><br>
  <tt>}</tt>
</blockquote>

<p>
The terminal functions are explained in the next sections.

<h3>3.2 dup/del</h3>

<p>
Terminals can have <tt>dup</tt> and <tt>del</tt> functions, just like
nonterminals.  See <a href="#dup">below</a> for more information.

<h3>3.3 classify <font color="red">(advanced)</font></h3>

<p>
In some situations, it is convenient to be able to alter the classification
of a token after it is yielded by the lexer but before the parser sees it,
in particular before it is compared to lookahead sets.  For this purpose,
each time a token is yielded from the lexer, it is passed to that token's
<tt>classify()</tt> function.  <tt>classify</tt> accepts a single argument,
the semantic value associated with that token.  It returns the token's
new classification, as a token id.  (It cannot change the semantic value.)

<p>
The main way it differs from simply modifying the lexer is that the
<tt>classify</tt> function has access to the parser context class, whereas
the lexer presumably does not.  In any case, it's something of a hack, and
best used sparingly.

<p>
As a representative example, here is the <tt>classify</tt> function from
<a href="c/c.gr">c/c.gr</a>, used to implement the lexer hack for a C parser:
<pre>
  token(StringRef) L2_NAME {
    fun classify(s) [
      if (isType(s)) {
        return L2_TYPE_NAME;
      }
      else {
        return L2_VARIABLE_NAME;
      }
    ]
  }
</pre>

<h3>3.4 Precedence and Associativity</h3>

<p>
[TODO: Write this.  For now, you can look at what
<a href="http://www.gnu.org/software/bison/manual/html_node/Precedence.html">Bison has to say</a>,
though that is pretty short.]

<h2>4. Nonterminals</h2>

<p>
Following the terminals, the bulk of the grammar is one or more
nonterminals.  Each nonterminal declaration specifies all of the
productions for which it is the left-hand-side.

<p>
A simple nonterminal might be:
<pre>
  nonterm(int) Exp {
    -&gt; e1:Exp "+" e2:Exp        { return e1 + e2; }
    -&gt; n:TOK_NUMBER             { return n; }
  }
</pre>

<p>
The type of the semantic value yielded by the productions is given
in parentheses, after the keyword "<tt>nonterm</tt>".  In this case,
<tt>int</tt> is the type.  The type can be omitted if productions
do not yield interesting semantic values.

<p>
In the example, Exp has two productions, <tt>Exp -&gt; Exp "+"
Exp</tt> and <tt>Exp -&gt; TOK_NUMBER</tt>.  The "<tt>-&gt;</tt>"
keyword introduces a production.

<p>
Right-hand-side symbols can be given names, by putting the name
before a colon (":") and the symbol.  These names can be used in
the action functions to refer to the semantic values of the
subtrees (like Bison's <tt>$1</tt>, <tt>$2</tt>, etc.).  Note that
action functions <tt>return</tt> their value, as opposed to (say)
assigning to <tt>$$</tt>.

<p>
There are four kinds of nontermial functions, described below.

<h3><a name="dup">4.1 dup</a></h3>

<p>
Because of the way the GLR algorithm operates, a semantic value
yielded (returned) by one action may be passed as an argument
to <em>more than one</em> action.  This is in contrast to Bison,
where each semantic value is yielded exactly once.

<p>
Depending on what the actions actually do, i.e. what the semantic
values actually mean, the user may need to intervene to help
manage the sharing of semantic values.  For example, if the
values form a tree where memory is managed by reference counting,
then the reference count of a value would need to be increased
each time it is yielded.

<p>
The <tt>dup()</tt> nonterminal function is intended to support the
kind of sharing management alluded to above.  Each time a semantic
value is to be passed to an action, it first is passed to the
associated <tt>dup()</tt> function.  The value returned by
<tt>dup()</tt> is stored back in the parser's data structures,
for use the next time the value must be passed to an action.
Effectively, by calling <tt>dup()</tt>, the parser is announcing,
"I am about to surrender this value to an action; please give me
a value to use in its place next time."

<p>
Common <tt>dup()</tt> strategies:
<ul>
<li>Return <tt>NULL</tt>.  This is the default.  This expresses the
    intent that the value <em>not</em> be passed more than once (since
    any subsequent actions will receive <tt>NULL</tt> arguments).
<li>Return the argument.  This is the default if the
    <tt>useGCDefaults</tt> option is specified.  This is useful when
    the semantic values can be shared arbitrarily without special handling.
<li>Increment a reference count, make a deep copy, etc.  Various
    possibilities exist depending on the particular sharing
    management in use.
</ul>

<h3>4.2 del</h3>

<p>
A natural counterpart to <tt>dup()</tt>, <tt>del()</tt> accepts values
that are not going to be passed to any more actions (this happens
when, for example, one of the potential parsers fails to make further
progress).  It does not return anything.

<p>
Common <tt>del()</tt> strategies:
<ul>
<li>Print a warning.  This is the default, since an unhandled
    <tt>del()</tt> may be the cause of a memory leak, depending
    on the memory management strategy in use.
<li>Do nothing.  This is the default if the <tt>useGCDefaults</tt>
    option is specified.
<li>Decrement a reference count, deallocate, etc.  Depending on
    the programmer's intended memory management scheme, the
    value passed to <tt>del()</tt> can be treated appropriately.
</ul>

<h3>4.3 merge</h3>

<p>
An <em>ambiguity</em> is the condition when a single sequence of
tokens can be parsed as some nonterminal in more than one way.
During parsing, when an ambiguity is encountered, the semantic
values from the different parses are passed to the nonterminal's
<tt>merge()</tt> function, two at a time.

<p>
Merge accepts two competing semantic value arguments, and returns a
semantic value that will stand for the ambiguous region in all future
reductions.  Both the arguments and the return value have the type of
the nonterminal's usual semantic values.

<p>
If there are more than two parses, the first two will be merged, the
result of which will be merged with the third, and so on until they
are all merged.  At each step, the first argument is the one that
may have resulted from a previous <tt>merge()</tt>, and the second
argument is not (unless it is the result of merging from further
down in the parse forest).

<p>
Common <tt>merge()</tt> strategies:
<ul>
<li>Print a message to the effect that the ambiguity is unexpected,
    and return one of the arguments arbitrarily.  This is the
    default behavior.
<li>Abort the program.  This is a more severe response than the
    first one, and is the default if the <tt>defaultMergeAborts</tt>
    option is specified.
<li>Examine the two semantic values, and apply some disambiguation
    criteria to choose which to retain.  Then return only the
    retained value.  Note that <tt>merge()</tt> is being given exclusive
    right to access both values; if it chooses to only return one of
    them for future reductions, then the other should probably be
    treated similarly to calling <tt>del()</tt> (though in fact, literally
    calling <tt>del()</tt> is not possible in the current implementation).
<li>Create some explicit representation of the ambiguity.  This is how
    the Elsa C++ parser handles most of the ambiguities in its C++ grammar,
    due to the type/variable ambiguity.
</ul>

<h3>4.4 keep</h3>

<p>
Sometimes, a potential ambiguity can be prevented if a semantic value
can be determined to be invalid in isolation (as opposed to waiting to
see a competing alternative in <tt>merge()</tt>).  To support such
determination, each nonterminal can have a <tt>keep()</tt> function,
which returns <tt>true</tt> if its semantic value argument should be
retained (as usual) or <tt>false</tt> if its argument should be
suppressed, as if the reduction never happened.

<p>
If <tt>keep</tt> returns <tt>false</tt>, the parser does <em>not</em>
call <tt>del()</tt> on that value; it is regarded as disposed by
<tt>keep</tt>.

<p>
Common <tt>keep</tt> strategies:
<ul>
<li>Always return <tt>true</tt>.  This is the default.
<li>Look at the argument, and return <tt>false</tt> if for some reason
    it should be discarded, particularly if it will otherwise lead to
    an ambiguity.  This is the intended usage.
<li>As a variation of the above, the reduction action itself can make
    the determination of suitability, and return a special value like
    <tt>NULL</tt> if it wants to cancel the reduction.  Then,
    <tt>keep()</tt> simply checks for the special value.  In fact,
    since <tt>keep()</tt> is a somewhat expensive option in terms of
    performance, I am considering eliminating <tt>keep()</tt> in favor
    of a built-in <tt>NULL</tt> check.
</ul>




<h2>5. Options</h2>

<p>
A number of variations in parser generator behavior can be requested
through the use of the <tt>option</tt> syntax:
<blockquote>
  <tt>option </tt><i>option_name</i><tt>;</tt>
</blockquote>
or, for options that accept an argument:
<blockquote>
  <tt>option </tt><i>option_name</i> <i>option_argument</i><tt>;</tt>
</blockquote>
The various options are described in the following sections.

<h3>5.1 useGCDefaults</h3>

<p>
The command
<pre>
  option useGCDefaults;
</pre>
instructs the parser generator to make the tacit assumption that sharing
management is automatic (e.g. via a garbage collector), and hence set the
default terminal and nonterminal functions appropriately.  

<p>
In fact, most users of Elkhound will probably want to specify this
option during initial grammar development, to reduce the amount
of specification needed to get started.  The rationale for not making
<tt>useGCDefaults</tt> the global default is that users should be aware
that the issue of sharing management is being swept under the carpet.

<h3>5.2 defaultMergeAborts</h3>

<p>
The command
<pre>
  option defaultMergeAborts;
</pre>
instructs the parser generator that if the grammar does not specify a
<tt>merge()</tt> function, the supplied default should print a message
and then abort the program.  This is a good idea once it is believed
that all the ambiguities have been handleded by <tt>merge()</tt> functions.

<h3>5.3 Expected conflicts, unreachable symbols</h3>

<p>
Nominally, the parser generator expects there to be no shift/reduce
and no reduce/reduce conflicts, and no unreachable (from the start
symbol) symbols.  Of course, the whole point of using GLR is to allow
conflicts, but it is still generally profitable to keep track of how
many conflicts are present at a given stage of grammar development,
since a sudden explosion of conflicts often indicates a grammar bug.

<p>
So, the user can declare how many conflicts of each type are expected.
For example,
<pre>
  option shift_reduce_conflicts 40;
  option reduce_reduce_conflicts 30;
</pre>
specifies that 40 S/R conflicts and 30 R/R conflicts are expected.  If
the parser generator finds matching statistics, it will suppress
reporting of such statistics; if there is a difference, it will be
reported.

<p>
Similarly, one can indicate the expected number of unreachable
syhmbols (this usually corresponds to a grammar in development, where
part of the grammar has been deliberately disabled by making it
inaccessible):
<pre>
  option unreachable_nonterminals 3;
  option unreachable_terminals 2;
</pre>

<h2>6. OCaml</h2>

<p>
By default, Elkhound generates a parser in C++.  By specifying
"<tt>-ocaml</tt>" on the command line,
the user can request that instead the parser generate OCaml code.
Please see <a href="ocaml/">ocaml/</a>, probably starting with
the example driver <a href="ocaml/main.ml">ocaml/main.ml</a>.




<p>
  <a href="http://validator.w3.org/check/referer"><img border="0"
      src="http://www.w3.org/Icons/valid-html401"
      alt="Valid HTML 4.01!" height="31" width="88"></a>
</p>

</body>

</HTML>



