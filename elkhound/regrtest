#!/bin/sh
# regression tests

# default values for user parameters
skip=0
big=0
contin=0

# counters
curtest=0
success=0
failure=0
unexSuccess=0
unexFailure=0
vcgenOnly=false
runOneTest=false

usage() {
cat <<EOF
usage: $0 [options]
  -skip <n>    skip the first <n> tests
  -one <n>     run only test <n>
  -big         run the big, timeconsuming tests
  -contin      keep going even after a test fails (or succeeds) unexpectedly
  -help        print this message
  -vcgen       only run the vcgen tests
EOF
}

# process args
while [ "$1" != "" ]; do
  case "$1" in
    -skip)
      shift
      skip="$1"
      ;;

    -one)
      shift
      skip="$1"
      runOneTest=true
      ;;

    -big)
      big=1
      ;;

    -contin)
      contin=1
      ;;

    -help)
      usage
      exit 0
      ;;

    -vcgen)
      vcgenOnly=true
      ;;

    *)
      echo "unknown arg: $1"
      usage
      exit 2
      ;;
  esac

  shift
done

# clear the logfile
log=regrtest.log
rm -f $log

# write something to terminal and log
log() {
  echo "$@"
  echo "$@" >> $log
}


# run a single test, and bail if it fails
runTest() {
  if ! runTestInternal "$@"; then
    if [ $contin = 0 ]; then
      exit 2
    fi
  fi
}

# run a single test, and return 0 if it succeeds
runTestInternal() {
  result=0

  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: skipping $*"
  else
    # print a visually distinct banner
    echo "------------ [$curtest] $* ------------"
    "$@"
    result=$?
    if [ $result -ne 0 ]; then
      unexFailure=$[ $unexFailure + 1 ]
      echo ""
      log  "[$curtest] A regression test command failed:"
      log  "  $*"
    else
      success=$[ $success + 1 ]
    fi

    if $runOneTest; then
      # exit with code 0 if the test succeeded
      exit $[ 1 - $success ]
    fi
  fi

  curtest=$[ $curtest + 1 ]
  return $result
}

# run a big test, only if the user wants to
bigTest() {
  if [ $big = 1 ]; then
    runTest "$@"
  fi
}

# run a test that is expected to fail
failTest() {
  reason="$1"
  shift
  if [ "$curtest" -lt "$skip" ]; then
    echo "[$curtest]: (fail) skipping $*"
  else
    echo "------------ [$curtest] (fail) $* ------------"
    if "$@"; then
      unexSuccess=$[ $unexSuccess + 1 ]
      echo ""
      log  "[$curtest] A regression test that used to fail ($reason) now succeeds:"
      log  "  $*"
      if [ $contin = 0 ]; then
        exit 2
      fi
    else
      failure=$[ $failure + 1 ]
      echo "Failed as expected: $reason"
    fi

    if $runOneTest; then
      # exit with code 0 if the test failed
      exit $[ 1 - $failure ]
    fi
  fi

  curtest=$[ $curtest + 1 ]
}

# run a failing big test
bigFail() {
  if [ $big = 1 ]; then
    failTest "$@"
  fi
}

# grep for lines containing both words, in first argument source file
grepBoth() {
  grep -w $2 $1 | grep -w $3
}


# ------------- small test grammars ----------
runTest make cexp3
runTest make cexp3b

# usage: testTrivGrammar <name> [<inputSuffix1> [<inputSuffix2> ...]]
testTrivGrammar() {
  name="$1"
  shift
  runTest make "$name.gr.exe" TRGRAMANL=,lrtable
  
  while [ "$1" != "" ]; do
    suffix="$1"
    shift

    runTest "./$name.gr.exe" "$name.in$suffix"
  done
}

testTrivGrammar aSEb 1
testTrivGrammar ite 1 2 3 4
testTrivGrammar AdB 1
testTrivGrammar CNI 1
testTrivGrammar ESb 1
testTrivGrammar CAdB 1

#runTest make aSEb.gr.exe
#runTest ./aSEb.gr.exe aSEb.in1

#  runTest make ite.gr.exe
#  for n in 1 2 3 4; do
#    runTest ./ite.gr.exe ite.in$n
#  done



# ------------ test the C grammar and parser -------------
if ! $vcgenOnly; then
  for n in 1 2 3 4 5 6 7 8 9 10 11 12; do
    runTest ./ccgr -tr stopAfterTCheck cc.bin c.in$n
  done


  tcheck() {
    runTest ./test-bad tcheck/$1 -tr stopAfterTCheck cc.bin
  }

  tcheck init.c
  tcheck addrglob.c
  tcheck loops.c
  tcheck exprpath.c
  runTest ./ccgr -tr printAnalysisPath cc.bin tcheck/morepaths.c
fi


# --------------- test Simplify directly ----------------
runTest ./test-Simplify.pl simp-ex/indegree.sx
runTest ./test-Simplify.pl simp-ex/sel_upd.sx


# --------------- test the program verifier ---------------
vcgen() {
  runTest ./ccgr cc.bin vcgen/$1
}
vcgenfail() {
  failTest "$1" ./ccgr cc.bin vcgen/"$2"
}
vcgentb() {
  runTest ./test-bad vcgen/$1 cc.bin
}
vcgencpp() {
  echo "cpp vcgen/$1 >tmp.i"
  cpp vcgen/$1 >tmp.i
  runTest ./ccgr cc.bin tmp.i
}

vcgen if.c
vcgen ptr.c
vcgen invar.c
vcgen global.c
vcgen global2.c
vcgen blast1.c
vcgentb clash1.c
vcgentb swap1.c
vcgentb array.c
vcgen ptrptr.c
vcgen simple.c

# fails because I can't seem to capture the notion of
# a string in my new sel/upd model
#vcgentb str.c

vcgentb struct.c
vcgen loop1.c
vcgen corrcond.c
vcgentb npktsmall.c
vcgen cutpt.c
runTest ./ccgr -tr printAnalysisPath cc.bin vcgen/nestwhile.c
vcgen memswap.c
vcgen ff.c
#failTest "can't prove postcondition" ./ccgr -tr disableFactFlow cc.bin vcgen/find.c
#vcgenfail "can't prove postcondition" find2.c
vcgen callfind.c

(cd vcgen; make) || (echo "Failed to make in vcgen"; exit 2)

vcgen node.i
vcgen owner1.i
runTest ./ccgr -tr disableFactFlow cc.bin vcgen/owner2.i

# this one is my main performance tester
runTest ./ccgr -tr trivialActions,stopAfterParse cc.bin c.in4d


# final arithmetic to report result
echo ""
echo "Successful tests:      $success"
echo "Failed as expected:    $failure"    
if [ $contin = 1 ]; then
  echo "Unexpected success:    $unexSuccess"
  echo "Unexpected failure:    $unexFailure"
  if [ -f "$log" ]; then
    cat "$log"
  fi
fi

