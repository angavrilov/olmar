; sel_upd.sx    -*- Lisp -*-
; experiments with new sel/upd axioms


; ---------------------- selOffset ----------------
bg_push (
  (uncheckedAccess mem0)           ; memory itself is not bounds-checked
  (EQ (length (sel mem0 a)) 10)    ; a[] has 10 elements

  (EQ (sel (sel mem0 a) 2) 9)      ; mem.a.2 == 9
  (EQ p0 (sub a (sub 2 whole)))    ; p0 == .a.2
)

valid "a" (
  (EQ (selOffset mem0 p0) 9)
)

notvalid "!a" (
  (EQ (selOffset mem0 p0) 8)
)


bg_push (
  (EQ mem1 (updOffset mem0 p0 7))
)

valid "b" (
  (EQ (selOffset mem1 p0) 7)
)

notvalid "!b" (
  (EQ (selOffset mem1 p0) 9)
)


; ------------------- okSel ------------------
bg_push (
  (EQ (length obj1) 3)
)

valid "oksel1" (
  (okSel obj1 0)
)

valid "oksel2" (
  (okSel obj1 2)
)

notvalid "!oksel1" (
  (okSel obj1 -1)
)

notvalid "!oksel2" (
  (okSel obj1 3)
)

valid "oksel3" (
  (okSel mem0 a)
)

valid "oksel1 via write" (
  (okSel mem1 a)
)

valid "oksel2 via write" (
  (okSel (sel mem1 a) 2)
)

valid "oksel2b via write" (
  (okSel (sel mem1 a) 0)
)

notvalid "!oksel2b via write" (
  (okSel (sel mem1 a) -1)
)

valid "oksel2c via write" (
  (okSel (sel mem1 a) 9)
)

notvalid "!oksel2c via write" (
  (okSel (sel mem1 a) 10)
)

bg_pop


; ------------------------- unrelated ------------------------
; I had to remove all 'unrelated' axioms because the axiom which
; used it causes Simplify to loop in some cases

; bg_push (
;   (DISTINCT a b c)
;   (EQ ptr1 (sub a (sub 0 whole)))
;   (EQ ptr2 (sub b (sub 0 whole)))
;   (EQ ptr3 (sub b (sub 1 whole)))
; )

; valid "unr1,2" (
;   (AND
;     (unrelated ptr1 ptr2)
;     (unrelated ptr2 ptr3)
;     (unrelated ptr3 ptr1)
;     (unrelated ptr1 ptr3)
;   )
; )


; bg_push (
;   (EQ ptr13 (addOffset ptr1 3))
;   (EQ ptr14 (addOffset ptr1 4))
; )

; valid "provable without unr3" (
;   (unrelated ptr13 ptr14)
; )

; valid "needs unr3" (
;   (IMPLIES
;     (EQ foo bar)
;     (unrelated (addOffset foo 3) (addOffset bar 4))
;   )
; )

; ; because foo could be a prefix of bar, or vice-versa
; notvalid "would be unsound" (
;   (IMPLIES
;     (NEQ foo bar)
;     (unrelated (addOffset foo 3) (addOffset bar 4))
;   )
; )

; bg_pop
; bg_pop


; -------------------- okSelOffset ----------------
valid "okselofs1" (
  (okSelOffset mem1 p0)
)

notvalid "!okselofs1" (
  (okSelOffset mem1 (sub a (sub 19 whole)))
)


; -------------------- addOffset ------------------
bg_push (
  (EQ p1 (addOffset p0 4))
)

valid "c" (
  (EQ p1 (sub a (sub 6 whole)))
)

notvalid "!c" (
  (EQ p1 (sub a (sub 2 whole)))
)

valid "okselofs2" (
  (okSelOffset mem1 p1)
)


; ---------------------- okSelOffsetRange -----------------
bg_push (
  (okSelOffsetRange obj offset 5)
)

valid "okSelOffsetRange1" (
  (okSelOffset obj (addOffset offset 2))
)

notvalid "okSelOffsetRange1b" (
  (okSelOffset obj (addOffset offset -1))
)

notvalid "okSelOffsetRange1c" (
  (okSelOffset obj (addOffset offset 5))
)

bg_pop


bg_push (
  (EQ (length obj) 10)                 ; array of 10 things
  (EQ mem2 (upd mem1 addr obj))        ; stored at address 'addr'
  (EQ ptr1 (sub addr (sub 3 whole)))   ; offset 3 within obj
)

valid "check" (
  (okSelOffset mem2 ptr1)
)

valid "okSelOffsetRange2" (
  (okSelOffsetRange mem2 ptr1 7)
)

notvalid "okSelOffsetRange2b" (
  (okSelOffsetRange mem2 ptr1 8)
)

bg_pop


; ------------------ appendIndex ---------------------
valid "d" (
  (EQ p1 (appendIndex (appendIndex whole a) 6))
)

notvalid "!d" (
  (EQ p1 (appendIndex (appendIndex whole a) 7))
)

valid "take apart" (
  (EXISTS (container last)
    (AND
      (EQ p1 (appendIndex container last))
      (EQ container (sub a whole))
      (EQ last 6)
    ))
)


; -------------- complicated example.. --------------
bg_push (
  ;(EQ (length (sel mem_33 addr_arr_2)) 10)
  (DISTINCT addr_arr_3 0)
  (uncheckedAccess mem_34)
  (EQ (length (sel mem_34 addr_arr_3)) 10)
  ;(EQ mem_35 (upd mem_34 addr_arr_3 arr_1))
)

valid "access1" (
  (okSel mem_34 addr_arr_3)
)

valid "access2" (
  (okSel (sel mem_34 addr_arr_3) 0)
)

valid "access2" (
  (okSel (sel mem_34 addr_arr_3) 9)
)

valid "check1" (
  (EQ (selOffset mem_34 (sub addr_arr_3 whole)) (sel mem_34 addr_arr_3))
)
                                                         
valid "final accesses" (
  (FORALL (i_30 )
    (IMPLIES
      (AND (<= 0 i_30) (< i_30 10))
      (okSelOffset mem_34 (addOffset (sub addr_arr_3 (sub 0 whole)) i_30))
    ))
)

bg_pop

; -------------- another example --------------
bg_push (
  (EQ y_8 (sel mem_34 addr_y_7))
  (DISTINCT addr_y_8 0)
  (uncheckedAccess mem_35)
  (EQ y_9 (sel mem_35 addr_y_8))
  (NEQ x_23 (sub addr_y_8 whole))
  (okSelOffset mem_35 x_23)
  (EQ mem_36 (updOffset mem_35 x_23 (+ (selOffset mem_35 x_23) 1)))
)

notvalid "x could point deep inside y, so y got modified" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole))
      (selOffset mem_35 (sub addr_y_8 whole)))
)

; provide additional information about x
bg_push (
  (EQ x_23 (sub x_object x_offset))
  (NEQ x_object addr_y_8)
)

valid "now it should work" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole))
      (selOffset mem_35 (sub addr_y_8 whole)))
)

bg_pop
bg_pop


; ------------------- firstIndexOf example ---------------
bg_push (
  (DISTINCT addr_y_8 0)
  (uncheckedAccess mem_35)
  (EQ y_9 (sel mem_35 addr_y_8))
  (NEQ (firstIndexOf x_23) (firstIndexOf (sub addr_y_8 whole)))
  (okSelOffset mem_35 x_23)
  (EQ mem_36 (updOffset mem_35 x_23 (+ (selOffset mem_35 x_23) 1)))
  (EQ x_23 (sub foo bar))
)

valid "unchanged" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole)) 
      (selOffset mem_35 (sub addr_y_8 whole)))
)


; ------------------ okSelOffset after two updates --------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_23)
  (EQ ptr_4 (sub ptr_index_4 ptr_rest_4))
  (EQ x_10 (sub x_index_4 x_rest_4))
  (okSelOffset mem_23 ptr_4)
  (okSelOffset mem_23 x_10)
  (NEQ (firstIndexOf ptr_4) (firstIndexOf x_10))
  (EQ mem_24 (updOffset mem_23 ptr_4 5))

  ; currently my axioms only go the other way..
  ;(okSelOffset (sel mem_23 x_index_4) x_rest_4)

  ; try reversing it.. I added this to bgpred.sx ..
  ;   (FORALL (obj index rest)  ; (PATS (okSelOffset obj (sub index rest)))
  ;     (IMPLIES
  ;       (okSelOffset obj (sub index rest))
  ;       (AND
  ;         (okSel obj index)
  ;         (okSelOffset (sel obj index) rest)
  ;       )
  ;     ))
)

valid "implications" (
  (AND
    (okSelOffset (sel mem_23 x_index_4) x_rest_4)
    (NEQ ptr_index_4 x_index_4)
    (EQ mem_24 (upd mem_23 ptr_index_4
                 (updOffset (sel mem_23 ptr_index_4) ptr_rest_4 5)))
    (IMPLIES
      (okSelOffset (sel mem_24 x_index_4) x_rest_4)
      (okSelOffset mem_24 x_10)
    )
  )
)

valid "still ok" (
  ;(okSelOffset mem_24 x_10)
  (okSelOffset (sel mem_24 x_index_4) x_rest_4)
)


; ---------------------- okSelOffset after array ops -----------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_20)
  (EQ a_7 (sub a_index_7 a_rest_7))
  (EQ a_rest_7 (sub 0 whole))     ; will this help?  no..
;   (FORALL (i_7 )
;     (IMPLIES
;       (AND (<= 0 i_7) (< i_7 5))
;       (okSelOffset mem_20 (addOffset a_7 i_7))
;     ))
;   (FORALL (i_7 )
;     (IMPLIES
;       (AND (<= 0 i_7) (< i_7 5))
;       (okSelOffset mem_20 (sub a_index_7 (sub i_7 whole)))
;     ))                                  

  ; explicitly instantiating was the key..
  (okSelOffset mem_20 (sub a_index_7 (sub 1 whole)))
  
  (EQ mem_21 (updOffset mem_20 (addOffset a_7 0) 0))
  (EQ prevArray (sel mem_20 a_index_7))
)

valid "implications" (
  (AND
    (okSelOffset mem_20 (addOffset a_7 1))
    (EQ (addOffset a_7 1) (sub a_index_7 (sub 1 whole)))

    (okSelOffset mem_20 (sub a_index_7 (sub 1 whole)))
    (EQ mem_21 (upd mem_20 a_index_7 (upd prevArray 0 0)))
    (EQ (sel (sel mem_21 a_index_7) 0) 0)   ; a[0] is known
    (EQ (sel (sel mem_21 a_index_7) 1)
        (sel (sel mem_20 a_index_7) 1))     ; a[1] hasn't changed
        
    (EQ (sel mem_21 a_index_7)
        (upd prevArray 0 0))      ; new array is a[0 := 0]

    (okSel mem_21 a_index_7)

    (okSel prevArray 1)
  )
)

valid "access after mod" (
  ;(okSelOffset mem_21 (addOffset a_7 1))
  ;(okSelOffset mem_21 (sub a_index_7 (sub 1 whole)))
  ;(AND
    ;(okSel prevArray 1)
    ;(EQ (sel mem_21 a_index_7)
    ;    (upd prevArray 0 0))      ; new array is a[0 := 0]
    (okSel (upd prevArray 0 0) 1)
  ;)
)


bg_pop

; ----------------- length>=5 example ------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_20)
  (EQ a_7 (sub a_index_7 a_rest_7))

  (>= (length (sel mem_20 (firstIndexOf a_7))) 5)
  ;(EQ (length (sel mem_20 (firstIndexOf a_7))) 5)

  (EQ (firstIndexOf (restOf a_7)) 0)
  
  (EQ a_rest_7 (sub index w_h_o_l_e))   ; I added this
  ;(EQ w_h_o_l_e whole)                  ; had to add this too
  (isWhole w_h_o_l_e)                   ; had to add this too
)

valid "implications" (
  (AND
    (EQ index 0)
  )
)

valid "access" (
  (okSelOffset mem_20 (addOffset a_7 0))
)

bg_pop


; -------------------- str.c example ----------------
; this one runs into a Simplify incompleteness

; bg_push (
;   (DISTINCT addr_buf_3 0 str_2)
;   (uncheckedAccess mem_10)
;   (EQ (length (sel mem_10 addr_buf_3)) 80)
;   (EQ mem_11 (upd mem_10 addr_buf_3 buf_1))
;   (EQ (length (sel mem_11 addr_buf_3)) 80)
;   (EQ (sub addr_buf_3 (sub 0 whole)) (sub p_index_4 p_rest_4))
;   (EQ (length (sel mem_11 str_2)) 12)
;   (EQ (firstZero (sel mem_11 str_2)) 11)
;   (EQ mem_11 (sub pre_mem_index_1 pre_mem_rest_1))
; )

; valid "goal" (
;   (EXISTS (srcBase_1 srcIndex_1 srcLen_1 srcObj_1 destBase_1 destIndex_1 destObj_1 )
;     (AND
;       (EQ (sub str_2 (sub 0 whole)) (sub srcBase_1 (sub srcIndex_1 0)))
;       (EQ srcObj_1 (sel mem_11 srcBase_1))
;       (EQ srcLen_1 (firstZero srcObj_1))
;       (EQ (sub addr_buf_3 (sub 0 whole)) (sub destBase_1 (sub destIndex_1 0)))
;       (EQ destObj_1 (sel mem_11 destBase_1))

;       ; implications
;       (EQ srcIndex_1 0)
;       (EQ srcBase_1 str_2)
;       (EQ srcLen_1 11)
;       (EQ (length srcObj_1) 12)

;       (<= 0 srcIndex_1)
;       (<= srcIndex_1 srcLen_1)
;       (< srcLen_1 (length srcObj_1))
;       (<= 0 destIndex_1)
;       (< destIndex_1 (length destObj_1))
;       (NEQ destBase_1 srcBase_1)
      
;       (EQ (length destObj_1) 80)
;       (EQ destIndex_1 0)
;       ;(EQ (- srcLen_1 srcIndex_1) 11)
;       ;(EQ (- srcLen_1 0) 11)

;       ;(< (- srcLen_1 srcIndex_1) (- (length destObj_1) destIndex_1))
;     ))
; )

; bg_push (
;   (FORALL (x)
;     (EQ
;       (- x 0)
;       x
;     ))
; )

; valid "tmp2" (  
;   (IMPLIES
;     (EQ len 5)
;     (EQ (- len 0) 5)
;   )
; )

; valid "tmp" (
;   (EXISTS (len)
;     (AND
;       (EQ len 5)
;       (EQ (- len 0) 5)     ; comment this out and it works, despite len == 5
;     ))
; )

; valid "tmp3" (
;   (EXISTS (len)
;     (AND
;       (EQ len 5)
;       (IMPLIES
;         (EQ len 5)
;         (EQ (- len 0) 5)
;       )
;     ))
; )

; valid "tmp4" (
;   (EXISTS (len)
;     (AND
;       (IMPLIES
;         (EQ len 5)
;         (EQ (- len 0) 5)
;       )
;     ))
; )

; bg_pop


; ------------------ array.c postcondition ----------------
bg_push (
  (EQ a_10 (sub a_index_11 a_rest_11))
  (EQ mem_22 (updOffset mem_21 (addOffset a_10 0) 0))
  (EQ mem_23 (updOffset mem_22 (addOffset a_10 1) 1))
  (EQ mem_24 (updOffset mem_23 (addOffset a_10 2) 2))
  (EQ mem_25 (updOffset mem_24 (addOffset a_10 3) 3))
  (EQ mem_26 (updOffset mem_25 (addOffset a_10 4) 4))
)
valid "array.c postcondition" (
  (EQ (selOffset mem_26 (addOffset a_10 2)) 2)
)
bg_pop
