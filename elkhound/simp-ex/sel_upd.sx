; sel_upd.sx    -*- Lisp -*-
; experiments with new sel/upd axioms


; ---------------------- selOffset ----------------
bg_push (
  (uncheckedAccess mem0)           ; memory itself is not bounds-checked
  (EQ (length (sel mem0 a)) 10)    ; a[] has 10 elements

  (EQ (sel (sel mem0 a) 2) 9)      ; mem.a.2 == 9
  (EQ p0 (sub a (sub 2 whole)))    ; p0 == .a.2
)

valid "a" (
  (EQ (selOffset mem0 p0) 9)
)

notvalid "!a" (
  (EQ (selOffset mem0 p0) 8)
)


bg_push (
  (EQ mem1 (updOffset mem0 p0 7))
)

valid "b" (
  (EQ (selOffset mem1 p0) 7)
)

notvalid "!b" (
  (EQ (selOffset mem1 p0) 9)
)


; ------------------- okSel ------------------
bg_push (
  (EQ (length obj1) 3)
)

valid "oksel1" (
  (okSel obj1 0)
)

valid "oksel2" (
  (okSel obj1 2)
)

notvalid "!oksel1" (
  (okSel obj1 -1)
)

notvalid "!oksel2" (
  (okSel obj1 3)
)

valid "oksel3" (
  (okSel mem0 a)
)

valid "oksel1 via write" (
  (okSel mem1 a)
)

valid "oksel2 via write" (
  (okSel (sel mem1 a) 2)
)

valid "oksel2b via write" (
  (okSel (sel mem1 a) 0)
)

notvalid "!oksel2b via write" (
  (okSel (sel mem1 a) -1)
)

valid "oksel2c via write" (
  (okSel (sel mem1 a) 9)
)

notvalid "!oksel2c via write" (
  (okSel (sel mem1 a) 10)
)

bg_pop


; -------------------- okSelOffset ----------------
valid "okselofs1" (
  (okSelOffset mem1 p0)
)

notvalid "!okselofs1" (
  (okSelOffset mem1 (sub a (sub 19 whole)))
)


; -------------------- addOffset ------------------
bg_push (
  (EQ p1 (addOffset p0 4))
)

valid "c" (
  (EQ p1 (sub a (sub 6 whole)))
)

notvalid "!c" (
  (EQ p1 (sub a (sub 2 whole)))
)

valid "okselofs2" (
  (okSelOffset mem1 p1)
)


; ------------------ appendIndex ---------------------
valid "d" (
  (EQ p1 (appendIndex (appendIndex whole a) 6))
)

notvalid "!d" (
  (EQ p1 (appendIndex (appendIndex whole a) 7))
)


; -------------- complicated example.. --------------
bg_push (
  ;(EQ (length (sel mem_33 addr_arr_2)) 10)
  (DISTINCT addr_arr_3 0)
  (uncheckedAccess mem_34)
  (EQ (length (sel mem_34 addr_arr_3)) 10)
  ;(EQ mem_35 (upd mem_34 addr_arr_3 arr_1))
)

valid "access1" (
  (okSel mem_34 addr_arr_3)
)

valid "access2" (
  (okSel (sel mem_34 addr_arr_3) 0)
)

valid "access2" (
  (okSel (sel mem_34 addr_arr_3) 9)
)

valid "check1" (
  (EQ (selOffset mem_34 (sub addr_arr_3 whole)) (sel mem_34 addr_arr_3))
)
                                                         
valid "final accesses" (
  (FORALL (i_30 )
    (IMPLIES
      (AND (<= 0 i_30) (< i_30 10))
      (okSelOffset mem_34 (addOffset (sub addr_arr_3 (sub 0 whole)) i_30))
    ))
)

bg_pop

; -------------- another example --------------
bg_push (
  (EQ y_8 (sel mem_34 addr_y_7))
  (DISTINCT addr_y_8 0)
  (uncheckedAccess mem_35)
  (EQ y_9 (sel mem_35 addr_y_8))
  (NEQ x_23 (sub addr_y_8 whole))
  (okSelOffset mem_35 x_23)
  (EQ mem_36 (updOffset mem_35 x_23 (+ (selOffset mem_35 x_23) 1)))
)

notvalid "x could point deep inside y, so y got modified" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole))
      (selOffset mem_35 (sub addr_y_8 whole)))
)

; provide additional information about x
bg_push (
  (EQ x_23 (sub x_object x_offset))
  (NEQ x_object addr_y_8)
)

valid "now it should work" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole))
      (selOffset mem_35 (sub addr_y_8 whole)))
)

bg_pop
bg_pop


; ------------------- firstIndexOf example ---------------
bg_push (
  (DISTINCT addr_y_8 0)
  (uncheckedAccess mem_35)
  (EQ y_9 (sel mem_35 addr_y_8))
  (NEQ (firstIndexOf x_23) (firstIndexOf (sub addr_y_8 whole)))
  (okSelOffset mem_35 x_23)
  (EQ mem_36 (updOffset mem_35 x_23 (+ (selOffset mem_35 x_23) 1)))
  (EQ x_23 (sub foo bar))
)

valid "unchanged" (
  (EQ (selOffset mem_36 (sub addr_y_8 whole)) 
      (selOffset mem_35 (sub addr_y_8 whole)))
)


; ------------------ okSelOffset after two updates --------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_23)
  (EQ ptr_4 (sub ptr_index_4 ptr_rest_4))
  (EQ x_10 (sub x_index_4 x_rest_4))
  (okSelOffset mem_23 ptr_4)
  (okSelOffset mem_23 x_10)
  (NEQ (firstIndexOf ptr_4) (firstIndexOf x_10))
  (EQ mem_24 (updOffset mem_23 ptr_4 5))

  ; currently my axioms only go the other way..
  ;(okSelOffset (sel mem_23 x_index_4) x_rest_4)

  ; try reversing it.. I added this to bgpred.sx ..
  ;   (FORALL (obj index rest)  ; (PATS (okSelOffset obj (sub index rest)))
  ;     (IMPLIES
  ;       (okSelOffset obj (sub index rest))
  ;       (AND
  ;         (okSel obj index)
  ;         (okSelOffset (sel obj index) rest)
  ;       )
  ;     ))
)

valid "implications" (
  (AND
    (okSelOffset (sel mem_23 x_index_4) x_rest_4)
    (NEQ ptr_index_4 x_index_4)
    (EQ mem_24 (upd mem_23 ptr_index_4
                 (updOffset (sel mem_23 ptr_index_4) ptr_rest_4 5)))
    (IMPLIES
      (okSelOffset (sel mem_24 x_index_4) x_rest_4)
      (okSelOffset mem_24 x_10)
    )
  )
)

valid "still ok" (
  ;(okSelOffset mem_24 x_10)
  (okSelOffset (sel mem_24 x_index_4) x_rest_4)
)


; ---------------------- okSelOffset after array ops -----------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_20)
  (EQ a_7 (sub a_index_7 a_rest_7))
  (EQ a_rest_7 (sub 0 whole))     ; will this help?  no..
;   (FORALL (i_7 )
;     (IMPLIES
;       (AND (<= 0 i_7) (< i_7 5))
;       (okSelOffset mem_20 (addOffset a_7 i_7))
;     ))
;   (FORALL (i_7 )
;     (IMPLIES
;       (AND (<= 0 i_7) (< i_7 5))
;       (okSelOffset mem_20 (sub a_index_7 (sub i_7 whole)))
;     ))                                  

  ; explicitly instantiating was the key..
  (okSelOffset mem_20 (sub a_index_7 (sub 1 whole)))
  
  (EQ mem_21 (updOffset mem_20 (addOffset a_7 0) 0))
  (EQ prevArray (sel mem_20 a_index_7))
)

valid "implications" (
  (AND
    (okSelOffset mem_20 (addOffset a_7 1))
    (EQ (addOffset a_7 1) (sub a_index_7 (sub 1 whole)))

    (okSelOffset mem_20 (sub a_index_7 (sub 1 whole)))
    (EQ mem_21 (upd mem_20 a_index_7 (upd prevArray 0 0)))
    (EQ (sel (sel mem_21 a_index_7) 0) 0)   ; a[0] is known
    (EQ (sel (sel mem_21 a_index_7) 1)
        (sel (sel mem_20 a_index_7) 1))     ; a[1] hasn't changed
        
    (EQ (sel mem_21 a_index_7)
        (upd prevArray 0 0))      ; new array is a[0 := 0]

    (okSel mem_21 a_index_7)

    (okSel prevArray 1)
  )
)

valid "access after mod" (
  ;(okSelOffset mem_21 (addOffset a_7 1))
  ;(okSelOffset mem_21 (sub a_index_7 (sub 1 whole)))
  ;(AND
    ;(okSel prevArray 1)
    ;(EQ (sel mem_21 a_index_7)
    ;    (upd prevArray 0 0))      ; new array is a[0 := 0]
    (okSel (upd prevArray 0 0) 1)
  ;)
)


bg_pop

; ----------------- length>=5 example ------------
bg_push (
  (DISTINCT 0)
  (uncheckedAccess mem_20)
  (EQ a_7 (sub a_index_7 a_rest_7))

  (>= (length (sel mem_20 (firstIndexOf a_7))) 5)
  ;(EQ (length (sel mem_20 (firstIndexOf a_7))) 5)

  (EQ (firstIndexOf (restOf a_7)) 0)
  
  (EQ a_rest_7 (sub index w_h_o_l_e))   ; I added this
  ;(EQ w_h_o_l_e whole)                  ; had to add this too
  (isWhole w_h_o_l_e)                   ; had to add this too
)

valid "implications" (
  (AND
    (EQ index 0)
  )
)

valid "access" (
  (okSelOffset mem_20 (addOffset a_7 0))
)
