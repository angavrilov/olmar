; indegree.sx    -*- Lisp -*-
; experiments relating to in-degree
               
; theory transferred from bgpred.sx
bg_push (
  ; ------------- tuple: "pointer" ---------------
  ; how to take apart a pointer
  (FORALL (b f)
    (EQ
      (object (pointer b f))
      b
    ))

  (FORALL (b f)
    (EQ
      (offset (pointer b f))
      f
    ))

  ; arithmetic does not change the object
  (FORALL (ptr ofs)           (PATS (object (+ ptr ofs)))
    (EQ
      (object (+ ptr ofs))
      (object ptr)
    ))
  (FORALL (ptr ofs)           (PATS (object (- ptr ofs)))
    (EQ
      (object (- ptr ofs))
      (object ptr)
    ))

  ; arithmetic changes the offset in the obvious way
  (FORALL (ptr ofs)           (PATS (offset (+ ptr ofs)))
    (EQ
      (offset (+ ptr ofs))
      (+ (offset ptr) ofs)
    ))
  (FORALL (ptr ofs)           (PATS (offset (- ptr ofs)))
    (EQ
      (offset (- ptr ofs))
      (- (offset ptr) ofs)
    ))

  ; fact that construction and deconstruction is identity
  ; pattern means this applies whenever both (object p) and
  ; (offset p) are around, for the same p
  (FORALL (p)                 (PATS (MPAT (object p) (offset p)))
    (EQ
      p
      (pointer (object p) (offset p))
    ))

  ; pointer disequality can be shown by showing either component
  ; is unequal
  (FORALL (obj1 obj2 ofs1 ofs2)
    (IMPLIES
      (OR
        (NEQ obj1 obj2)      ; different objects
        (NEQ ofs1 ofs2)      ; different offsets
      )
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
    ))

  ; --------------- theory: select/update ------------------
  ; reading from the same location as was last written
  (FORALL (mem obj ofs value)
    (EQ
      (select (update mem obj ofs value) obj ofs)
      value
    ))

  ; reading from a different location from last written
  (FORALL (mem obj1 obj2 ofs1 ofs2 value)
    (IMPLIES
      (NEQ (pointer obj1 ofs1) (pointer obj2 ofs2))
;       (OR
;         (NEQ obj1 obj2)      ; different objects
;         (NEQ ofs1 ofs2)      ; different offsets
;       )
      (EQ
        (select (update mem obj1 ofs1 value) obj2 ofs2)
        (select mem obj2 ofs2)
      )))

  ; you can read past a 'changed' marker, but only if you're
  ; reading from a different object
  (FORALL (mem obj1 obj2 ofs2)
    (IMPLIES
      (NEQ obj1 obj2)
      (EQ
        (select (changed mem obj1) obj2 ofs2)
        (select mem obj2 ofs2)
      )
    ))
)  

; -------------------- inDegree0 -----------------------
bg_push (
  ; three distinct objects
  (DISTINCT obj1 obj2 obj3)

  ; two distinct fields
  (DISTINCT next otherField)

  ; initially obj1 has nothing pointing to it
  (inDegree0 mem0 next obj1)
  (inDegree0 mem0 next obj3)     ; same for obj3

  ; then obj2 is modified to point at obj3
  (EQ mem1 (update mem0 obj2 next (pointer obj3 0)))
)

valid "inDegree0-surv-otherObj" (
  (inDegree0 mem1 next obj1)
)

notvalid "inDegree0-surv-otherObj" (
  (IMPLIES
    (EQ mem1b (update mem0 obj2 next (pointer obj4 0)))   ; obj4 could be obj1
    (inDegree0 mem1b next obj1)
  )
)

notvalid "inDegree0-surv-otherObj" (
  (IMPLIES
    (EQ mem1c (update mem0 obj2 next (pointer obj1 0)))    ; definitely points at obj1
    (inDegree0 mem1c next obj1)
  )
)

valid "inDegree0-surv-otherField" (
  (IMPLIES
    (EQ mem1d (update mem0 obj2 otherField (pointer obj3 0)))
    (inDegree0 mem1d next obj1)
  )
)

notvalid "inDegree0-surv-otherField" (
  (IMPLIES
    (EQ mem1e (update mem0 obj2 ambigField (pointer obj1 0)))   ; possibly ambigField==next
    (inDegree0 mem1e next obj1)
  )
)


valid "inDegree0-no-point" (
  (NEQ (object (select mem0 obj3 next)) obj1)
)

valid "inDegree0-no-point via pointer" (
  (NEQ (select mem0 obj3 next) (pointer obj1 0))
)

valid "inDegree0-no-point in mem1" (
  (NEQ (object (select mem1 obj3 next)) obj1)
)


; ------------- inDegree0 to inDegree1 ----------------
valid "inDegree0-to-inDegree1" (
  (inDegree1 mem1 next obj3 obj2)
)

notvalid "inDegree0-to-inDegree1" (
  (inDegree1 mem1 next obj1 obj2)
)


; ------------------ inDegree1 ------------------------
valid "inDegree1-surv-otherObj" (
  (IMPLIES
    (EQ mem2 (update mem1 obj3 next (pointer obj1 0)))
    (inDegree1 mem2 next obj3 obj2)
  )
)

notvalid "inDegree1-surv-otherObj" (
  (IMPLIES
    (EQ mem2b (update mem1 obj3 next (pointer obj3 0)))
    (inDegree1 mem2b next obj3 obj2)
  )
)

valid "inDegree1-surv-otherField" (
  (IMPLIES
    (EQ mem2c (update mem1 obj1 otherField (pointer obj3 0)))
    (inDegree1 mem2c next obj3 obj2)
  )
)

notvalid "inDegree1-surv-otherField" (
  (IMPLIES
    (EQ mem2d (update mem1 obj1 ambigField (pointer obj3 0)))
    (inDegree1 mem2d next obj3 obj2)
  )
)

bg_push (
  (inDegree1 memFoo next obj1 obj2)
)

valid "inDegree1-one-point" (
  (EQ (object (select memFoo obj2 next)) obj1)
)

notvalid "inDegree1-one-point" (
  (EQ (object (select memFoo obj3 next)) obj1)
)

valid "inDegree1-none-other" (
  (NEQ (object (select memFoo obj3 next)) obj1)
)

bg_pop
bg_pop

; -------------- inDegree1 to inDegree0 -----------------
bg_push (
  ; three distinct objects
  (DISTINCT 0 obj1 obj2 obj3)

  ; two distinct fields
  (DISTINCT next otherField)

  ; initially obj1 points to obj2
  (inDegree1 mem0 next obj2 obj1)

  ; then obj1 is changed
  (EQ mem1 (update mem0 obj1 next (pointer 0 0)))
)

valid "inDegree1-to-inDegree0" (
  (inDegree0 mem1 next obj2)
)

notvalid "inDegree1-to-inDegree0" (
  (inDegree0 mem1 next obj1)
)
        


; (IMPLIES
;   (AND
;     (DISTINCT 0)

;     (EQ (offset head_19) 0)
;     (NEQ (object head_19) 0)
;     (hasTypeNode (object head_19))
;     (OR (inDegree0 mem_40 next_32 (object head_19)) (EXISTS (refObj_55 ) (inDegree1 mem_40 next_32 (object head_19) refObj_55)))
;     (IMPLIES (NEQ (select mem_40 (object head_19) next_32) (pointer 0 0)) (hasTypeNode (object (select mem_40 (object head_19) next_32))))

;     (EQ (offset toAdd_19) 0)
;     (NEQ (object toAdd_19) 0)
;     (hasTypeNode (object toAdd_19))
;     (OR (inDegree0 mem_40 next_32 (object toAdd_19)) (EXISTS (refObj_56 ) (inDegree1 mem_40 next_32 (object toAdd_19) refObj_56)))
;     (IMPLIES (NEQ (select mem_40 (object toAdd_19) next_32) (pointer 0 0)) (hasTypeNode (object (select mem_40 (object toAdd_19) next_32))))

;     (inDegree0 mem_40 next_32 (object toAdd_19))
    
;     (EQ somePtr (select mem_40 (object p_14) (+ (offset p_14) next_32)))

;     (NEQ somePtr (pointer 0 0))

;     (EQ (select mem_40 (object somePtr) (+ (offset somePtr) next_32)) (pointer 0 0))

;     (EQ mem_41 (update mem_40 (object somePtr) (+ (offset somePtr) next_32) toAdd_19))
;   )
;   (EXISTS (refObj_58 )
;     (inDegree1 mem_41 next_32 (object toAdd_19) refObj_58))
; )
