// cc.gr
// my attempt to implement a grammar for C++

// I'm actually trying to use this single file for both C and C++;
// the C++ grammar should parse C ok


// grab list generated by lexer
terminals {
  include("cc.tok")
}


// declarations for semantic functions
literalCode "prologue" {
  #include "cc_env.h"    // Env
  #include "cc_tree.h"   // CCTreeNode
  #include "cc_cfg.h"    // CFG, etc.
  #include "dataflow.h"  // DataflowEnv
  #include "cil.h"       // CilXXX stuff (C Intermediate Language)
  #include "ckheap.h"    // checkHeap

  // provide easy-to-grep-for (and easy-to-put-a-breakpt) names for
  // places I haven't implemented the Cil translation
  CilExpr *todoCilExpr();
  CilInst *todoCilInst();
  
  // this is for places where there is no value
  // for a construct
  inline CilExpr *noCilValue() { return NULL; }
  

  // stuff related to exporting data to ocaml
  #ifdef WES_OCAML_LINKAGE
    #include "caml/mlvalues.h"
    #include "caml/alloc.h"
    #include "caml/memory.h"
    struct wes_ast_node {
        const char *name;
        int num_children;
        int line, col;
        struct wes_ast_node ** children;
    };
    struct wes_list {
        struct wes_ast_node * hd;
        struct wes_list * tl;
    };
  #endif /* WES_OCAML_LINKAGE */
}

// use a custom base class
treeNodeBase "CCTreeNode";


// dummy first rule
nonterm StartSymbol -> TranslationUnit L2_EOF;


// ------------- identifier ambiguity -------------------
// identifiers can play a number of roles, and this is the
// source of problems parsing C and C++
// (here, "variable" means variable or function; it names
// an object that exists at runtime)
nonterm HasName {
  fundecl string getName() const;
  fun getName = n.nameValue;
}
nonterm TypedefName : HasName -> n:L2_NAME   ;
nonterm EnumName : HasName -> n:L2_NAME      ;
nonterm EnumValueName : HasName -> n:L2_NAME ;     // called 'enumerator' in spec
nonterm ClassName : HasName -> n:L2_NAME     ;
nonterm TemplateName : HasName -> n:L2_NAME  ;
nonterm VariableName : HasName -> n:L2_NAME  ;
nonterm LabelName : HasName -> n:L2_NAME     ;


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------
nonterm Checkable {
  // this does several jobs:
  //   - check type consistency, and report errors where
  //     inconsistencies are found
  //   - add new symbols to the environment, with their types
  //   - return an expression ptr for the value of the
  //     language construct, when evaluated as an expression
  //     (deliberately vague here, for now..)
  fundecl CilExpr *typeCheck(Env *passedEnv, CilInstructions &inst);

  // first thing in every typeCheck function
  literalCode "prefix" typeCheck {
    env = passedEnv;
  }

/*
  // the problem is I can't call 'typeCheck' unless I have
  // a C++ class from which they're derived.. I'll put that
  // on hold for now, because it's not perfectly clear just
  // how common it will be to want to automate the walk
  // like this...

  // default behavior is to simply check all (nonterminal) subtrees
  // (ideal would be to check only 'Checkable' ones, but right
  // now I have no runtime way to determine that)
  fun typeCheck {
    // for now, no disambiguation
    Reduction const *red = only();

    FOREACH_OBJLIST(TreeNode, red->children, iter) {
      if (iter.data()->isNonterm()) {
      }
    }
  }
*/

  // so for now default impl is to do nothing
  fun typeCheck = NULL;
}

nonterm TranslationUnit : Checkable {
  // simple indirection so I can print just the d's
  fundecl void printTree();
  fun printTree {}      // NOP; never called
  
  // entry point to gather an ocaml ast; this *overrides*
  // the camlAST declared in glrtree.h; can't say 'virtual',
  // however, because this decl text is also emitted for
  // the fn definition
  fundecl /*virtual*/ struct wes_ast_node *camlAST();

  -> empty {
    fun camlAST { // return our ocaml AST
      #ifdef WES_OCAML_LINKAGE
        struct wes_ast_node * retval = new struct wes_ast_node;
        retval->name = "empty parse tree";
        retval->num_children = 0;
        retval->children = NULL;
        retval->line = retval->col = 0;
        return retval;
      #else /* WES_OCAML_LINKAGE */
        return NULL;
      #endif /* WES_OCAML_LINKAGE */
    }
  }

  -> t:TranslationUnit d:Declaration {
    fun typeCheck {
      delete t.typeCheck(env, inst);

      try {
        delete d.typeCheck(env, inst);
      }
      catch (XSemanticError &x) {
        // error recovery; report and proceed
        env->report(x.err);
      }
      env->flushLocalErrors(cout);

      return noCilValue();
    }

    fun printTree {
      if (tracingSys("parse-sexp")) {
        // I really just want a sequence of declarations, so just
        // print d's tree
        d.printParseTree(cout, 2 /*indent*/, true /*asSexp*/);
        cout << endl;
      }

      if (tracingSys("parse-tree")) {
        d.printParseTree(cout, 2 /*indent*/, false /*asSexp*/);
      }
    }

    fun camlAST {
      return d.camlAST();
    }
  }

  // allow assembly at toplevel for gnu compatibility
  -> t:TranslationUnit a:GNUAsmStatement {
    fun typeCheck {
      return t.typeCheck(env, inst);
    }
    
    fun camlAST {
      // sm: I'm suspicious of this .. if I wasn't doing analysis
      // on each function before processing the next, this would
      // prevent camlAST from visiting anything before the last
      // toplevel ASM ..
      return a.camlAST();
    }
  }

  literalCode "constructor" {
    // if we just constructed the "-> empty" production,
    // do nothing special
    if (red->children.isEmpty()) {
      return;
    }

    // cast context argument
    env = (Env*)(tree.extra);

    // clear the existing dataflow environment (effect is we
    // don't analyze globals ....)
    env->getDenv().reset();

    // debugging..
    trace("typeCheck") << locString() << endl;

    // run the analysis on this piece of the tree
    CilCompound *cil = newCompound();
    delete typeCheck(env, *cil);

    #ifdef WES_OCAML_LINKAGE
      // this is a hideous hack, but I cannot actually pass return values
      // around through scott's code
      // sm: yeah, we're in a C++ constructor here so return
      // values are tricky ...
      {
	extern struct wes_list * wes_result_list; // declared below 
        struct wes_list * new_cell = new struct wes_list;
        new_cell->hd = camlAST();
        new_cell->tl = wes_result_list;
        wes_result_list = new_cell;
      }
    #endif /* WES_OCAML_LINKAGE */

    #ifndef WES_OCAML_LINKAGE
    // this is, more or less, the product of the analysis
    // but ocaml users do not want to see it ...
    printTree();
    #endif /* WES_OCMAL_LINKAGE */

    // or this
    if (tracingSys("cil-tree")) {
      cil->printTreeNoBraces(0 /*indent*/, cout);
    }
    checkHeap();     // TODO1: remove when bug is fixed
    delete cil;
    checkHeap();

    // ---- throw away most of the tree now ----
    // grab a pointer to the left child reduction, which should be
    // an instance of "TranslationUnit -> empty"
    NonterminalNode *leftNT = &( red->children.nth(0)->asNonterm() );
    Reduction *leftReduction = leftNT->only();

    // the tree right now looks like this:
    //             'this': NonterminalNode
    //                         |
    // 'red': TranslationUnit -> TranslationUnit Declaration
    //                            /                   \           .
    //      'leftNT': NonterminalNode      (code just analyzed)
    //                           |
    // 'leftReduction': TranslationUnit -> empty
    //                      (no children)

    // of these, all the NonterminalNodes are in the 'treeNodes'
    // list except for 'this'

    // let's verify some of this
    xassert(reductions.count() == 1);
    xassert(red->children.count() == 2);
    xassert(leftNT->reductions.count() == 1);
    xassert(leftReduction->children.count() == 0);

    // the goal is to throw away everything except for
    // 'leftNT' and below .. to maintain the invariant that
    // all NonterminalNodes have at least one reduction,
    // we'll simply swap 'red' and 'leftReduction'

    // first, remove from both..
    this->reductions.removeItem(red);
    leftNT->reductions.removeItem(leftReduction);

    // .. now add back to opposite one
    this->reductions.prepend(leftReduction);
    leftNT->reductions.prepend(red);

    // blow away all the other tree nodes; this deletes everything
    // except 'this' and its newly-acquired 'leftReduction'

    // we must kill the parent links first (this is, in essence
    // the *big* *fix* to my earlier corruption errors)
    MUTATE_EACH_OBJLIST(TreeNode, tree.treeNodes, iter) {
      iter.data()->killParentLink();
    }

    // now do the real deallocations
    tree.treeNodes.deleteAll();
  }
}

// ------ A.4 Expressions ------
nonterm HasType {
  // return the Type represented by this syntax
  fundecl Type const *getType(Env *passedEnv);
  literalCode "prefix" getType {
    env = passedEnv;
  }

  // by default, and on error cases:
  fun getType {
    throwError("I don't know this kind of expression's type");
  }
}

// base class for expressions
nonterm ExprBase : Checkable, HasType {
  // return the integer this expression evaluates to at compile time
  fundecl int intEval(Env *passedEnv);
  fun intEval { throwError("not a constant integer expression"); }
  literalCode "prefix" intEval {
    env = passedEnv;
  }
}


nonterm PrimaryExpression : ExprBase {
  -> e:Literal {
    fun intEval = e.intEval(env);
    fun getType = e.getType(env);
    fun typeCheck {
      try {
        return newIntLit(intEval(env));
      }
      catch (...) {
        // not an int .. no current repr in Cil
        return todoCilExpr();
      }
    }
  }

  -> "this"                     {}

  formGroup {
    fun getType = e.getType(env);

    -> "(" e:Expression ")" {
      fun intEval = e.intEval(env);
      fun typeCheck = e.typeCheck(env, inst);
    }

    -> e:PQVarName {
      fun typeCheck = newVarRef(e.typeCheck(env));
    }
  }

  // GNU extension
  -> "(" s:CompoundStatement ")"
    { fun typeCheck = s.typeCheck(env, inst); }
}

nonterm Literal : ExprBase {
  -> i:L2_INT_LITERAL {
    fun intEval = i.intValue;
    fun getType = env->getSimpleType(ST_INT);
  }
  -> L2_FLOAT_LITERAL | L2_STRING_LITERAL | L2_CHAR_LITERAL ;
}


// base class for nonterminals that yield a part of a
// string that describes a type
nonterm HasTypeName {
  // return either a complete type description, or part
  // of one to be concatenated in context
  fundecl string typeName();

  // default implementation: just yield the original input
  fun typeName = unparseString();
}

nonterm HasDeclName {
  // retrieve the name of the variable being declared
  fundecl string getDeclName();

  // again, for now, take the easy road
  fun getDeclName = unparseString();
}


// possibly-qualified name; essentially spec's id-expression
// missing: template-id because I don't know what that is
nonterm PQVarName : HasTypeName, HasDeclName, HasType {
  fundecl Variable *typeCheck(Env *passedEnv);
  literalCode "prefix" typeCheck {
    env = passedEnv;
  }

  // 'colonColon' attribute of PQVarName and Qualifier: set to 1 when "::" is
  // the leftmost token in the tree matched; this is important because
  // declarators aren't allowed to have the bare "::" qualifier
  attr colonColon;        // true if a bare "::" is in front

  -> n:VariableName {
    action colonColon := 0;
    fun typeCheck {
      env = passedEnv;
      if (!env->isDeclaredVar(n.getName())) {
        SemanticError err(this, SE_UNDECLARED_VAR);
        err.varName = n.getName();
        
        // TODO2: is this a good idea?
        THROW(XSemanticError(err));
      }
      return env->getVariable(n.getName());
    }

    fun getType {
      if (!env->isDeclaredVar(n.getName())) {
        throwError("tried to get type of an undeclared identifier");
      }
      else {
        Variable *v = env->getVariable(n.getName());
        xassert(v);
        xassert(v->type);    // having trouble with gdb ... !
        return v->type;
      }
    }
  }

  fun typeCheck {
    // each of the remaining rules requires some more sophisticated
    // way of naming symbols
    throwError("typeCheck unimplemented for complicated names");
  }

  -> OperatorFunctionId     { action colonColon := 0; }
  -> ConversionFunctionId   { action colonColon := 0; }
  -> "~" ClassName          { action colonColon := 0; }
  -> q:Qualifier rhs:PQVarName  {
    // this PQVarName is preceeded by :: if the Qualifier is
    action colonColon := q.colonColon;

    // can't put any more qualifiers on to left of ::
    condition rhs.colonColon == 0;
  }
}

nonterm Qualifier {
  attr colonColon;     // true for leading "::"

  -> "::"              { action colonColon := 1; }
  -> ClassName "::"    { action colonColon := 0; }
}


nonterm PostfixExpression : ExprBase {
  -> e:PrimaryExpression {
    fun intEval = e.intEval(env);
    fun getType = e.getType(env);
    fun typeCheck = e.typeCheck(env, inst);
  }
                                                         
  // array access
  -> p:PostfixExpression "[" e:Expression "]" {
    fun typeCheck {
      Owner<CilExpr> array; array = p.typeCheck(env, inst);
      Owner<CilExpr> index; index = e.typeCheck(env, inst);
      return newArrayAccess(array.xfr(), index.xfr());
    }
  }

  // fn call
  -> p:PostfixExpression "(" e:ExpressionListOpt ")" {
    fun typeCheck {
      // check the fn name
      Owner<CilExpr> fn; fn = p.typeCheck(env, inst);

      Type const *origFnType = typeOf(fn, env);
      Type const *fnType = origFnType;
      if (fnType->isPointerType()) {
        // you get 1 free dereference when computing
        // a function to call
        fnType = fnType->asPointerTypeC().atType;
      }

      if (!fnType->isFunctionType()) {
        throwError(stringc
          << "expression `" << fn->toString() << "' has type `"
          << origFnType->toString() << "', which is neither a "
          << "function type nor a pointer to a function type");
      }

      // get its return type
      Type const *retType = fnType->asFunctionTypeC().retType;

      // need a temprary for the result
      Variable *result = env->newTmpVar(retType);
      inst.append(newVarDecl(result));

      // make a CIL object to hold the call
      Owner<CilFnCall> call; 
      call = newFnCall(newVarRef(result), fn.xfr());

      // check the arglist, adding the arguments to the
      // 'call' object
      e.typeCheck(env, inst, call);

      // insert the call into the list of instructions
      inst.append(call.xfr());

      if (!env->isTrialBalloon() &&
          p.getLeftmostTerminalC()->token->unparseString().equals("free")) {
        // conditions for analysis
        if (e.numGroundTerms() == 1) {
          ana_free(e.unparseString());
        }
        else {
          cout << locString() << ": can't analyze\n";
        }
      }

      // anything that uses this call can get the value
      // from the temporary I created
      return newVarRef(result);
    }
  }


  // field access or deref + field access
  -> p:PostfixExpression op:FieldAccessOp n:PQVarName {
    fun typeCheck {
      // check the left side
      Owner<CilExpr> record; record = p.typeCheck(env, inst);

      // look up its type
      Type const *type = record->getType(env);

      if (op.unparseString().equals("->")) {      // HACK!
        // deref the type
        if (!type->isPointerType()) {
          throwError(stringc
            << "left side of `->' (" << record->toString()
            << ") must be a *pointer* to a struct; its type is "
            << type->toString());
        }

        // deref
        record = newDeref(record.xfr());
        type = type->asPointerTypeC().atType;
      }
       
      // the type should be a structure whose fields we can access
      if (!( type->isCVAtomicType() &&
             type->asCVAtomicTypeC().atomic->isCompoundType() )) {
        throwError(stringc <<
          "left side of `" << op.unparseString() <<
          "' must be a struct");
      }
      CompoundType const &ctype =
        type->asCVAtomicTypeC().atomic->asCompoundTypeC();

      if (ctype.env == NULL) {
        throwError(stringc
          << "can't access field of " << record->toString()
          << " because its type (" << ctype.toString()
          << ") is incomplete (it's only forward-declared)");
      }

      // check the right side in the context of the
      // struct we just found
      Owner<Variable> field; field = n.typeCheck(ctype.env);

      return newFieldRef(record.xfr(), field.xfr());
    }
  }

  -> p:PostfixExpression op:IncOp {
    fun typeCheck {
      // get expression being incremented
      Owner<CilLval> lval; lval = asLval(p.typeCheck(env, inst));

      // save old value
      Variable *tmp = env->newTmpVar(typeOf(lval, env));
      inst.append(newVarDecl(tmp));
      inst.append(newAssign(newVarRef(tmp), lval->clone()));

      // increment the expression
      BinOp bop = (op.unparseString()[0]=='+')? OP_PLUS : OP_MINUS;     // hack
      Owner<CilLval> lhs; lhs = lval->clone();
      inst.append(newAssign(lhs.xfr(), newBinExpr(bop, lval.xfr(), newIntLit(1))));

      // return a reference to the old value
      return newVarRef(tmp);
    }
  }

  // pulled these two because other rules supercede them
  //-> PostfixExpression "." PseudoDestructorName           ; // explicit dtor call
  //-> PostfixExpression "->" PseudoDestructorName          ;

  formGroup {
    fun typeCheck = e.typeCheck(env, inst);

    -> "dynamic_cast"     "<" TypeId ">" "(" e:Expression ")" ;   // casts
    -> "static_cast"      "<" TypeId ">" "(" e:Expression ")" ;
    -> "reinterpret_cast" "<" TypeId ">" "(" e:Expression ")" ;
    -> "const_cast"       "<" TypeId ">" "(" e:Expression ")" ;
  }

  // removed for now since I don't know much about them
  //-> "typeid" "(" Expression ")"                          ;   // RTTI
  //-> "typeid" "(" TypeId ")"                              ;
}

// TODO: revise grammar syntax so I can name productions
// directly, and avoid these silly indirections
nonterm IncOp -> "++" | "--";                  
nonterm FieldAccessOp -> "." | "->";

nonterm ExpressionList {
  fundecl void typeCheck(Env *passedEnv, CilInstructions &inst, CilFnCall *call);
  literalCode "prefix" typeCheck {
    env = passedEnv;
  }

  -> a:AssignmentExpression {
    fun typeCheck {
      call->appendArg(a.typeCheck(env, inst));
    }
  }

  -> e:ExpressionList "," a:AssignmentExpression {
    fun typeCheck {
      e.typeCheck(env, inst, call);
      call->appendArg(a.typeCheck(env, inst));
    }
  }
}

nonterm ExpressionListOpt {
  fundecl void typeCheck(Env *passedEnv, CilInstructions &inst, CilFnCall *call);
  literalCode "prefix" typeCheck {
    env = passedEnv;
  }

  -> empty
    { fun typeCheck {} }
  -> e:ExpressionList
    { fun typeCheck { e.typeCheck(env, inst, call); } }
}

// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName
//PseudoDestructorName -> Qualifier PseudoDestructorName

nonterm UnaryExpression : ExprBase {
  // TODO: better abstraction of this mechanism
  literalCode "disamb" typeCheck {
    return disambiguate(passedEnv, inst, (DisambFn)&UnaryExpression_Node::unamb_typeCheck);
  }

  formGroup {
    fun typeCheck = e.typeCheck(env, inst);

    -> e:PostfixExpression {
      fun intEval = e.intEval(env);
      fun getType = e.getType(env);
    }

    -> op:IncOp e:CastExpression {
      fun typeCheck {
        Owner<CilLval> lval; lval = asLval(e.typeCheck(env, inst));

        // increment the expression
        BinOp bop = op.unparseString()[0]=='+'? OP_PLUS : OP_MINUS;     // hack
        Owner<CilLval> lhs; lhs = lval->clone();
        Owner<CilLval> rhs; rhs = lval->clone();
        inst.append(newAssign(lhs.xfr(), newBinExpr(bop, rhs.xfr(), newIntLit(1))));

        // return a reference to the incremented lval
        return lval.xfr();
      }
    }

    // size of expression
    -> "sizeof" e:UnaryExpression {
      fun intEval {
        Type const *type = e.getType(env);
        xassert(type);
        return type->reprSize();
      }

      fun typeCheck {
        delete e.typeCheck(env, inst);

        ostream &os = trace("sizeof") << locString() << ": sizeof(expr) is ";
        try {
          int s = intEval(env);
          os << s << endl;
          setTheInt(s);
        }
        catch (xBase &x) {
          os << "unknown (reason: " << x << ")\n";
        }

        return newIntLit(intEval(env));
      }

      fun getType = e.getType(env);
    }

    -> e:DeleteExpression              ;
  }

  // dereference
  -> "*" e:CastExpression {
    fun intEval { throwError("can't intEval"); }

    fun typeCheck {
      // check arg
      Owner<CilExpr> expr; expr = e.typeCheck(env, inst);
      
      // check that it's a pointer type
      Type const *type = typeOf(expr, env);
      if (!type->isPointerType()) {
        throwError(stringc
          << "the `*' operator is for dereferencing pointers; `"
          << expr->toString() << "' has type " << type->toString());
      }

      e.ana_checkDeref();
      
      return newDeref(expr.xfr());
    }

    fun getType {
      Type const *derefd = e.getType(env);
      if (!derefd->isPointerType()) {
        throwError("don't dereference things that aren't pointers");
      }
      PointerType const &pt = derefd->asPointerTypeC();

      return pt.atType;      // type of thing pointed at
    }
  }


  // other unary operators
  formGroup {
    fun getType {
      throwError("it's a unary operator I don't handle yet for getType");
    }

    -> "&" e:CastExpression {
      fun intEval { throwError("can't apply this operator to an integer"); }

      fun typeCheck {
        Owner<CilLval> lval; lval = asLval(e.typeCheck(env, inst));
        return newAddrOfExpr(lval.xfr());
      }
    }

    -> "+" e:CastExpression {
      fun intEval = e.intEval(env);
      fun typeCheck = e.typeCheck(env, inst);
    }

    -> "-" e:CastExpression {
      fun intEval = -e.intEval(env);
      fun typeCheck = newUnaryExpr(OP_NEGATE, e.typeCheck(env, inst));
    }

    -> "!" e:CastExpression {
      fun intEval = !e.intEval(env);
      fun typeCheck = newUnaryExpr(OP_NOT, e.typeCheck(env, inst));
    }

    -> "~" e:CastExpression {
      fun intEval = ~e.intEval(env);
      fun typeCheck = newUnaryExpr(OP_BITNOT, e.typeCheck(env, inst));
    }
  }

  -> "sizeof" "(" t:TypeId ")" {               // size of type
    fun typeCheck {
      t.getType(env);     // just make sure it's a valid type, for disambiguation

      ostream &os = trace("sizeof") << locString() << ": sizeof(type) is ";
      try {
        int s = intEval(env);
        os << s << endl;
        setTheInt(s);
      }
      catch (xBase &x) {
        os << "unknown (reason: " << x << ")\n";
      }

      return newIntLit(intEval(env));
    }

    fun intEval {
      Type const *type = t.getType(env);
      if (type) {
        return type->reprSize();
      }
      else {
        throwError("unknown type");
      }
    }
  }

  -> NewExpression                   ;
}


// for now, no new-placement or "::" in front
// I've changed the syntax slightly to correct what I think is a mistake
// (my syntax allows array of ptr to fn, whereas std syntax doesn't -- TOVERIFY)
nonterm NewExpression {
  -> "new" TypeSpecifier NewDeclaratorOpt NewInitializerOpt ;
  -> "new" "(" TypeId ")" NewDeclaratorOpt NewInitializerOpt ;
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]")?  ("[" ConstExpression "]")*
nonterm NewDeclaratorOpt -> empty |
                            PtrOperator NewDeclaratorOpt |
                            DirectNewDeclarator ;        // commit to at least one "[" ... "]"
nonterm DirectNewDeclarator -> "[" Expression "]" |
                               DirectNewDeclarator "[" ConstantExpression "]" ;

nonterm NewInitializerOpt -> empty | "(" ExpressionListOpt ")" ;

// omitting possibility of initial "::"
nonterm DeleteExpression : Checkable {
  fun typeCheck {
    /*Owner<CilExpr> expr; expr =*/ delete e.typeCheck(env, inst);
    //inst.append(newFreeInst(expr.xfr()));
    return noCilValue();     // TODO3: is this correct according to C++ std?
  }

  -> "delete" e:CastExpression ;
  -> "delete" "[" "]" e:CastExpression ;
}

nonterm CastExpression : ExprBase {

  // added this to disambiguate fn calls and casts
  literalCode "disamb" typeCheck {
    return disambiguate(passedEnv, inst, (DisambFn)&CastExpression_Node::unamb_typeCheck);
  }

  -> e:UnaryExpression {
    fun intEval = e.intEval(env);
    fun typeCheck = e.typeCheck(env, inst);
    fun getType = e.getType(env);
  }

  -> "(" t:TypeId ")" e:CastExpression {
    fun typeCheck {
      Type const *type = t.getType(env);
      Owner<CilExpr> expr; expr = e.typeCheck(env, inst);
      if (isLval(expr)) {
        return newCastLval(type, asLval(expr.xfr()));
      }
      else {
        return newCastExpr(type, expr.xfr());
      }
    }

    fun getType {
      // should check castability ...
      return t.getType(env);
    }
  }
}

// ++++ binary operator expression ++++
// primary expressions
nonterm BinaryExpression : ExprBase {
  attr prec;                  // precedence of binding (topmost) operator in expression

  literalCode "disamb" typeCheck {
    return disambiguate(passedEnv, inst, (DisambFn)&BinaryExpression_Node::unamb_typeCheck);
  }

  -> e:CastExpression {
    action  prec := 100;      // higher precedence than anything else

    fun intEval = e.intEval(env);
    fun typeCheck = e.typeCheck(env, inst);
    fun getType = e.getType(env);
  }

  formGroup {
    action  prec := op.prec;

    condition  this.prec <= left.prec;             // precedence
    condition  this.prec <= right.prec;            // more precedence
    condition  op.leftAssoc == 1 ?
                 this.prec < right.prec :          // left associative
                 this.prec < left.prec;            // right associative

    fun getType {
      return left.getType(env);      // more omitted consistency checks ...
    }

    fun intEval = op.intEval(left.intEval(env), right.intEval(env));

    -> left:BinaryExpression op:BinaryOperator right:BinaryExpression {
      fun typeCheck {
        Owner<CilExpr> L; L = left.typeCheck(env, inst);
        Owner<CilExpr> R; R = right.typeCheck(env, inst);
        BinOp bop = op.getOp();
        return newBinExpr(bop, L.xfr(), R.xfr());
      }
    }

    -> left:BinaryExpression op:ShortCircuitLogical right:BinaryExpression {
      fun typeCheck {
        // the code is written as if we're doing "||"; "&&" differs only
        // at the end

        // TODO2: are these operators guaranteed to return 0 or 1?
        // the code emitted now doesn't necessarily do that..

        // need a temprary for the result of this computation
        Variable *result = env->newTmpVar(env->getSimpleType(ST_INT));
        inst.append(newVarDecl(result));

        // evaluate left operand, and give the result a name
        Owner<CilExpr> L; L = left.typeCheck(env, inst);

        // create the code to execute if 'L' is true
        Owner<CilInst> leftTrue;
                       leftTrue = newAssign(newVarRef(result), L->clone());

        // create the code to execute if 'L' is false
        Owner<CilCompound> evalRight; evalRight = newCompound();
        {
          // evaluate right operand, putting code into 'evalRight'
          Owner<CilExpr> R; R = right.typeCheck(env, *evalRight);

          // store R into the result
          evalRight->append(newAssign(newVarRef(result), R.xfr()));
        }

        // combine the test and both branches
        if (op.unparseString().equals("||")) {     // TODO2: HACK!
          inst.append(newIfThenElse(L.xfr(),              // if (left)
                                    leftTrue.xfr(),       //   tmp = left;   <-- no side effects
                                    evalRight.xfr()));    // else tmp = right;
        }
        else {
          // to handle "&&", just reverse the sense of the 'if'
          inst.append(newIfThenElse(L.xfr(),              // if (left)
                                    evalRight.xfr(),      //   tmp = right;
                                    leftTrue.xfr()));     // else tmp = left;   <-- no side effects
        }

        // finally, the result of all this is the new temporary
        return newVarRef(result);
      }
    }
  }
}

nonterm BinOpBase {
  attr prec;             // precedence of operator; higher value binds more tightly
  attr leftAssoc;        // 1 means left-associative, 0 means right-associative

  // all have left precedence by default; can override individually
  action  leftAssoc := 1;

  // return this operator's effect on integers
  fundecl int intEval(int left, int right);

  // return this operator's intermediate repr
  fundecl BinOp getOp();
}

// an operator in a binary expression
nonterm BinaryOperator : BinOpBase {
  // highest precedence
  // (don't need .* and ->* right now...)
  //formGroup {
  //  action prec:=64;
  //  -> ".*" | "->*"     { fun intEval { throwError("can't apply this operator to integers"); } }
  //}

  formGroup {
    action prec:=60;
    -> "*"              { fun intEval = left * right;   fun getOp = OP_TIMES; }
    -> "/"              { fun intEval = left / right;   fun getOp = OP_DIVIDE; }
    -> "%"              { fun intEval = left % right;   fun getOp = OP_MOD; }
  }

  formGroup {
    action prec:=56;
    -> "+"              { fun intEval = left + right;   fun getOp = OP_PLUS; }
    -> "-"              { fun intEval = left - right;   fun getOp = OP_MINUS; }
  }

  formGroup {
    action prec:=52;
    -> "<<"             { fun intEval = left << right;   fun getOp = OP_LSHIFT; }
    -> ">>"             { fun intEval = left >> right;   fun getOp = OP_RSHIFT; }
  }

  formGroup {
    action prec:=48;
    -> "<"              { fun intEval = left < right;   fun getOp = OP_LT; }
    -> ">"              { fun intEval = left > right;   fun getOp = OP_GT; }
    -> "<="             { fun intEval = left <= right;   fun getOp = OP_LTE; }
    -> ">="             { fun intEval = left >= right;   fun getOp = OP_GTE; }
  }

  formGroup {
    action prec:=44;
    -> "=="             { fun intEval = left == right;   fun getOp = OP_EQUAL; }
    -> "!="             { fun intEval = left != right;   fun getOp = OP_NOTEQUAL; }
  }

  -> "&" {
    action prec:=40;      fun intEval = left & right;    fun getOp = OP_BITAND;
  }

  -> "^" {
    action prec:=36;      fun intEval = left ^ right;    fun getOp = OP_BITXOR;
  }

  -> "|" {
    action prec:=32;      fun intEval = left | right;    fun getOp = OP_BITOR;
  }
}

// pulled these out to implement short-circuit evaluation for booleans
nonterm ShortCircuitLogical : BinOpBase {
  -> "&&" {
    action prec:=28;        fun intEval = left && right;   fun getOp = OP_AND;
  }

  -> "||" {
    action prec:=24;        fun intEval = left || right;   fun getOp = OP_OR;
  }
  // lowest precedence
}
// ---- end of binary operator expression ----


nonterm ConditionalExpression : ExprBase {
  literalCode "disamb" typeCheck {
    return disambiguate(passedEnv, inst, (DisambFn)&ConditionalExpression_Node::unamb_typeCheck);
  }

  -> e:BinaryExpression {
    fun intEval = e.intEval(env);
    fun typeCheck = e.typeCheck(env, inst);
    fun getType = e.getType(env);
  }

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression {
    fun intEval {
      // evaluate all of them first, so we get the check for the
      // expression being const regardless of which way the test goes
      // (this may in fact turn out to be wrong, but for now it's what
      // I think it should be)
      int c = cond.intEval(env);
      int t = th.intEval(env);
      int e = el.intEval(env);
      return c ? t : e;
    }

    fun typeCheck {
      // grab guard expression
      Owner<CilExpr> condExpr;
                     condExpr = cond.typeCheck(env, inst);

      // figure out what it will take to evaluate the 'then'
      Owner<CilCompound> thenInsts; thenInsts = newCompound();
      Owner<CilExpr> thenExpr;
                     thenExpr = th.typeCheck(env, *thenInsts);

      // simiarly for 'else'
      Owner<CilCompound> elseInsts; elseInsts = newCompound();
      Owner<CilExpr> elseExpr;
                     elseExpr = el.typeCheck(env, *elseInsts);

      // store result of evaluation in a temporary
      // TODO: check that the expression types match
      Variable *tmp = env->newTmpVar(typeOf(thenExpr, env));
      inst.append(newVarDecl(tmp));

      // append to each sequence an assignment from the
      // computed expression to the temporary
      thenInsts->append(newAssign(newVarRef(tmp), thenExpr.xfr()));
      elseInsts->append(newAssign(newVarRef(tmp), elseExpr.xfr()));

      // finally, append an if-then-else instruction
      inst.append(newIfThenElse(
        condExpr.xfr(), thenInsts.xfr(), elseInsts.xfr()));

      // return a ref to the temporary, which can be used
      // as the value of the ?: expression
      return newVarRef(tmp);
    }

    fun getType {
      // a consistency check would be in order .. but I don't
      // have a type equality predicate yet ..
      return el.getType(env);
    }
  }

  // wtf?  gnu...
  // linux driver code has "expr ? : expr" ...
  // according to Marat, "e1 ? : e2" is the same as "e1 ? e1 : e2",
  // except that e1 is only evaluated once
  -> cond:BinaryExpression "?" ":" el:AssignmentExpression {
    fun intEval {
      // evaluate all of them first, so we get the check for the
      // expression being const regardless of which way the test goes
      // (this may in fact turn out to be wrong, but for now it's what
      // I think it should be)
      int c = cond.intEval(env);
      int t = 0;    // ?
      int e = el.intEval(env);
      return c ? t : e;
    }

    fun typeCheck {
      // ??
      delete cond.typeCheck(env, inst);
      return el.typeCheck(env, inst);
    }

    fun getType {
      // a consistency check would be in order .. but I don't
      // have a type equality predicate yet ..
      return el.getType(env);
    }
  }

}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm AssignmentExpression : ExprBase {
  formGroup {
    fun typeCheck = e.typeCheck(env, inst);
    fun getType = e.getType(env);

    -> e:ConditionalExpression   { fun intEval = e.intEval(env); }
    -> e:ThrowExpression ;
  }

  formGroup {
    fun getType {
      // .. here I should check that e2's type can be coerced to
      // e1's type, but wtf ...
      return e2.getType(env);
    }

    -> e1:BinaryExpression "=" e2:AssignmentExpression {
      fun typeCheck {
        // evaluation order?
        Owner<CilLval> lval; lval = asLval(e1.typeCheck(env, inst));
        Owner<CilExpr> expr; expr = e2.typeCheck(env, inst);

        if (!env->isTrialBalloon() &&
            e2.unparseString().equals("malloc ( )")) {
          // conditions for analysis
          if (e1.numGroundTerms() == 1) {
            ana_malloc(e1.unparseString());
          }
          else {
            cout << locString() << ": can't analyze\n";
          }
        }

        Owner<CilLval> lhs; lhs = lval->clone();
        inst.append(newAssign(lhs.xfr(), expr.xfr()));
        return lval.xfr();
      }

    }

    -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression {
      fun typeCheck {
        // evaluation order?
        Owner<CilLval> lval; lval = asLval(e1.typeCheck(env, inst));
        Owner<CilExpr> expr; expr = e2.typeCheck(env, inst);

        BinOp bop = op.getOp();
        Owner<CilLval> lhs; lhs = lval->clone();
        Owner<CilLval> rhs; rhs = lval->clone();
        inst.append(newAssign(lhs.xfr(),
                              newBinExpr(bop, rhs.xfr(), expr.xfr())));
        return lval.xfr();
      }
    }
  }
}

nonterm AssignmentOperator {
  fundecl BinOp getOp();

  -> "*="   { fun getOp = OP_TIMES; }
  -> "/="   { fun getOp = OP_DIVIDE; }
  -> "%="   { fun getOp = OP_MOD; }
  -> "+="   { fun getOp = OP_PLUS; }
  -> "-="   { fun getOp = OP_MINUS; }
  -> ">>="  { fun getOp = OP_RSHIFT; }
  -> "<<="  { fun getOp = OP_LSHIFT; }
  -> "&="   { fun getOp = OP_BITAND; }
  -> "^="   { fun getOp = OP_BITXOR; }
  -> "|="   { fun getOp = OP_BITOR; }
}


// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
// update: now that I'm doing translation too, the difference
// in the meanings is great enough that I think they should be
// separate, as they are
nonterm Expression : ExprBase {
  -> ae:AssignmentExpression {
    fun intEval = ae.intEval(env);
    fun typeCheck = ae.typeCheck(env, inst);
    fun getType = ae.getType(env);
  }

  -> e:Expression "," ae:AssignmentExpression {
    // choosing again to evaluate everything..
    fun intEval = e.intEval(env), ae.intEval(env);

    fun typeCheck {
      delete e.typeCheck(env, inst);     // throw away all but last
      return ae.typeCheck(env, inst);    // keep last value
    }

    // type of ',' is last one in sequence ..
    fun getType = ae.getType(env);
  }
}

nonterm ExpressionOpt : Checkable {
  -> empty ;
  -> e:Expression  { fun typeCheck = e.typeCheck(env, inst); }
}

// this is an expression with the additional requirement that
// it be entirely evaluable at compile time
// (which is essentially a type property)
nonterm ConstantExpression : ExprBase -> e:ConditionalExpression {
  fun intEval = e.intEval(env);
  fun typeCheck = e.typeCheck(env, inst);
}

// ------ A.5 Statements ------
nonterm HasCFG {
  // add this node to 'cfg'; 'edge' is the edge to split to insert
  // the CFG nodes; returns the edge that leaves the region
  fundecl CFGEdge *getCFG(CFG &cfg, CFGEdge *edge);
  fun getCFG = edge;
}


// labeled-statement
nonterm Statement : Checkable, HasCFG {
  literalCode "disamb" typeCheck {
    return disambiguate(passedEnv, inst, (DisambFn)&Statement_Node::unamb_typeCheck);
  }

  fun typeCheck = s.typeCheck(env, inst);
  fun getCFG = s.getCFG(cfg, edge);

  fundecl bool isWhileLoop() const;
  fun isWhileLoop = false;

  -> n:LabelName ":" s:Statement {
    fun getCFG {
      // associate the label with the edge 'edge'
      cfg.addLabel(n.getName(), edge);

      // insert statement's CFG
      return s.getCFG(cfg, edge);
    }

    fun typeCheck {
      inst.append(newLabel(n.getName()));
      return s.typeCheck(env, inst);
    }
  }

  // had to remove the statement because I found linux kernel
  // code that has "case:" immediately followed by "}"
  // TODO: revise grammar syntax so I can have both, and simply
  // prefer the one with a statement..
  -> "case" e:ConstantExpression ":" /*s:Statement*/ {
    fun typeCheck = NULL;    // TODO: typeCheck
    fun getCFG {
      // just associate the expression with the edge, and return
      cfg.addCaseLabel(&e, edge);
      return edge;
    }
  }

  -> "default" ":" s:Statement {
    // TODO: typeCheck
    fun getCFG {
      cfg.addDefaultLabel(edge);
      return s.getCFG(cfg, edge);
    }
  }

  // expression-statement
  -> s:ExpressionStatement ;

  // compound-statement
  -> s:CompoundStatement ;

  formGroup {
    fun typeCheck = e.typeCheck(env, inst);

    // selection-statement
    -> "if" "(" e:Condition ")" s:Statement {
      fun getCFG {
        // splice a conditional node into 'edge', initially
        // with both targets pointing to a null block that
        // itself points where 'edge' did
        CFGNullNode *join = cfg.makeNullNode(edge->getTarget());
        CFGIfNode *cond = cfg.makeIfNode(&e, join, join);
        edge->setTarget(cond);

        // now insert s's CFG into the "then" branch
        s.getCFG(cfg, cond->getThenEdge());

        return join->getOutgoingEdge();
      }

      fun typeCheck {
        // make a copy of the current dataflow environment
        DataflowEnv initialDenv(env->getDenv());

        // check the expression first; this sets its 'env' pointer
        Owner<CilExpr> cond; cond = e.typeCheck(env, inst);

        // apply the constraints implied by the condition to
        // the current dataflow environment
        e.ana_applyConstraint(false /*negated*/);

        // flow through 'then' branch
        Owner<CilCompound> thenInst; thenInst = newCompound();
        delete s.typeCheck(env, *thenInst);

        // grab resulting dataflow env
        DataflowEnv afterThen(env->getDenv());

        // restore original env
        env->getDenv() = initialDenv;

        // apply the negation of the condition to the
        // now-current dataflow environment
        e.ana_applyConstraint(true /*negated*/);

        // merge the branches
        env->getDenv().mergeWith(afterThen);

        // add the intermediate form of if-then-else, where
        // the else branch is empty
        inst.append(newIfThenElse(
          cond.xfr(), thenInst.xfr(), newCompound()));

        return noCilValue();      // can't treat an if-then-else as a value
      }
    }

    // if-then-else preferred over if-then when ambiguous
    // (so far unimplemented! (TODO))
    -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement {
      fun typeCheck {
        // make a copy of the current dataflow environment
        DataflowEnv initialDenv(env->getDenv());

        // check the expression first; this sets its 'env' pointer
        Owner<CilExpr> cond; cond = e.typeCheck(env, inst);

        // apply the constraints implied by the condition to
        // the current dataflow environment
        e.ana_applyConstraint(false /*negated*/);

        // flow through 'then' branch
        Owner<CilCompound> thenInst; thenInst = newCompound();
        delete s1.typeCheck(env, *thenInst);

        // grab resulting dataflow env
        DataflowEnv afterThen(env->getDenv());

        // restore original env
        env->getDenv() = initialDenv;

        // apply the negation of the condition to the
        // now-current dataflow environment
        e.ana_applyConstraint(true /*negated*/);

        // flow through 'else' branch
        Owner<CilCompound> elseInst; elseInst = newCompound();
        delete s2.typeCheck(env, *elseInst);

        // merge the branches
        env->getDenv().mergeWith(afterThen);

        // append if-then-else
        inst.append(newIfThenElse(
          cond.xfr(), thenInst.xfr(), elseInst.xfr()));

        return noCilValue();      // no value
      }

      fun getCFG {
        // make the conditional structure
        CFGNullNode *join = cfg.makeNullNode(edge->getTarget());
        CFGIfNode *cond = cfg.makeIfNode(&e, join, join);
        edge->setTarget(cond);

        // insert then and else branches
        s1.getCFG(cfg, cond->getThenEdge());
        s2.getCFG(cfg, cond->getElseEdge());

        return join->getOutgoingEdge();
      }
    }

    -> "switch" "(" e:Condition ")" s:Statement {
      // TODO: typeCheck

      fun getCFG {
        // make a switch node where a 'break' statement will go to a
        // null node, which itself points to edge's target, and splice
        // that in
        CFGNullNode *join = cfg.makeNullNode(edge->getTarget());
        CFGSwitchNode *sw = cfg.makeSwitchNode(&e, join);
        edge->setTarget(sw);

        // indicate that this is the current switch node
        cfg.pushSwitch(sw);

        // let the statement, which has the "case:" labels,
        // add their own stuff
        s.getCFG(cfg, NULL /*?*/);

        // restore old switch context, if any
        cfg.popSwitch();

        return join->getOutgoingEdge();
      }
    }

    // iteration-statement
    formGroup {
      fun getCFG {
        // build an empty looping structure, essentially:
        //   cond:        if (e) {
        //   bodyStart:     /* empty */
        //                  /* insert body here */
        //   bodyEnd:       goto cond;     /* target of 'continue' */
        //                }
        //   loopExit:    /* target of 'break' */
        CFGNullNode *loopExit = cfg.makeNullNode(edge->getTarget());
        CFGNullNode *bodyEnd = cfg.makeNullNode(NULL);
        CFGNullNode *bodyStart = cfg.makeNullNode(bodyEnd);
        CFGIfNode *cond = cfg.makeIfNode(&e, bodyStart, loopExit);
        bodyEnd->setTarget(cond);

        // difference between while and do-while
        if (isWhileLoop()) {
          edge->setTarget(cond);
        }
        else {    // do-while
          edge->setTarget(bodyStart);
        }

        // mark the exit targets
        cfg.pushContinue(bodyEnd);
        cfg.pushBreak(loopExit);

        // build loop body
        s.getCFG(cfg, bodyStart->getOutgoingEdge());

        // restore loop context
        cfg.popContinue();
        cfg.popBreak();

        return loopExit->getOutgoingEdge();
      }

      -> "while" "(" e:Condition ")" s:Statement {
        fun isWhileLoop = true;
        
        fun typeCheck {
          // get condition's imperative and non-imperative elements
          Owner<CilCompound> condInst; condInst = newCompound();
          Owner<CilExpr> cond; cond = e.typeCheck(env, *condInst);

          // get statement's imperatives
          Owner<CilCompound> body; body = newCompound();
          delete s.typeCheck(env, *body);

          // TODO: break and continue

          // append the condition's imperative to the body
          body->append(condInst->clone());

          // also put condition's imperative just before loop ...
          inst.append(condInst.xfr());

          // then the loop body itself
          inst.append(newWhileLoop(cond.xfr(), body.xfr()));

          // no value
          return noCilValue();
        }
      }

      -> "do" s:Statement "while" "(" e:Expression ")" ";" {
        fun isWhileLoop = false;

        fun typeCheck {
          // make the body, and start with a label so we can jump
          // past the initial test on the first iteration
          Owner<CilCompound> body; body = newCompound();
          LabelName topOfBody = newTmpLabel();
          body->append(newLabel(topOfBody));

          // get statement's imperatives
          delete s.typeCheck(env, *body);

          // get condition, putting its imperative at the end
          // of the body
          Owner<CilExpr> cond; cond = e.typeCheck(env, *body);

          // TODO: break and continue

          // just before loop we jump into it, past test
          inst.append(newGoto(topOfBody));

          // then the loop body itself
          inst.append(newWhileLoop(cond.xfr(), body.xfr()));

          // no value
          return noCilValue();
        }
      }
    }

    // this is a special-purpose rule intended for use with (unexpanded)
    // macros that, internally, contain a for loop; it is *not* part of
    // the C or C++ languages!
    -> L2_NAME "(" e:ExpressionList ")" s:CompoundStatement {
      fun typeCheck = NULL;       // TODO: implement?  eliminate?
    }
  }

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ExpressionOpt ")" s2:Statement {
    fun typeCheck {
      // initializer is just as if it were before the loop (except
      // declared variables are supposed to have loop scope .. TODO)
      delete s1.typeCheck(env, inst);

      // grab condition and its imperative elements
      Owner<CilCompound> condInst; condInst = newCompound();
      Owner<CilExpr> cond; cond = c.typeCheck(env, *condInst);

      // TODO: break and continue

      // loop body
      Owner<CilCompound> body; body = newCompound();
      delete s2.typeCheck(env, *body);

      // increment expression; as if at end of body (except
      // for "continue" ..)
      delete e.typeCheck(env, *body);

      // stick test at end of body too
      body->append(condInst->clone());

      // test imperative goes before loop body
      inst.append(condInst.xfr());

      // then the loop body
      inst.append(newWhileLoop(cond.xfr(), body.xfr()));

      return noCilValue();
    }

    fun getCFG {
      // stick in the init code
      edge = s1.getCFG(cfg, edge);

      // build an empty looping structure, essentially:
      //   cond:        if (e) {
      //   bodyStart:     /* empty */
      //                  /* insert body here */
      //   bodyEnd:       goto cond;     /* target of 'continue' */
      //                }
      //   loopExit:    /* target of 'break' */
      CFGNullNode *loopExit = cfg.makeNullNode(edge->getTarget());
      CFGNullNode *bodyEnd = cfg.makeNullNode(NULL);
      CFGNullNode *bodyStart = cfg.makeNullNode(bodyEnd);
      CFGIfNode *cond = cfg.makeIfNode(c.getGuardExpr(), bodyStart, loopExit);
      bodyEnd->setTarget(cond);
      edge->setTarget(cond);

      // mark the exit targets
      cfg.pushContinue(bodyEnd);
      cfg.pushBreak(loopExit);

      // build loop body
      s2.getCFG(cfg, bodyStart->getOutgoingEdge());

      // stick in the increment code
      // TODO
      //e2.getCFG(cfg, bodyEnd->getOutgoingEdge());

      // restore loop context
      cfg.popContinue();
      cfg.popBreak();

      return loopExit->getOutgoingEdge();
    }
  }

  // jump-statement
  formGroup {
    fun typeCheck = NULL;

    -> "break" ";" {
      // TODO2: typeCheck
      fun getCFG {
        edge->setTarget(cfg.getBreakTarget());
        return edge;
      }
    }

    -> "continue" ";" {
      // TODO2: typeCheck
      fun getCFG {
        edge->setTarget(cfg.getContinueTarget());
        return edge;
      }
    }

    -> "return" e:Expression ";" {
      fun typeCheck {
        Owner<CilExpr> expr; expr = e.typeCheck(env, inst);
        inst.append(newReturn(expr.xfr()));
        return noCilValue();
      }

      fun getCFG {
        CFGReturnNode *node = cfg.makeReturnNode(&e,
          cfg.getReturnTarget());
        edge->setTarget(node);
        return edge;
      }
    }

    -> "return" ";" {
      fun typeCheck {
        inst.append(newReturn(NULL));
        return noCilValue();
      }

      fun getCFG {
        CFGReturnNode *node = cfg.makeReturnNode(NULL,
          cfg.getReturnTarget());
        edge->setTarget(node);
        return edge;
      }
    }

    -> "goto" n:LabelName ";" {
      fun typeCheck {
        inst.append(newGoto(n.getName()));
        return noCilValue();
      }

      fun getCFG {
        edge->setTarget(cfg.getLabelTarget(n.getName()));
        return edge;
      }
    }
  }

  // declaration-statement
  -> s:BlockDeclaration ;

  // try-block
  -> s:TryBlock ;

  // GNU extensions
  -> GNUAsmStatement {
    fun typeCheck = NULL;
    fun getCFG = edge;
  }
}

nonterm ExpressionStatement : Checkable, HasCFG {
  -> ";" ;
  -> e:Expression ";" {
    fun typeCheck = e.typeCheck(env, inst);

    fun getCFG {
      CFGExprNode *node = cfg.makeExprNode(&e);
      return cfg.insertNode(node, edge);
    }
  }
}

// base class for nodes that establish a new scope
nonterm ScopeNode {
  datadecl Owner<Env> localEnv;

  // this overrides a virtual method in CCTreeNode
  fundecl void killParentLink();
  fun killParentLink {
    if (localEnv) {
      localEnv->killParentLink();
    }
  }
}

nonterm CompoundStatement : Checkable, HasCFG, ScopeNode {
  -> "{" seq:StatementSeqOpt "}" {
    fun typeCheck {
      xassert(!localEnv);
      localEnv = new Env(env);    // scope

      try {
        Owner<CilExpr> ret; ret = seq.typeCheck(localEnv, inst);

        ana_endScope(localEnv);

        return ret.xfr();
      }
      catch (...) {
        // kill the localEnv so it doesn't continue to
        // point to 'env', which may well be destroyed during
        // the unwind process before 'localEnv' is
        //localEnv.del();
        
        // different strategy: the problem with deleting localEnv
        // is we could have pointers from below pointing at us;
        // this happens if e.g. we have two children, and the
        // left child typeChecks *and* has its own scope; then
        // that scope will point at us; if the right child then
        // fails to segfault, we execute this code; so now my
        // strategy is to simply break the parent link; I still
        // need to rethink my whole approach to environments ...
        localEnv->killParentLink();

        throw;
      }
    }

    fun getCFG = seq.getCFG(cfg, edge);
  }
}

nonterm StatementSeqOpt : Checkable, HasCFG {
  -> empty ;
  -> seq:StatementSeqOpt s:Statement {
    fun typeCheck {
      try {
        delete seq.typeCheck(env, inst);
      }
      catch (XSemanticError &x) {
        // error recovery; report and proceed
        env->report(x.err);
      }
      env->flushLocalErrors(cout);

      try {
        return s.typeCheck(env, inst);
      }
      catch (XSemanticError &x) {
        env->report(x.err);
        env->flushLocalErrors(cout);
        return noCilValue();
      }
    }

    fun getCFG {
      return s.getCFG(cfg, seq.getCFG(cfg, edge));
    }
  }
}

nonterm Condition : Checkable {
  fun typeCheck = e.typeCheck(env, inst);

  -> e:Expression ;
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression {
    fun typeCheck {
      // basic declaration handling
      Type const *declType = decl.getDeclType(env, spec.getType(env));
      VarName name = decl.getDeclName();
      declareVariable(env, name, DF_NONE, declType);

      // declare a new intermediate variable
      Variable *var = env->getVariable(name);
      inst.append(newVarDecl(var));

      // initialize it
      Owner<CilExpr> initVal; initVal = e.typeCheck(env, inst);
      inst.append(newAssign(newVarRef(var), initVal.xfr()));

      return noCilValue();
    }
  }
}

nonterm ConditionOpt : Checkable {
  fundecl CCTreeNode *getGuardExpr();
  fun getGuardExpr = NULL;

  -> empty ;
  -> c:Condition {
    fun typeCheck = c.typeCheck(env, inst);
  }
}

nonterm ForInitStatement : Checkable, HasCFG {
  -> s:ExpressionStatement | s:SimpleDeclaration {
    fun typeCheck = s.typeCheck(env, inst);
  }
}




// ----- A.6 Declarations ------
nonterm DeclarationSeqOpt : Checkable {
  -> empty {
    fun typeCheck = NULL;
  }
  -> seq:DeclarationSeqOpt d:Declaration {
    fun typeCheck {
      delete seq.typeCheck(env, inst);
      return d.typeCheck(env, inst);
    }
  }
}

nonterm Declaration : Checkable {
  fun typeCheck = d.typeCheck(env, inst);

  -> GNUAttribute d:Declaration ;    // yet more

  -> d:BlockDeclaration ;
  -> d:FunctionDefinition ;
  //-> TemplateDeclaration ;
  -> d:LinkageSpecification ;
}

// C++ has other alternatives..
nonterm BlockDeclaration : Checkable, HasCFG {
  -> d:SimpleDeclaration {
    fun typeCheck = d.typeCheck(env, inst);
  }
}

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm SimpleDeclaration : Checkable {
  //e.g.: int                x                     ;
  -> spec:DeclSpecifier list:InitDeclaratorListOpt ";" {
    fun typeCheck {
      Type const *type = spec.getType(env);    // a complete type
      DeclFlags flags = spec.getDeclFlags();   // inline, virtual, etc.
      list.declare(env, inst, flags, type);
      return noCilValue();
    }
  }
}


// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

nonterm HasDeclFlags {
  // return the set of declaration flags present here
  fundecl DeclFlags getDeclFlags();
}

nonterm DeclSpecifier : HasTypeName, HasType, HasDeclFlags {
  fun typeName = s.typeName();
  fun getType = s.getType(env);

  -> "inline" m:DeclModifier s:TypeSpecifier
   | m:DeclModifier "inline" s:TypeSpecifier {
    fun getDeclFlags = (DeclFlags)(DF_INLINE | m.getDeclFlags());
  }

  -> m:DeclModifier s:TypeSpecifier {
    fun getDeclFlags = m.getDeclFlags();
  }
  
  -> "inline" s:TypeSpecifier
   | s:TypeSpecifier {
    fun getDeclFlags = DF_NONE;
  }
}

// my analysis (informal and ad-hoc) indicates that none of these can
// be used together; "inline" is pulled out because it can be used
// with "virtual", "static", "friend", and possibly "extern"; I
// consider all this preferable to just allowing a "word soup"
nonterm DeclModifier : HasDeclFlags {
  -> "virtual"     { fun getDeclFlags = DF_VIRTUAL; }
  -> "friend"      { fun getDeclFlags = DF_FRIEND; }
  -> "mutable"     { fun getDeclFlags = DF_MUTABLE; }
  -> "typedef"     { fun getDeclFlags = DF_TYPEDEF; }
  -> "auto"        { fun getDeclFlags = DF_AUTO; }
  -> "register"    { fun getDeclFlags = DF_REGISTER; }
  -> "static"      { fun getDeclFlags = DF_STATIC; }
  -> "extern"      { fun getDeclFlags = DF_EXTERN; }
}


nonterm HasCVFlags {
  // return all const/volatile at this level
  fundecl CVFlags getCVFlags();
}

nonterm TypeSpecifier : HasTypeName, HasType, HasCVFlags {
  // generic implementation
  fun getType {
    Type const *baseType = s.getType(env);
    CVFlags cv = getCVFlags();

    // apply the cv flags to what we have
    Type const *ret = env->applyCVToType(cv, baseType);
    if (!ret) {
      // e.g.:
      //   typedef int (*Foo)();
      //   Foo const f;
      reportError(env, "cannot apply const/volatile to this type");
      return baseType;    // error recovery
    }
    return ret;
  }

  // default impls
  fun typeName = s.typeName();
  fun getCVFlags = CV_NONE;

  // these are the atomic types (see types.txt)
  formGroup {
    -> s:SimpleTypeSpecifier ;          // int

    -> s:SimpleCVTypeSpecifier          // unsigned const char  (not good style, IMO)
         { fun getCVFlags = s.getCVFlags(); }

    -> s:ElaboratedTypeSpecifier ;      // class foo  or  enum bar

    -> s:ClassSpecifier                 // class { ... }
         { fun typeName = "class { ... }"; }
    -> s:EnumSpecifier                  // enum { ... }
         { fun typeName = "enum { ... }"; }
  }

  // these are: "CV* atomic-type" or "atomic-type CV*"
  formGroup {
    fun typeName = stringc << s.typeName() << " " << q.typeName();

    fun getCVFlags {
      // get flags from underlying specifier
      CVFlags flags = s.getCVFlags();

      // add the flag at this level
      return (CVFlags)(flags | q.getCVFlags());
    }

    -> q:CVQualifier s:TypeSpecifier ;  // const int
    -> s:TypeSpecifier q:CVQualifier ;  // int const
  }
}


nonterm ElaboratedTypeSpecifier : HasTypeName, HasType {
  -> k:ClassKeyword n:L2_NAME {
    fun getType {
      CompoundType::Keyword keyword = k.getKeyword();
      CompoundType const *type = env->lookupOrMakeCompound(n.nameValue, keyword);
      if (!type) {
        // e.g.:
        //   class Foo;
        //   struct Foo *f;
        throwError("compound kind mismatch");
      }

      return env->makeType(type);
    }
  }

  -> "enum" n:L2_NAME {
    fun getType {
      EnumType const *type = env->lookupEnum(n.nameValue);
      if (!type) {
        throwError("undeclared enum");
      }
      return env->makeType(type);
    }
  }
}


nonterm SimpleTypeBase : HasType {
  // helper to get the simple type spec, to cut down on
  // syntactic verbiage
  fundecl SimpleTypeId getst();
  fun getst { internalError("can't call me"); }

  fun getType {
    return env->getSimpleType(getst());
  }
}


// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here; I do not
nonterm SimpleTypeSpecifier : SimpleTypeBase, HasTypeName {
  fun typeName {
    return simpleTypeName(getst());
  }

  // the existence of this production is part of why parsing C is hard
  -> n:PQTypeName {
    fun getType {
      Type const *ret = env->lookupType(n.typeName());
      if (!ret) {
        throwError(stringc << "undefined type: " << n.typeName());
      }
      return ret;
    }
    fun typeName = n.typeName();
  }

  -> "char"                     { fun getst = ST_CHAR; }
  -> "unsigned" "char"          { fun getst = ST_UNSIGNED_CHAR; }
  -> "signed" "char"            { fun getst = ST_SIGNED_CHAR; }
  -> "bool"                     { fun getst = ST_BOOL; }
  -> "unsigned"                 { fun getst = ST_UNSIGNED_INT; }
  -> "unsigned" "int"           { fun getst = ST_UNSIGNED_INT; }
  -> "signed"                   { fun getst = ST_INT; }
  -> "signed" "int"             { fun getst = ST_INT; }
  -> "int"                      { fun getst = ST_INT; }
  -> "unsigned" "short" "int"   { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "short"         { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "long" "int"    { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" "long"          { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "signed" "long" "int"      { fun getst = ST_LONG_INT; }
  -> "signed" "long"            { fun getst = ST_LONG_INT; }
  -> "long" "int"               { fun getst = ST_LONG_INT; }
  -> "long"                     { fun getst = ST_LONG_INT; }
  -> "signed" "long" "long"     { fun getst = ST_LONG_LONG; }
  -> "long" "long"              { fun getst = ST_LONG_LONG; }
  -> "unsigned" "long" "long"   { fun getst = ST_UNSIGNED_LONG_LONG; }
  -> "signed" "short" "int"     { fun getst = ST_SHORT_INT; }
  -> "signed" "short"           { fun getst = ST_SHORT_INT; }
  -> "short" "int"              { fun getst = ST_SHORT_INT; }
  -> "short"                    { fun getst = ST_SHORT_INT; }
  -> "wchar_t"                  { fun getst = ST_WCHAR_T; }
  -> "float"                    { fun getst = ST_FLOAT; }
  -> "double"                   { fun getst = ST_DOUBLE; }
  -> "long" "double"            { fun getst = ST_LONG_DOUBLE; }
  -> "void"                     { fun getst = ST_VOID; }
}


// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm PQTypeName : HasTypeName {
  -> n:L2_NAME                 { fun typeName = n.nameValue; }
  -> TemplateId                { fun typeName = "(template-id)"; }
  -> Qualifier n:PQTypeName    { fun typeName = stringc << "(qualifier)" << n.typeName(); }
}

// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll probably merge them at some point
nonterm SimpleCVTypeSpecifier : SimpleTypeBase, HasTypeName, HasCVFlags {
  fun typeName {
    return stringc << simpleTypeName(getst()) << " " << q.typeName();
  }

  fun getCVFlags = q.getCVFlags();

  -> "unsigned" q:CVQualifierSeq "char"         { fun getst = ST_UNSIGNED_CHAR; }
  -> "signed" q:CVQualifierSeq "char"           { fun getst = ST_SIGNED_CHAR; }
  -> "unsigned" q:CVQualifierSeq "int"          { fun getst = ST_UNSIGNED_INT; }
  -> "signed" q:CVQualifierSeq "int"            { fun getst = ST_INT; }
  -> "unsigned" q:CVQualifierSeq "short" "int"  { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "short" q:CVQualifierSeq "int"  { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" q:CVQualifierSeq "short"        { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" q:CVQualifierSeq "long" "int"   { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" "long" q:CVQualifierSeq "int"   { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" q:CVQualifierSeq "long"         { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "signed" q:CVQualifierSeq "long" "int"     { fun getst = ST_LONG_INT; }
  -> "signed" "long" q:CVQualifierSeq "int"     { fun getst = ST_LONG_INT; }
  -> "signed" q:CVQualifierSeq "long"           { fun getst = ST_LONG_INT; }
  -> "long" q:CVQualifierSeq "int"              { fun getst = ST_LONG_INT; }
  -> "signed" q:CVQualifierSeq "long" "long"    { fun getst = ST_LONG_LONG; }
  -> "unsigned" q:CVQualifierSeq "long" "long"  { fun getst = ST_UNSIGNED_LONG_LONG; }
  -> "signed" q:CVQualifierSeq "short" "int"    { fun getst = ST_SHORT_INT; }
  -> "signed" "short" q:CVQualifierSeq "int"    { fun getst = ST_SHORT_INT; }
  -> "signed" q:CVQualifierSeq "short"          { fun getst = ST_SHORT_INT; }
  -> "short" q:CVQualifierSeq "int"             { fun getst = ST_SHORT_INT; }
  -> "long" q:CVQualifierSeq "double"           { fun getst = ST_LONG_DOUBLE; }
}


nonterm EnumSpecifier : HasType {
  fundecl string getEnumName();

  fun getType {
    // get preliminary info
    string name = getEnumName();    // could be ""

    // construct the vessel to carry additional stuff
    EnumType *type = env->lookupEnum(name);
    if (type) {
      // TODO: wrong because this prevents local redeclaration
      throwError(stringc << "enum already declared: " << name);
    }
    if (!type) {
      type = env->makeEnumType(name);
      xassert(type);
    }

    // TODO: add the enum's elements to its definition

    return env->makeType(type);
  }

  -> "enum" "{" list:EnumeratorListOpt "}"
    { fun getEnumName = ""; }
  -> "enum" n:EnumName "{" list:EnumeratorListOpt "}"
    { fun getEnumName = n.getName(); }
}
                         

nonterm EnumeratorList -> EnumeratorDefinition |
                          EnumeratorList "," EnumeratorDefinition ;
nonterm EnumeratorListOpt -> empty | EnumeratorList |
                             EnumeratorList "," ;     // GNU extension (??)

nonterm EnumeratorDefinition -> EnumValueName |
                                EnumValueName "=" ConstantExpression ;

nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

nonterm LinkageSpecification : Checkable {
  // todo: actually record the linkage spec
  -> "extern" L2_STRING_LITERAL "{" d:DeclarationSeqOpt "}" |
     "extern" L2_STRING_LITERAL d:Declaration {
    fun typeCheck = d.typeCheck(env, inst);
  }
}

// ------ A.7 Declarators ------
// -- declarator --
// declarator: the "x" in a declaration like "int x"

nonterm HasDeclare {
  // this function is defined for declarators, etc.; for each declarator
  // in the subtree, combine 'type' with the additional type modifiers
  // associated with the declarator (if any), and add the completed
  // declaration, with 'flags', to 'env'
  fundecl void declare(Env *passedEnv, CilInstructions &inst, 
                       DeclFlags flags, Type const *type);
  literalCode "prefix" declare {
    env = passedEnv;
  }
}

nonterm InitDeclaratorList : HasDeclare {
  -> d:InitDeclarator {
    fun declare { d.declare(env, inst, flags, type); }
  }

  -> list:InitDeclaratorList "," d:InitDeclarator {
    fun declare {
      list.declare(env, inst, flags, type);
      d.declare(env, inst, flags, type);
    }
  }
}

nonterm InitDeclaratorListOpt : HasDeclare {
  -> empty                      { fun declare {} }
  -> list:InitDeclaratorList    { fun declare { list.declare(env, inst, flags, type); } }
}

nonterm InitDeclarator : HasDeclare {
  fun declare {
    // get the full type from the declarator
    Type const *fullType = d.getDeclType(env, type);

    // get the declared name
    string name = d.getDeclName();

    // put that pair into the environment
    declareVariable(env, name, flags, fullType);

    // and add an intermediate form declaration too (but
    // we don't have typedefs in Cil, so pass over them)
    // TODO2: are other DeclFlags relevant?  e.g. static??
    if (!( flags & DF_TYPEDEF )) {
      inst.append(newVarDecl(env->getVariable(name)));
    }
  }

  // don't know what to do with the initializer at this point.. (TODO)
  -> d:Declarator |                   // (int)  x
     d:Declarator Initializer ;       // (int)  x = 5
}

nonterm Initializer {
  -> "=" InitializerClause ;

  // this causes an ambiguity with
  //   int fileno(FILE *f);
  // because it could be multiplication.. handling it isn't that
  // hard, but for now let's just take out this rule
  //-> "(" ExpressionList ")" ;          // ctor args
}

nonterm InitializerClause {
  -> AssignmentExpression        ;   // scalar
  -> "{" InitializerList "}"     ;   // array initializer
  -> "{" InitializerList "," "}" ;   // useful syntactic quirk
  -> "{" "}"                     ;   // ?  does this mean the array is zeroed?
}

nonterm InitializerList -> InitializerClause |
                           InitializerList "," InitializerClause ;


nonterm HasDeclType {
  // retrieve the type associated with this declaration, where
  // 'type' is the type as built so far (inherited from the
  // specifier, or constructed by parsing type constructors)
  fundecl Type const *getDeclType(Env *passedEnv, Type const *type);
  literalCode "prefix" getDeclType {
    env = passedEnv;
  }
}

nonterm DeclaratorBase : HasTypeName, HasDeclType, HasDeclName {
  // get the node that has the function parameters, or NULL if this
  // isn't a function declaration
  fundecl ParameterDeclarationClause_Node *getFnParams();
  fun getFnParams = NULL;

  // return the type name string for the return type, if this is
  // a function declaration
  fundecl string retTypeName();
  fun retTypeName { internalError("not a function type"); }

  // name of variable or function being declared
  fun getDeclName = d.getDeclName();

  // attribute 'isFunction' of Declarator and DirectDeclarator: if the
  // type of the thing declared is a function (not a ptr to a
  // function, or an array of fns...), this is 1, otherwise 0; it is
  // used to do some disambiguation later on, where functions are
  // allowed to not have return types (DeclSpecifiers) to allow for
  // ctors and dtors, but other declarations must have types
  attr isFunction;
  
  // this attribute is needed to compute isFunction; it is 1 if the
  // declarator is simply a PQName, and 0 otherwise
  attr isName;
}

nonterm Declarator : DeclaratorBase {
  // (PtrOperator)* DirectDeclarator
  -> p:PtrOperator d:Declarator {
  
    // if d is a function, then this declares a function that
    // returns a pointer
    action isFunction := d.isFunction;
    action isName := 0;

    fun typeName = stringc << "*" << d.typeName();
    fun retTypeName = stringc << "*" << d.retTypeName();

    fun getFnParams {
      return d.getFnParams();
    }

    fun getDeclType {
      // grab info about the syntax
      CVFlags cv = p.getCVFlags();
      PtrOper op = p.getPtrOper();

      // make a new type that is, e.g., a pointer to the type
      // we were already given
      Type *newType = env->makePtrOperType(op, cv, type);

      // and declare the variable with that new, constructed type
      return d.getDeclType(env, newType);
    }
  }

  // I'm still looking for the right place to put GNUAttribute ...
  -> d:DirectDeclarator GNUAttribute |       // GNU extension
     d:DirectDeclarator {
    action isFunction := d.isFunction;
    action isName := d.isName;

    fun getFnParams = d.getFnParams();
    fun typeName = d.typeName();
    fun retTypeName = d.retTypeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}

nonterm DirectDeclarator : DeclaratorBase {
  // for arrays
  fundecl bool hasSize();             // true if a size is specified
  fun hasSize = false;
  fundecl int getSize(Env *env);      // get declared size
  fun getSize { internalError("can't call getSize"); }

  -> n:PQVarName {
    action isFunction := 0;
    action isName := 1;

    // declarator names can't be qualified with "::" (this resolves an
    // ambiguity with constructs like "Foo::Foo() {}")
    condition n.colonColon == 0;

    fun typeName = "";

    fun getDeclName = n.getDeclName();
    fun getDeclType {
      // having carried the type info along, we finally reach the
      // name of interest; return the final, collected type
      return type;
    }
  }

  // function type declarator; the return type comes from the type
  // specifier that preceeds this
  -> d:DirectDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt  {
  // ^^^ name of fn ^^^     ^^^^^^^^^^ arguments ^^^^^^^^^^     ^^^^^ const? ^^^^^^
    action isFunction := d.isName? 1 : d.isFunction;
    action isName := 0;

    fun getFnParams = &args;
    fun typeName = "(function)";
    fun retTypeName = d.typeName();

    fun getDeclType {
      // build a container for the function type
      FunctionType *fnType =
        env->makeFunctionType(type /*return type*/, q.getCVFlags());

      // fill in the details about arguments
      args.getArgTypes(env, fnType);

      // continue on down
      return d.getDeclType(env, fnType);
    }
  }

  // arrays
  formGroup {
    // Q: is there such a thing as returning an array, and could
    // this syntax declare one?  looks like yes...
    action isFunction := 0;
    action isName := 0;

    fun getDeclType {
      Type *arrType;
      if (hasSize()) {
        arrType = env->makeArrayType(type, getSize(env));    // known size
      }
      else {
        arrType = env->makeArrayType(type);                  // unknown size
      }

      return d.getDeclType(env, arrType);
    }

    // array of specified size
    -> d:DirectDeclarator "[" sz:ConstantExpression "]" {
      fun hasSize = true;
      fun getSize = sz.intEval(env);
      fun typeName = stringc << d.typeName() << "[" << sz.unparseString() << "]";
    }

    // array of unspecified size
    -> d:DirectDeclarator "[" "]" {
      fun typeName = stringc << d.typeName() << "[]";
    }
  }

  // precedence grouping
  -> "(" d:Declarator ")"  {
    action isFunction := d.isFunction;
    action isName := d.isName;

    fun getFnParams = d.getFnParams();
    fun typeName = d.typeName();
    fun retTypeName = d.retTypeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}


nonterm PtrOperator : HasCVFlags {
  // return which of the two "pointer" operators this is
  fundecl PtrOper getPtrOper();

  // c++ std mentions something with "::" as well, I don't know what that means
  -> "*" q:CVQualifierSeqOpt {
    fun getCVFlags = q.getCVFlags();
    fun getPtrOper = PO_POINTER;
  }

  -> "&" {
    fun getCVFlags = CV_NONE;
    fun getPtrOper = PO_REFERENCE;
  }
}


nonterm CVQualifierSeqOpt : HasCVFlags {
  -> empty              { fun getCVFlags = CV_NONE; }
  -> s:CVQualifierSeq   { fun getCVFlags = s.getCVFlags(); }
}

nonterm CVQualifierSeq : HasTypeName, HasCVFlags {
  -> q:CVQualifier                    { fun getCVFlags = q.getCVFlags(); }
  -> q:CVQualifier s:CVQualifierSeq   { fun getCVFlags = (CVFlags)(q.getCVFlags() | s.getCVFlags()); }
}

nonterm CVQualifier : HasTypeName, HasCVFlags {
  -> "const"            { fun getCVFlags = CV_CONST; }
  -> "volatile"         { fun getCVFlags = CV_VOLATILE; }
  -> "owner"            { fun getCVFlags = CV_OWNER; }
}


// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
nonterm TypeId : HasType {
  -> spec:TypeSpecifier decl:AbstractDeclarator {
    fun getType {
      Type const *specType = spec.getType(env);
      return decl.getDeclType(env, specType);
    }
  }
     
  // gnu extension
  -> "__typeof__" "(" e:Expression ")" {
    fun getType {
      return e.getType(env);
    }
  }
}

// note: the semantic functions in AbstractDeclarator are
// essentially duplicated code from Declarator ...
nonterm AbstractDeclarator : HasTypeName, HasDeclType {
  -> p:PtrOperator d:AbstractDeclarator {
    fun typeName = stringc << "*" << d.typeName();
    
    fun getDeclType =
      d.getDeclType(env, env->makePtrOperType(
        p.getPtrOper(), p.getCVFlags(), type));
  }

  -> d:DirectAbstractDeclarator {
    fun typeName = d.typeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}

nonterm DirectAbstractDeclarator : HasTypeName, HasDeclType {
  fun typeName = d.typeName();

  // this is where abstract declarators differ from regular declarators;
  // for a declarator, this rule is "-> PQVarName"
  -> empty {
    fun typeName = "";
    fun getDeclType = type;
  }

  // function
  -> d:DirectAbstractDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt {
    fun getDeclType {
      FunctionType *fnType = 
        env->makeFunctionType(type /*return type*/, q.getCVFlags());
      args.getArgTypes(env, fnType);
      return d.getDeclType(env, fnType);
    }
  }

  -> d:DirectAbstractDeclarator "[" sz:ConstantExpression "]" {     // array of specified size
    fun getDeclType =
      d.getDeclType(env, env->makeArrayType(type, sz.intEval(env)));
  }

  -> d:DirectAbstractDeclarator "[" "]" {                        // array of unspecified size
    fun getDeclType =
      d.getDeclType(env, env->makeArrayType(type));
  }

  -> "(" d:AbstractDeclarator ")" {                              // precedence grouping
    fun getDeclType = d.getDeclType(env, type);
  }
}


nonterm HasPrintSig {
  // print to cout some part of the function signature
  fundecl void printSig();
}


// -- parameters in declarations --
nonterm HasArgTypes {
  // accumulate the types of the arguments and store them in 'fnType'
  fundecl void getArgTypes(Env *passedEnv, FunctionType *fnType);
  literalCode "prefix" getArgTypes {
    env = passedEnv;
  }
}

nonterm ParameterDeclarationClause : HasPrintSig, HasArgTypes {
  -> p:ParameterDeclarationList {            // some args
    fun printSig { p.printSig(); }
    fun getArgTypes { p.getArgTypes(env, fnType); }
  }
  -> empty {                                 // no args
    fun printSig {}
    fun getArgTypes {}
  }
  -> "..." {                                 // all args are optional
    fun printSig { cout << "..."; }
    fun getArgTypes { fnType->acceptsVarargs = true; }
  }

  formGroup {
    fun printSig { p.printSig(); cout << ", ..."; }
    fun getArgTypes {
      p.getArgTypes(env, fnType);
      fnType->acceptsVarargs = true;
    }

    -> p:ParameterDeclarationList "..." ;      // args plus optionally more
    -> p:ParameterDeclarationList "," "..." ;  // same; alternative syntax
  }
}

nonterm ParameterDeclarationList : HasPrintSig, HasArgTypes {
  -> d:ParameterDeclaration {
    fun printSig { cout << d.typeName(); }
    fun getArgTypes { d.getArgTypes(env, fnType); }
  }

  -> list:ParameterDeclarationList "," d:ParameterDeclaration {
    fun printSig {
      list.printSig();
      cout << ", " << d.typeName();
    }
    fun getArgTypes {
      list.getArgTypes(env, fnType);
      d.getArgTypes(env, fnType);
    }
  }
}

nonterm ParameterDeclaration : HasTypeName, HasArgTypes {
  fundecl bool hasName();
  fundecl string getDeclName();

  fun typeName = stringc << s.typeName() << d.typeName();

  fun getArgTypes {
    // type
    Type const *specType = s.getType(env);
    Type const *fullType = d.getDeclType(env, specType);

    // check that there are no modifiers.. this could also be
    // done with attributes, and it's a toss-up in my mind now
    // which is the superior approach
    DeclFlags flags = s.getDeclFlags();
    if (flags != DF_NONE) {
      reportError(env, "modifiers not allowed in parameter declarations");
    }

    Parameter *param = new Parameter(fullType);
    if (hasName()) {
      param->name = getDeclName();
    }
    //if (hasDefaultArg()) {
    //  // these are nontrivial to handle, so for now I do nothing
    //}

    fnType->addParam(param);
  }

  formGroup {
    fun hasName = true;
    fun getDeclName = d.getDeclName();

    -> s:DeclSpecifier d:Declarator ;
    -> s:DeclSpecifier d:Declarator "=" AssignmentExpression ;
  }

  formGroup {
    fun hasName = false;
    fun getDeclName { internalError("can't call me"); }

    -> s:DeclSpecifier d:AbstractDeclarator ;
    -> s:DeclSpecifier d:AbstractDeclarator "=" AssignmentExpression ;
  }
}

// -- function definition --
nonterm FunctionDefinition : Checkable, HasPrintSig, ScopeNode {
  // I am wary of letting the declspecifier be optional, because it seems
  // to me that may introduce more ambiguities.. but it truly is missing
  // in ctors and dtors; so my idea now is to only permit it when the
  // declarator declares a function type (can't be more specific since there
  // aren't good syntactic clues for ctors)

  // all declarators must be of function type
  condition d.isFunction == 1;

  // this works for all the productions

  // return type      name/params   body
  -> r:DeclSpecifier  d:Declarator  b:FunctionBody
   | r:DeclSpecifier  GNUAttribute d:Declarator  b:FunctionBody {    // arg..
    fun printSig {
      cout << d.getDeclName() << ": returns "
           << r.typeName() << d.retTypeName() << ", arg types: ";

      ParameterDeclarationClause_Node *pdc = d.getFnParams();
      xassert(pdc);    // otherwise isFunction had to be 0
      pdc->printSig();
      cout << endl;
    }

    fun typeCheck {
      // typecheck the signature
      Type const *type = d.getDeclType(env, r.getType(env));

      // must be a function type, otherwise the parser has
      // screwed up (in particular the 'isFunction' attribute)
      xassert(type->isFunctionType());
      FunctionType const *fnType = &type->asFunctionTypeC();

      // add the function decl to the original environment
      DeclFlags flags = r.getDeclFlags();   // inline, virtual, etc.
      string name = d.getDeclName();
      declareVariable(env, name, flags, fnType);

      // then grab it
      Variable *funcVar = env->getVariable(name);
      xassert(funcVar->type == fnType);

      // add the formals to the new environment we'll create for
      // the function body
      xassert(!localEnv);
      localEnv = new Env(env);     // scope

      try {
        FOREACH_OBJLIST(Parameter, fnType->params, iter) {
          Parameter const *param = iter.data();
          if (!param->name.isempty()) {
            // would really like to be doing this in the context
            // of the tree node that actually defined the name...
            declareVariable(localEnv, param->name, DF_NONE, param->type);
          }
        }

        // typecheck the body
        Owner<CilCompound> body; body = newCompound();
        delete b.typeCheck(localEnv, *body);

        ana_endScope(localEnv);

        // intermediate form: for now, just another instruction ...
        // perhaps I should separate out a language of declarations?
        inst.append(newFunDecl(funcVar, body.xfr()));

        return noCilValue();
      }       
      
      catch (...) {
        // see above
        localEnv->killParentLink();
        throw;
      }
    }
  }

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  FunctionBody          // {c,d}tor
    { fun printSig { cout << d.getDeclName() << ": ctor or dtor\n"; } }

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  ":" MemInitializerList FunctionBody   // ctor
    { fun printSig { cout << d.getDeclName() << ": ctor with init list\n"; } }
}

nonterm FunctionBody : Checkable -> s:CompoundStatement {
  fun typeCheck = s.typeCheck(env, inst);
}

nonterm ExplicitOpt -> "explicit" | empty ;


// ------ A.8 Classes ------
// I'm going to use the "class" terminology throughout, even though
// C only has "struct" and "union"
nonterm ClassSpecifier : HasType ->
  k:ClassKeyword n:ClassNameOpt base:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}"
{
  fun getType {
    // get preliminary info
    CompoundType::Keyword keyword = k.getKeyword();
    string name = n.getName();    // could be ""

    // TODO: the rules below are wrong since they don't allow
    // something to be redeclared inside a nested scope

    // construct the vessel to carry additional stuff
    CompoundType *compound = env->lookupCompound(name);
    if (compound && compound->isComplete()) {
      throwError(stringc << "already declared: " << name);
    }
    if (compound && compound->keyword != keyword) {
      throwError(stringc << "declared as different kind of compound: " << name);
    }
    if (!compound) {
      compound = env->lookupOrMakeCompound(name, keyword);
      xassert(compound);
    }
    compound->makeComplete(NULL /*no enclosing env for C structs*/);

    // ignore 'base' for now

    // add info about the members
    memb.addMemberInfo(env, compound,
                       keyword==CompoundType::K_CLASS?
                         AM_PRIVATE : AM_PUBLIC);

    // print the compound we just declared
    trace("compounds") << compound->toStringWithFields() << endl;

    return env->makeType(compound);
  }
}

nonterm ClassNameOpt {
  fundecl string getName();
  -> empty         { fun getName = ""; }
  -> n:ClassName   { fun getName = n.getName(); }
}

nonterm ClassKeyword {
  fundecl CompoundType::Keyword getKeyword();
  -> "class"       { fun getKeyword = CompoundType::K_CLASS; }
  -> "struct"      { fun getKeyword = CompoundType::K_STRUCT; }
  -> "union"       { fun getKeyword = CompoundType::K_UNION; }
}


nonterm MemberDeclBase {
  // add info in this subtree to the compound we're building
  fundecl void addMemberInfo(Env *passedEnv, CompoundType *compound, AccessMode access);

  // for now, just eat it
  fun addMemberInfo {}

  literalCode "prefix" addMemberInfo {
    env = passedEnv;
  }
}

nonterm MemberDeclarationSeqOpt : MemberDeclBase {
  -> empty ;

  -> decl:MemberDeclaration list:MemberDeclarationSeqOpt {
    fun addMemberInfo {
      try {
        decl.addMemberInfo(env, compound, access);
      }
      catch (XSemanticError &x) {
        cout << "Error: " << x.err.whyStr() << endl;
      }

      list.addMemberInfo(env, compound, access);
    }
  }

  // unhandled
  -> AccessSpecifier ":" MemberDeclarationSeqOpt ;
}

nonterm AccessSpecifier -> "public" | "private" | "protected" ;

nonterm MemberDeclaration : MemberDeclBase {
  -> spec:DeclSpecifier list:MemberDeclaratorList ";" {    // member fn or data
    fun addMemberInfo {
      // same code from SimpleDeclaration
      Type const *type = spec.getType(env);
      DeclFlags flags = spec.getDeclFlags();
      list.declare(env, compound->env, flags, type);
    }
  }

  -> FunctionDefinition ";" ;                    // inline fn
  -> FunctionDefinition ;                        // syntactic tweak
  -> ExplicitOpt VirtualOpt d:Declarator ";"     // ctor, dtor, conv op
       { condition d.isFunction == 1; }
  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

nonterm HasDeclareNoSE {     // "SE" = "side effects"
  // this function is defined for declarators, etc.; for each declarator
  // in the subtree, combine 'type' with the additional type modifiers
  // associated with the declarator (if any), and add the completed
  // declaration, with 'flags', to 'env'
  fundecl void declare(Env *passedEnv, Env *destEnv, DeclFlags flags, Type const *type);
  literalCode "prefix" declare {
    env = passedEnv;
  }
}

// very similar to InitDeclaratorList
nonterm MemberDeclaratorList : HasDeclareNoSE {
  -> d:MemberDeclarator {
    fun declare { d.declare(env, destEnv, flags, type); }
  }

  -> list:MemberDeclaratorList "," d:MemberDeclarator {
    fun declare {
      list.declare(env, destEnv, flags, type);
      d.declare(env, destEnv, flags, type);
    }
  }
}

nonterm MemberDeclarator : HasDeclareNoSE {
  -> d:Declarator {
    fun declare {
      // this code is same as InitDeclarator
      Type const *fullType = d.getDeclType(env, type);
      declareVariable(destEnv, d.getDeclName(), flags, fullType);
    }
  }

  // other cases unhandled as yet
  fun declare {}
  -> Declarator "=" ConstantExpression ;   // pure; and member inits??
  -> L2_NAME ":" ConstantExpression ;      // named bitfield
  -> ":" ConstantExpression ;              // unnamed bitfield
}


// ------ A.9 Derived classes ------
nonterm BaseClauseOpt -> empty |
                         ":" BaseSpecifierList ;

nonterm BaseSpecifierList -> BaseSpecifier | BaseSpecifierList "," BaseSpecifier ;

nonterm BaseSpecifier -> VirtualOpt AccessSpecifierOpt PQClassName ;
nonterm VirtualOpt -> empty | "virtual" ;
nonterm AccessSpecifierOpt -> empty | AccessSpecifier ;

nonterm PQClassName -> ClassName | Qualifier PQClassName ;


// ------ A.10 Special member functions ------
nonterm ConversionFunctionId -> "operator" ConversionTypeId ;
nonterm ConversionTypeId -> TypeSpecifier ConversionDeclaratorOpt ;
nonterm ConversionDeclaratorOpt -> empty | PtrOperator ConversionDeclaratorOpt ;

nonterm MemInitializerList
  -> MemInitializer | MemInitializer "," MemInitializerList ;

// std has a separate rule for base class ctor call, but that's not
// a useful parsing distinction, so it just creates gratuitous
// ambiguities, and I've eliminated it
nonterm MemInitializer -> L2_NAME "(" ExpressionListOpt ")" ;     // member init


// ------ A.11 Overloading ------
nonterm OperatorFunctionId -> "operator" Operator ;

// the cpp standard is unclear on whether "()" is to be considered a token,
// or whether it is permissible to see it as "(" ")".. I'm using the latter
nonterm Operator {
  -> "new" | "delete" | "new" "[" "]" | "delete" "[" "]" ;
  -> BinaryOperator      /* filter out ".*" later */     ;
  -> AssignmentOperator                                  ;
  -> "!" | "~" | "," | "++" | "--" | "->"                ;
  -> "(" ")" | "[" "]"                                   ;
}


// ------ A.12 Templates ------
//TemplateParameterList -> TemplateParameter
//TemplateParameterList -> TemplateParameterList "," TemplateParameter

//TemplateParameter -> TypeParameter | ParameterDeclaration


nonterm TemplateId -> TemplateName "<" TemplateArgumentList ">" |
                      TemplateName "<" ">" ;

nonterm TemplateArgumentList -> TemplateArgument |
                                TemplateArgumentList "," TemplateArgument ;

nonterm TemplateArgument -> Literal | TypeId ;
// where I have Literal the std has AssignmentExpression...
// std also mentions IdExpression here, which is my PQVarName.....


// ------ A.13 Exception handling ------
// TODO: intermediate code gen for EH constructs
// is *all* wrong

nonterm TryBlock : Checkable, HasCFG
  -> "try" s:CompoundStatement h:HandlerSeq {
  fun typeCheck {
    delete s.typeCheck(env, inst);
    return h.typeCheck(env, inst);
  }
}

nonterm HandlerSeq : Checkable {
  -> h:Handler { fun typeCheck = h.typeCheck(env, inst); }
  -> h:Handler seq:HandlerSeq {
    fun typeCheck {
      delete h.typeCheck(env, inst);
      return seq.typeCheck(env, inst);
    }
  }
}

nonterm Handler : Checkable, ScopeNode {
  -> "catch" "(" d:ExceptionDeclaration ")" s:CompoundStatement {
    fun typeCheck {
      xassert(!localEnv);
      localEnv = new Env(env);    // scope

      try {
        delete d.typeCheck(localEnv, inst);
        return s.typeCheck(localEnv, inst);

        ana_endScope(localEnv);

        return noCilValue();
      }
      catch (...) {
        // see above
        localEnv->killParentLink();
        throw;
      }
    }
  }
}

nonterm ExceptionDeclaration : Checkable {
  -> s:TypeSpecifier d:Declarator {          // named exception object
    fun typeCheck {
      Type const *type = d.getDeclType(env, s.getType(env));
      string name = d.getDeclName();
      declareVariable(env, name, DF_NONE, type);

      return noCilValue();
    }
  }

  -> TypeSpecifier AbstractDeclarator     ;  // unnamed exception object
  -> "..."                                ;  // anything
}

nonterm ThrowExpression : Checkable, HasType {
  -> "throw" ;
  -> "throw" e:AssignmentExpression {
    fun typeCheck = e.typeCheck(env, inst);
    fun getType = e.getType(env);
  }
}


// ------------------- GNU extensions -------------------
// just enough to get past them ..

// all operators/punctuators except "(" and ")"
nonterm GNUExprOp ->
  "[" | "]" | "->" | "::" | "." | "!" | "~" | "+" | "-" | "++" | "--" |
  "&" | "*" | ".*" | "->*" | "/" | "%" | "<<" | ">>" | "<" | "<=" | ">" |
  ">=" | "==" | "!=" | "^" | "|" | "&&" | "||" | "?" | ":" | "=" | "*=" |
  "/=" | "%=" | "+=" | "-=" | "&=" | "^=" | "|=" | "<<=" | ">>=" | "," |
  "..." | ";" | "{" | "}" ;

// all of them, I guess..
nonterm GNUExprKeyword ->
  "asm" | "auto" | "break" | "bool" | "case" | "catch" | "cdecl" | "char" |
  "class" | "const" | "const_cast" | "continue" | "default" | "delete" |
  "do" | "double" | "dynamic_cast" | "else" | "enum" | "explicit" | "extern" |
  "float" | "for" | "friend" | "goto" | "if" | "inline" | "int" | "long" |
  "mutable" | "new" | "operator" | "pascal" | "private" | "protected" |
  "public" | "register" | "reinterpret_cast" | "return" | "short" |
  "signed" | "sizeof" | "static" | "static_cast" | "struct" | "switch" |
  "template" | "this" | "throw" | "try" | "typedef" | "typeid" | "union" |
  "unsigned" | "virtual" | "void" | "volatile" | "wchar_t" | "while" | "__typeof__";


nonterm GNUAttribute -> "__attribute__" "(" "(" GNUExprSeq ")" ")";

// recognize grouping only
nonterm GNUExprSeq -> empty | GNUExpr GNUExprSeq ;
nonterm GNUExpr -> "(" GNUExprSeq ")"
                 | L2_NAME | GNUExprOp | GNUExprKeyword
                 | L2_INT_LITERAL | L2_STRING_LITERAL ;

nonterm GNUAsmStatement -> "asm" "(" GNUExprSeq ")" ";"
                         | "asm" "volatile" "(" GNUExprSeq ")" ";" ;


// -------------------------------------------------------
literalCode "epilogue" {

#include "trace.h"    // traceAddSys
#include "glr.h"      // StackNode::printAllocStats


#if 0   // not used; old test code
bool processNode(TreeNode const *n, void*)
{
  if (n->getSymbolC()->name.equals("FunctionDefinition")) {
    FunctionDefinition_Node const *fn = (FunctionDefinition_Node*)n;
    fn->printSig();
  }
  return false;    // continue
}

// this code went with it, in main
  // simple test: print all function definition signatures
  cout << "------ all function def signatures ------\n";
  top->walkTree(processNode);
#endif // 0


CilExpr *todoCilExpr()
{
  // rather than segfaulting, let's make something reasonable
  return newIntLit(12345678);    // hopefully recognizable
}

CilInst *todoCilInst()
{
  return newLabel("unimplementedInst");
}


int fakemain(int argc, char *argv[])
{
  // by default, print progress reports
  traceAddSys("progress");

  // do this before creating the first environment
  // (this messes up the usage string printed by treeMain
  // but who cares)
  while (traceProcessArg(argc, argv))
    {}

  try {
    // this program's exception-handling structure is mature
    // enough that printing all thrown exceptions has crossed
    // the line from helpful to annoying
    xBase::logExceptions = false;
    if (tracingSys("eh")) {
      xBase::logExceptions = true;     // sometimes I want them .. :)
    }

    // place to store the tree
    ParseTreeAndTokens tree;

    // dataflow environment ...
    DataflowEnv denv;

    // toplevel environment, in which each toplevel form
    // will be evaluated, just before that form is thrown
    // away
    //traceAddSys("env-declare");
    Env env(&denv);

    // carry this context in the tree, since it is an argument
    // to node constructors
    tree.extra = &env;

    // use another try to catch ambiguities so we can
    // report them before the tree is destroyed
    try {
      // this sets everything in motion, including analysis of
      // tree, etc; it returns when the entire tree has been
      // processed
      treeMain(tree, argc, argv);
    }
    catch (XAmbiguity &x) {
      cout << x << endl;
      return 4;
    }
  }
  catch (xBase &x) {
    cout << "died on exception: " << x << endl;
    return 6;
  }

  // since this is outside all the scopes that create interesting
  // nodes, the stat counts should be 0
  TreeNode::printAllocStats();
  StackNode::printAllocStats();
  CilExpr::printAllocStats();
  CilInst::printAllocStats();

  return 0;
}


// toplevel entries to the parser for the ocaml code
#ifdef WES_OCAML_LINKAGE
extern "C" {

value c_to_ocaml(struct wes_ast_node *n, char *filename)
{
    CAMLparam0();
    CAMLlocal4(result,str,arr,child);
    int i;

    result = alloc(5,0);
    str = copy_string(n->name);
    Store_field(result, 0, str);
    Store_field(result, 2, Val_int(n->line));
    Store_field(result, 3, Val_int(n->col));
    Store_field(result, 4, (int)(filename));
    if (n->num_children == 0) {
	Store_field(result, 1, Atom(0));
	CAMLreturn(result);
    } else {
	arr = alloc(n->num_children, 0);
	for (i=0;i<n->num_children;i++) {
	    child = c_to_ocaml(n->children[i],filename);
	    modify(&Field(arr,i), child);
	}
	Store_field(result, 1, arr);
	CAMLreturn(result);
    }
}

void wes_print(struct wes_ast_node * n)
{
    int i;
    printf("(%s",n->name);
    for (i=0;i<n->num_children;i++)
	wes_print(n->children[i]);
    printf(")");
}

/* I am putting this here to avoid "multiple declaration" errors from the
 * ocaml linker which is not quite as robust as g++ */
struct wes_list * wes_result_list;

value wes_main(char *filename) {
    CAMLparam0();
    CAMLlocal2(retval, c);
    char *argv[5] = {
	"cc.gr",
	"-tr",
	"parse-tree,sizeof",
	"cc.gr",
	filename};
    int argc = 5;
    int res;
    struct wes_list * l;

    wes_result_list = NULL; // declaring this NULL at the toplevel
    			    // gives multiple definition errors on my machine
    res = fakemain(argc, argv);
    // examine wes_result_list

#if 0
    for (l = wes_result_list; l != NULL; l = l->tl) {
	struct wes_ast_node * n = l->hd;
	wes_print(n);
    }
    printf("\n\n");
#endif

    // convert it over to OCAML
    c = Val_int(0);
    for (l = wes_result_list; l != NULL; l = l->tl) {
	struct wes_ast_node * n = l->hd;
	retval = alloc(2,0);
	Store_field(retval, 0, c_to_ocaml(n,filename));
	Store_field(retval, 1, c);
	c = retval;
    }
    wes_result_list = NULL; // memory leak!
    CAMLreturn(c);
}

} // extern "C"

#else /* !WES_OCAML_LINKAGE */

// 'main' for a standalone executable
int main(int argc, char *argv[])
{
  //fakemain(argc, argv);
  return fakemain(argc, argv);
}

#endif /* !WES_OCAML_LINKAGE */


} // epilogue
