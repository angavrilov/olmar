// cc.gr
// my attempt to implement a grammar for C++

// I'm actually trying to use this single file for both C and C++;
// the C++ grammar should parse C ok


// grab list generated by lexer
terminals {
  include("cc.tok")
}

          
// declarations for semantic functions
prologue {                            
  #include "cc_env.h"    // Env
  #include "cc_tree.h"   // CCTreeNode
}
treeNodeBase "CCTreeNode";


// dummy first rule
nonterm StartSymbol -> TranslationUnit L2_EOF;


// ------------- identifier ambiguity -------------------
// identifiers can play a number of roles, and this is the
// source of problems parsing C and C++
// (here, "variable" means variable or function; it names
// an object that exists at runtime)
nonterm HasName {
  fundecl string getName() const;
  fun getName = n.strValue;
}
nonterm TypedefName : HasName -> n:L2_NAME   ;
nonterm EnumName : HasName -> n:L2_NAME      ;
nonterm EnumValueName : HasName -> n:L2_NAME ;     // called 'enumerator' in spec
nonterm ClassName : HasName -> n:L2_NAME     ;
nonterm TemplateName : HasName -> n:L2_NAME  ;
nonterm VariableName : HasName -> n:L2_NAME  ;
nonterm LabelName : HasName -> n:L2_NAME     ;


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------
nonterm Checkable {
  // this does several jobs:
  //   - check type consistency, and report errors where
  //     inconsistencies are found
  //   - add new symbols to the environment, with their types
  fundecl void typeCheck(Env &env) const;
        
/*
  // the problem is I can't call 'typeCheck' unless I have
  // a C++ class from which they're derived.. I'll put that
  // on hold for now, because it's not perfectly clear just
  // how common it will be to want to automate the walk
  // like this...

  // default behavior is to simply check all (nonterminal) subtrees
  // (ideal would be to check only 'Checkable' ones, but right
  // now I have no runtime way to determine that)
  fun typeCheck {
    // for now, no disambiguation
    Reduction const *red = only();

    FOREACH_OBJLIST(TreeNode, red->children, iter) {
      if (iter.data()->isNonterm()) {
      }
    }
  }
*/

  // so for now default impl is to do nothing
  fun typeCheck {}
}

nonterm TranslationUnit : Checkable {
  -> empty;
  -> d:Declaration t:TranslationUnit {
    fun typeCheck { 
      try {
        d.typeCheck(env);
      }
      catch (XSemanticError &x) {
        // error recovery; report and proceed
        env.report(x.err);
      }
      env.flushLocalErrors(cout);

      t.typeCheck(env); 
    } 
  }
}

// ------ A.4 Expressions ------
// base class for expressions
nonterm ExprBase {
  // return the integer this expression evaluates to at compile time
  fundecl int intEval(Env &env) const;
  fun intEval { throwError("not a constant integer expression"); }
  
  // check that all the used variables are declared, and report
  // those that are unused
  fundecl void varsDecld(Env &env) const;
  fun varsDecld {}
}


nonterm PrimaryExpression : ExprBase {
  -> e:Literal                  { fun intEval = e.intEval(env); }
  -> "this"                     {}
  
  formGroup {
    fun varsDecld { e.varsDecld(env) }
    -> "(" e:Expression ")"       { fun intEval = e.intEval(env); }
    -> e:PQVarName                {}
  }
}

nonterm Literal : ExprBase {
  -> i:L2_INT_LITERAL    { fun intEval = i.intValue; }
  -> L2_FLOAT_LITERAL | L2_STRING_LITERAL | L2_CHAR_LITERAL ;
}


// base class for nonterminals that yield a part of a
// string that describes a type
nonterm HasTypeName {
  // return either a complete type description, or part
  // of one to be concatenated in context
  fundecl string typeName() const;

  // default implementation: just yield the original input
  fun typeName = unparseString();
}

nonterm HasDeclName {
  // retrieve the name of the variable being declared
  fundecl string getDeclName() const;

  // again, for now, take the easy road
  fun getDeclName = unparseString();
}


// possibly-qualified name; essentially spec's id-expression
// missing: template-id because I don't know what that is
nonterm PQVarName : HasTypeName, HasDeclName, HasVarsDecld {
  // 'colonColon' attribute of PQVarName and Qualifier: set to 1 when "::" is
  // the leftmost token in the tree matched; this is important because
  // declarators aren't allowed to have the bare "::" qualifier
  attr colonColon;        // true if a bare "::" is in front

  -> n:VariableName {
    action colonColon := 0;
    fun varsDecld {
      if (!env.isDeclaredVar(n.getName())) {
        SemanticError err(this, SE_UNDECLARED_VAR);
        err.varName = n.getName();
        env.report(err);
      }
    }
  }

  fun varsDecld {                          
    // each of the remaining rules requires some more sophisticated
    // way of naming symbols
    reportError("varsDecld unimplemented");
  }

  -> OperatorFunctionId     { action colonColon := 0; }
  -> ConversionFunctionId   { action colonColon := 0; }
  -> "~" ClassName          { action colonColon := 0; }
  -> q:Qualifier rhs:PQVarName  {
    // this PQVarName is preceeded by :: if the Qualifier is
    action colonColon := q.colonColon;

    // can't put any more qualifiers on to left of ::
    condition rhs.colonColon == 0;
  }
}

nonterm Qualifier {
  attr colonColon;     // true for leading "::"

  -> "::"              { action colonColon := 1; }
  -> ClassName "::"    { action colonColon := 0; }
}


nonterm PostfixExpression : ExprBase {
  -> e:PrimaryExpression                         { fun intEval = e.intEval(env); }
  -> PostfixExpression "[" Expression "]"        ;   // array
  -> PostfixExpression "(" ExpressionListOpt ")" ;   // fn call
  -> PostfixExpression "." PQVarName             ;   // field access
  -> PostfixExpression "->" PQVarName            ;   // deref + field access
  -> PostfixExpression "++"                      ;
  -> PostfixExpression "--"                      ;

  // pulled these two because other rules supercede them
  //-> PostfixExpression "." PseudoDestructorName           ; // explicit dtor call
  //-> PostfixExpression "->" PseudoDestructorName          ;
  -> "dynamic_cast"     "<" TypeId ">" "(" Expression ")" ;   // casts
  -> "static_cast"      "<" TypeId ">" "(" Expression ")" ;
  -> "reinterpret_cast" "<" TypeId ">" "(" Expression ")" ;
  -> "const_cast"       "<" TypeId ">" "(" Expression ")" ;
  -> "typeid" "(" Expression ")"                          ;   // RTTI
  -> "typeid" "(" TypeId ")"                              ;
}

nonterm ExpressionList -> AssignmentExpression |
                          ExpressionList "," AssignmentExpression ;
nonterm ExpressionListOpt -> empty | ExpressionList ;

// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName
//PseudoDestructorName -> Qualifier PseudoDestructorName

nonterm UnaryExpression : ExprBase {
  -> e:PostfixExpression                 { fun intEval = e.intEval(env); }
  -> "++" CastExpression           ;
  -> "--" CastExpression           ;
  -> op:UnaryOperator e:CastExpression   { fun intEval = op.intEval(e.intEval(env)); }
  -> "sizeof" UnaryExpression      ;       // size of expression
  -> "sizeof" "(" TypeId ")"       ;       // size of type
  -> NewExpression                 ;
  -> DeleteExpression              ;
}

nonterm UnaryOperator {
  // return this operator's effect on integer value 'val'
  fundecl int intEval(int val) const;

  -> "*" | "&"     { fun intEval { throwError("can't apply this operator to an integer"); } }
  -> "+"           { fun intEval = val; }
  -> "-"           { fun intEval = -val; }
  -> "!"           { fun intEval = !val; }
  -> "~"           { fun intEval = ~val; }
}

// for now, no new-placement or "::" in front
// I've changed the syntax slightly to correct what I think is a mistake
// (my syntax allows array of ptr to fn, whereas std syntax doesn't -- TOVERIFY)
nonterm NewExpression {
  -> "new" TypeSpecifier NewDeclaratorOpt NewInitializerOpt ;
  -> "new" "(" TypeId ")" NewDeclaratorOpt NewInitializerOpt ;
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]")?  ("[" ConstExpression "]")*
nonterm NewDeclaratorOpt -> empty |
                            PtrOperator NewDeclaratorOpt |
                            DirectNewDeclarator ;        // commit to at least one "[" ... "]"
nonterm DirectNewDeclarator -> "[" Expression "]" |
                               DirectNewDeclarator "[" ConstantExpression "]" ;

nonterm NewInitializerOpt -> empty | "(" ExpressionListOpt ")" ;

// omitting possibility of initial "::"
nonterm DeleteExpression -> "delete" CastExpression          |
                            "delete" "[" "]" CastExpression  ;

nonterm CastExpression : ExprBase {
  -> e:UnaryExpression      { fun intEval = e.intEval(env); }
  -> "(" TypeId ")" CastExpression ;
}

// ++++ binary operator expression ++++
// primary expressions
nonterm BinaryExpression : ExprBase {
  attr prec;                  // precedence of binding (topmost) operator in expression

  -> e:CastExpression {
    action  prec := 100;      // higher precedence than anything else

    fun intEval = e.intEval(env);
  }

  -> left:BinaryExpression op:BinaryOperator right:BinaryExpression {
    action  prec := op.prec;

    condition  this.prec <= left.prec;             // precedence
    condition  this.prec <= right.prec;            // more precedence
    condition  op.leftAssoc == 1 ?
                 this.prec < right.prec :          // left associative
                 this.prec < left.prec;            // right associative

    fun intEval = op.intEval(left.intEval(env), right.intEval(env));
  }
}

// an operator in a binary expression
nonterm BinaryOperator {
  attr prec;             // precedence of operator; higher value binds more tightly
  attr leftAssoc;        // 1 means left-associative, 0 means right-associative

  // all have left precedence by default; can override individually
  action  leftAssoc := 1;
                                                 
  // return this operator's effect on integers
  fundecl int intEval(int left, int right) const;

  // highest precedence
  formGroup {
    action prec:=64;
    -> ".*" | "->*"     { fun intEval { throwError("can't apply this operator to integers"); } }
  }

  formGroup {
    action prec:=60;
    -> "*"              { fun intEval = left * right; }
    -> "/"              { fun intEval = left / right; }
    -> "%"              { fun intEval = left % right; }
  }

  formGroup {
    action prec:=56;
    -> "+"              { fun intEval = left + right; }
    -> "-"              { fun intEval = left - right; }
  }

  formGroup {
    action prec:=52;
    -> "<<"             { fun intEval = left << right; }
    -> ">>"             { fun intEval = left >> right; }
  }

  formGroup {
    action prec:=48;
    -> "<"              { fun intEval = left < right; }
    -> ">"              { fun intEval = left > right; }
    -> "<="             { fun intEval = left <= right; }
    -> ">="             { fun intEval = left >= right; }
  }

  formGroup {
    action prec:=44;
    -> "=="             { fun intEval = left == right; }
    -> "!="             { fun intEval = left != right; }
  }

  -> "&" {
    action prec:=40;      fun intEval = left & right;
  }

  -> "^" {
    action prec:=36;      fun intEval = left ^ right;
  }

  -> "|" {
    action prec:=32;      fun intEval = left | right;
  }

  -> "&&" {
    action prec:=28;      fun intEval = left && right;
  }

  -> "||" {
    action prec:=24;      fun intEval = left || right;
  }
  // lowest precedence
}
// ---- end of binary operator expression ----


nonterm ConditionalExpression : ExprBase {
  -> e:BinaryExpression {
    fun intEval = e.intEval(env);
  }

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression {
    fun intEval {
      // evaluate all of them first, so we get the check for the
      // expression being const regardless of which way the test goes
      // (this may in fact turn out to be wrong, but for now it's what
      // I think it should be)
      int c = cond.intEval(env);
      int t = th.intEval(env);
      int e = el.intEval(env);
      return c ? t : e;
    }
  }
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm AssignmentExpression : ExprBase {
  -> e:ConditionalExpression   { fun intEval = e.intEval(env); }
  -> BinaryExpression AssignmentOperator AssignmentExpression ;
  -> ThrowExpression ;
}

nonterm AssignmentOperator -> "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" |
                              "<<=" | "&=" | "^=" | "|=" ;

// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
nonterm Expression : ExprBase {
  -> ae:AssignmentExpression {
    fun intEval = ae.intEval(env);
  }
  -> e:Expression "," ae:AssignmentExpression {
    // choosing again to evaluate everything..
    fun intEval = e.intEval(env), ae.intEval(env);
  }
}
nonterm ExpressionOpt -> empty | Expression ;

// this is an expression with the additional requirement that
// it be entirely evaluable at compile time
// (which is essentially a type property)
nonterm ConstantExpression : ExprBase -> e:ConditionalExpression
  { fun intEval = e.intEval(env); }

// ------ A.5 Statements ------
// labeled-statement
nonterm Statement : Checkable {
  disamb typeCheck {
    // if it's not ambiguous, or we've already disambiguated,
    // go straight to the real deal
    if (reductions.count() == 1) {
      unamb_typeCheck(env);
      return;
    }

    // DARN!  need to break the type system here ... I'd like to
    // not have to remove all 'const' just for this ...
    ObjList<Reduction> &realReds =
      const_cast< ObjList<Reduction>& >(reductions);

    // pull all the competing reductions out into a private list
    ObjList<Reduction> myReds;
    myReds.concat(realReds);

    // need place to put the ones that are finished
    ObjList<Reduction> okReds;
    ObjList<Reduction> badReds;

    // one at a time, put them back, and attempt to type-check them
    while (myReds.isNotEmpty()) {
      // put it back
      Reduction *red = myReds.removeAt(0);
      realReds.append(red);

      // attempt type-check in a new environment so it can't
      // corrupt the main one we're working on
      Env newEnv(&env);
      try {
        unamb_typeCheck(newEnv);
      }
      catch (XSemanticError &x) {
        newEnv.report(x.err);
      }

      // remove the reduction from the main node
      realReds.removeAt(0);

      // did that work?
      if (newEnv.numLocalErrors() == 0) {
        // yes
        okReds.append(red);
      }
      else {
        // no
        badReds.append(red);

        // throw away the errors so they don't get
        // moved into the original environment
        newEnv.forgetLocalErrors();
      }
    }

    // put all the good ones back
    realReds.concat(okReds);

    // see what the verdict is
    if (realReds.count() == 1) {
      // successfully disambiguated
    }
    else if (realReds.count() > 1) {
      // more than one worked..
      THROW(XAmbiguity(this));
    }
    else {
      // none of them worked.. let's arbitrarily pick the first and
      // throw away the rest, and report the errors from that one
      realReds.append(badReds.removeAt(0));
    }

    // throw away the bad ones
    badReds.deleteAll();

    // now, we have exactly one reduction -- typecheck it
    // in the current environment
    xassert(realReds.count() == 1);
    unamb_typeCheck(env);
  }

  fun typeCheck { s.typeCheck(env); }

  -> LabelName ":" s:Statement ;
  -> "case" ConstantExpression ":" s:Statement ;
  -> "default" ":" s:Statement ;

  // expression-statement
  -> s:ExpressionStatement ;

  // compound-statement
  -> s:CompoundStatement ;

  // selection-statement
  -> "if" "(" Condition ")" s:Statement ;
  -> "if" "(" Condition ")" s1:Statement "else" s2:Statement      // preferred earlier when ambiguous
    { fun typeCheck { s1.typeCheck(env); s2.typeCheck(env); } }
  -> "switch" "(" Condition ")" s:Statement ;

  // iteration-statement
  -> "while" "(" Condition ")" s:Statement ;
  -> "do" s:Statement "while" "(" Expression ")" ";" ;

  // this is a special-purpose rule intended for use with (unexpanded)
  // macros that, internally, contain a for loop; it is *not* part of
  // the C or C++ languages!
  -> L2_NAME "(" ExpressionList ")" s:CompoundStatement ;

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" s1:ForInitStatement ConditionOpt ";" ExpressionOpt ")" s2:Statement
    { fun typeCheck { s1.typeCheck(env); s2.typeCheck(env); } }

  // jump-statement
  formGroup {
    fun typeCheck {}

    -> "break" ";" ;
    -> "continue" ";" ;
    -> "return" Expression ";" ;
    -> "return" ";" ;
    -> "goto" LabelName ";" ;
  }

  // declaration-statement
  -> s:BlockDeclaration ;

  // try-block
  -> s:TryBlock ;
}

nonterm ExpressionStatement : Checkable -> Expression ";" | ";" ;

nonterm CompoundStatement : Checkable -> "{" seq:StatementSeqOpt "}" {
  fun typeCheck {
    Env newEnv(&env);       // scope
    seq.typeCheck(newEnv);
  }
}

nonterm StatementSeqOpt : Checkable {
  -> empty ;
  -> seq:StatementSeqOpt s:Statement {
    fun typeCheck {
      try {
        seq.typeCheck(env);
      }
      catch (XSemanticError &x) {
        // error recovery; report and proceed
        env.report(x.err);
      }
      env.flushLocalErrors(cout);

      s.typeCheck(env);
    }
  }
}

nonterm Condition -> Expression | TypeSpecifierSeq Declarator "=" AssignmentExpression ;
nonterm ConditionOpt -> empty | Condition ;

nonterm ForInitStatement : Checkable -> s:ExpressionStatement | s:SimpleDeclaration
  { fun typeCheck { s.typeCheck(env); } }




// ----- A.6 Declarations ------
nonterm DeclarationSeqOpt : Checkable {
  -> empty {
    fun typeCheck {} 
  }
  -> seq:DeclarationSeqOpt d:Declaration {
    fun typeCheck {
      seq.typeCheck(env);
      d.typeCheck(env);
    }
  } 
}

nonterm Declaration : Checkable {
  fun typeCheck { d.typeCheck(env); }

  -> d:BlockDeclaration ;
  -> d:FunctionDefinition ;
  //-> TemplateDeclaration ;
  -> d:LinkageSpecification ;
}

// C++ has other alternatives..
nonterm BlockDeclaration : Checkable -> d:SimpleDeclaration
  { fun typeCheck { d.typeCheck(env); } }

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm SimpleDeclaration : Checkable {
  //e.g.: int                x                     ;
  -> spec:DeclSpecifier list:InitDeclaratorListOpt ";" {
    fun typeCheck {
      Type const *type = spec.getType(env);    // a complete type
      DeclFlags flags = spec.getDeclFlags();   // inline, virtual, etc.
      list.declare(env, flags, type);
    }
  }
}


// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

nonterm HasDeclFlags {
  // return the set of declaration flags present here
  fundecl DeclFlags getDeclFlags() const;
}

nonterm HasType {
  // return the Type represented by this syntax
  fundecl Type const *getType(Env &env) const;
}

nonterm DeclSpecifier : HasTypeName, HasType, HasDeclFlags {
  fun typeName = s.typeName();
  fun getType = s.getType(env);

  -> "inline" m:DeclModifierOpt s:TypeSpecifier {
    fun getDeclFlags = (DeclFlags)(DF_INLINE | m.getDeclFlags());
  }

  -> m:DeclModifierOpt s:TypeSpecifier {
    fun getDeclFlags = m.getDeclFlags();
  }
}

// my analysis (informal and ad-hoc) indicates that none of these can
// be used together; "inline" is pulled out because it can be used with
// "virtual", "static", "friend", and possibly "extern"
nonterm DeclModifierOpt : HasDeclFlags {
  -> empty         { fun getDeclFlags = DF_NONE; }
  -> "virtual"     { fun getDeclFlags = DF_VIRTUAL; }
  -> "friend"      { fun getDeclFlags = DF_FRIEND; }
  -> "mutable"     { fun getDeclFlags = DF_MUTABLE; }
  -> "typedef"     { fun getDeclFlags = DF_TYPEDEF; }
  -> "auto"        { fun getDeclFlags = DF_AUTO; }
  -> "register"    { fun getDeclFlags = DF_REGISTER; }
  -> "static"      { fun getDeclFlags = DF_STATIC; }
  -> "extern"      { fun getDeclFlags = DF_EXTERN; }
}


nonterm HasCVFlags {
  // return all const/volatile at this level
  fundecl CVFlags getCVFlags() const;
}

nonterm TypeSpecifier : HasTypeName, HasType, HasCVFlags {
  // generic implementation
  fun getType {
    Type const *baseType = s.getType(env);
    CVFlags cv = getCVFlags();

    // apply the cv flags to what we have
    Type const *ret = env.applyCVToType(cv, baseType);
    if (!ret) {
      // e.g.:
      //   typedef int (*Foo)();
      //   Foo const f;
      reportError(env, "cannot apply const/volatile to this type");
      return baseType;    // error recovery
    }
    return ret;
  }

  // default impls
  fun typeName = s.typeName();
  fun getCVFlags = CV_NONE;

  // these are the atomic types (see types.txt)
  formGroup {
    -> s:SimpleTypeSpecifier ;          // int

    -> s:SimpleCVTypeSpecifier          // unsigned const char  (not good style, IMO)
         { fun getCVFlags = s.getCVFlags(); }

    -> s:ElaboratedTypeSpecifier ;      // class foo  or  enum bar

    -> s:ClassSpecifier                 // class { ... }
         { fun typeName = "class { ... }"; }
    -> s:EnumSpecifier                  // enum { ... }
         { fun typeName = "enum { ... }";
           fun getType { xfailure("not implemented"); } }
  }

  // these are: "CV* atomic-type" or "atomic-type CV*"
  formGroup {
    fun typeName = stringc << s.typeName() << " " << q.typeName();

    fun getCVFlags {
      // get flags from underlying specifier
      CVFlags flags = s.getCVFlags();

      // add the flag at this level
      return (CVFlags)(flags | q.getCVFlags());
    }

    -> q:CVQualifier s:TypeSpecifier ;  // const int
    -> s:TypeSpecifier q:CVQualifier ;  // int const
  }
}


nonterm ElaboratedTypeSpecifier : HasTypeName, HasType {
  -> k:ClassKeyword n:L2_NAME {
    fun getType {
      CompoundType::Keyword keyword = k.getKeyword();
      CompoundType const *type = env.lookupOrMakeCompound(n.strValue, keyword);
      if (!type) {
        // e.g.:
        //   class Foo;
        //   struct Foo *f;
        throwError("compound kind mismatch");
      }

      return env.makeType(type);
    }
  }

  -> "enum" n:L2_NAME {
    fun getType {
      EnumType const *type = env.lookupEnum(n.strValue);
      if (!type) {
        throwError("undeclared enum");
      }
      return env.makeType(type);
    }
  }
}


nonterm SimpleTypeBase : HasType {
  // helper to get the simple type spec, to cut down on
  // syntactic verbiage
  fundecl SimpleTypeId getst() const;
  fun getst { xfailure("can't call me"); }

  fun getType {
    return env.getSimpleType(getst());
  }
}

// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here; I do not
nonterm SimpleTypeSpecifier : SimpleTypeBase, HasTypeName {
  fun typeName {
    return simpleTypeName(getst());
  }

  // the existence of this production is part of why parsing C is hard
  -> n:PQTypeName {
    fun getType {
      Type const *ret = env.lookupType(n.typeName());
      if (!ret) {
        throwError(stringc << "undefined type: " << n.typeName());
      }
      return ret;
    }
    fun typeName = n.typeName();
  }

  -> "char"                     { fun getst = ST_CHAR; }
  -> "unsigned" "char"          { fun getst = ST_UNSIGNED_CHAR; }
  -> "signed" "char"            { fun getst = ST_SIGNED_CHAR; }
  -> "bool"                     { fun getst = ST_BOOL; }
  -> "unsigned"                 { fun getst = ST_UNSIGNED_INT; }
  -> "unsigned" "int"           { fun getst = ST_UNSIGNED_INT; }
  -> "signed"                   { fun getst = ST_INT; }
  -> "signed" "int"             { fun getst = ST_INT; }
  -> "int"                      { fun getst = ST_INT; }
  -> "unsigned" "short" "int"   { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "short"         { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "long" "int"    { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" "long"          { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "signed" "long" "int"      { fun getst = ST_LONG_INT; }
  -> "signed" "long"            { fun getst = ST_LONG_INT; }
  -> "long" "int"               { fun getst = ST_LONG_INT; }
  -> "long"                     { fun getst = ST_LONG_INT; }
  -> "signed" "short" "int"     { fun getst = ST_SHORT_INT; }
  -> "signed" "short"           { fun getst = ST_SHORT_INT; }
  -> "short" "int"              { fun getst = ST_SHORT_INT; }
  -> "short"                    { fun getst = ST_SHORT_INT; }
  -> "wchar_t"                  { fun getst = ST_WCHAR_T; }
  -> "float"                    { fun getst = ST_FLOAT; }
  -> "double"                   { fun getst = ST_DOUBLE; }
  -> "long" "double"            { fun getst = ST_LONG_DOUBLE; }
  -> "void"                     { fun getst = ST_VOID; }
}


// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm PQTypeName : HasTypeName {
  -> n:L2_NAME                 { fun typeName = n.strValue; }
  -> TemplateId                { fun typeName = "(template-id)"; }
  -> Qualifier n:PQTypeName    { fun typeName = stringc << "(qualifier)" << n.typeName(); }
}

// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll probably merge them at some point
nonterm SimpleCVTypeSpecifier : SimpleTypeBase, HasTypeName, HasCVFlags {
  fun typeName {
    return stringc << simpleTypeName(getst()) << " " << q.typeName();
  }

  fun getCVFlags = q.getCVFlags();

  -> "unsigned" q:CVQualifierSeq "char"         { fun getst = ST_UNSIGNED_CHAR; }
  -> "signed" q:CVQualifierSeq "char"           { fun getst = ST_SIGNED_CHAR; }
  -> "unsigned" q:CVQualifierSeq "int"          { fun getst = ST_UNSIGNED_INT; }
  -> "signed" q:CVQualifierSeq "int"            { fun getst = ST_INT; }
  -> "unsigned" q:CVQualifierSeq "short" "int"  { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" "short" q:CVQualifierSeq "int"  { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" q:CVQualifierSeq "short"        { fun getst = ST_UNSIGNED_SHORT_INT; }
  -> "unsigned" q:CVQualifierSeq "long" "int"   { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" "long" q:CVQualifierSeq "int"   { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "unsigned" q:CVQualifierSeq "long"         { fun getst = ST_UNSIGNED_LONG_INT; }
  -> "signed" q:CVQualifierSeq "long" "int"     { fun getst = ST_LONG_INT; }
  -> "signed" "long" q:CVQualifierSeq "int"     { fun getst = ST_LONG_INT; }
  -> "signed" q:CVQualifierSeq "long"           { fun getst = ST_LONG_INT; }
  -> "long" q:CVQualifierSeq "int"              { fun getst = ST_LONG_INT; }
  -> "signed" q:CVQualifierSeq "short" "int"    { fun getst = ST_SHORT_INT; }
  -> "signed" "short" q:CVQualifierSeq "int"    { fun getst = ST_SHORT_INT; }
  -> "signed" q:CVQualifierSeq "short"          { fun getst = ST_SHORT_INT; }
  -> "short" q:CVQualifierSeq "int"             { fun getst = ST_SHORT_INT; }
  -> "long" q:CVQualifierSeq "double"           { fun getst = ST_LONG_DOUBLE; }
}

nonterm EnumSpecifier -> "enum" "{" EnumeratorListOpt "}" |
                         "enum" EnumName "{" EnumeratorListOpt "}" ;

nonterm EnumeratorList -> EnumeratorDefinition |
                          EnumeratorList "," EnumeratorDefinition ;
nonterm EnumeratorListOpt -> empty | EnumeratorList ;

nonterm EnumeratorDefinition -> EnumValueName |
                                EnumValueName "=" ConstantExpression ;

nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

nonterm LinkageSpecification : Checkable {
  // todo: actually record the linkage spec
  -> "extern" L2_STRING_LITERAL "{" d:DeclarationSeqOpt "}" |
     "extern" L2_STRING_LITERAL d:Declaration {
    fun typeCheck { d.typeCheck(env); }
  }
}

// ------ A.7 Declarators ------
// -- declarator --
// declarator: the "x" in a declaration like "int x"

nonterm HasDeclare {
  // this function is defined for declarators, etc.; for each declarator
  // in the subtree, combine 'type' with the additional type modifiers
  // associated with the declarator (if any), and add the completed
  // declaration, with 'flags', to 'env'
  fundecl void declare(Env &env, DeclFlags flags, Type const *type) const;
}

nonterm InitDeclaratorList : HasDeclare {
  -> d:InitDeclarator {
    fun declare { d.declare(env, flags, type); }
  }

  -> list:InitDeclaratorList "," d:InitDeclarator {
    fun declare {
      list.declare(env, flags, type);
      d.declare(env, flags, type);
    }
  }
}

nonterm InitDeclaratorListOpt : HasDeclare {
  -> empty                      { fun declare {} }
  -> list:InitDeclaratorList    { fun declare { list.declare(env, flags, type); } }
}

nonterm InitDeclarator : HasDeclare {
  fun declare {
    // get the full type from the declarator
    Type const *fullType = d.getDeclType(env, type);

    // get the declared name
    string name = d.getDeclName();

    // put that pair into the environment
    declareVariable(env, name, flags, fullType);
  }

  // don't know what to do with the initializer at this point..
  -> d:Declarator |                   // (int)  x
     d:Declarator Initializer ;       // (int)  x = 5
}

nonterm Initializer -> "=" InitializerClause |
                       "(" ExpressionList ")" ;          // ctor args

nonterm InitializerClause {
  -> AssignmentExpression        ;   // scalar
  -> "{" InitializerList "}"     ;   // array initializer
  -> "{" InitializerList "," "}" ;   // useful syntactic quirk
  -> "{" "}"                     ;   // ?  does this mean the array is zeroed?
}

nonterm InitializerList -> InitializerClause |
                           InitializerList "," InitializerClause ;


nonterm HasDeclType {
  // retrieve the type associated with this declaration, where
  // 'type' is the type as built so far (inherited from the
  // specifier, or constructed by parsing type constructors)
  fundecl Type const *getDeclType(Env &env, Type const *type) const;
}

nonterm DeclaratorBase : HasTypeName, HasDeclType, HasDeclName {
  // get the node that has the function parameters, or NULL if this
  // isn't a function declaration
  fundecl ParameterDeclarationClause_Node const *getFnParams() const;
  fun getFnParams = NULL;

  // return the type name string for the return type, if this is
  // a function declaration
  fundecl string retTypeName() const;
  fun retTypeName { xfailure("not a function type"); }

  // name of variable or function being declared
  fun getDeclName = d.getDeclName();

  // attribute 'isFunction' of Declarator and DirectDeclarator: if the
  // type of the thing declared is a function (not a ptr to a
  // function, or an array of fns...), this is 1, otherwise 0; it is
  // used to do some disambiguation later on, where functions are
  // allowed to not have return types (DeclSpecifiers) to allow for
  // ctors and dtors, but other declarations must have types
  attr isFunction;
  
  // this attribute is needed to compute isFunction; it is 1 if the
  // declarator is simply a PQName, and 0 otherwise
  attr isName;
}

nonterm Declarator : DeclaratorBase {
  // (PtrOperator)* DirectDeclarator
  -> p:PtrOperator d:Declarator {
  
    // if d is a function, then this declares a function that
    // returns a pointer
    action isFunction := d.isFunction;
    action isName := 0;

    fun typeName = stringc << "*" << d.typeName();
    fun retTypeName = stringc << "*" << d.retTypeName();

    fun getFnParams {
      return d.getFnParams();
    }

    fun getDeclType {
      // grab info about the syntax
      CVFlags cv = p.getCVFlags();
      PtrOper op = p.getPtrOper();

      // make a new type that is, e.g., a pointer to the type
      // we were already given
      Type *newType = env.makePtrOperType(op, cv, type);

      // and declare the variable with that new, constructed type
      return d.getDeclType(env, newType);
    }
  }

  -> d:DirectDeclarator {
    action isFunction := d.isFunction;
    action isName := d.isName;

    fun getFnParams = d.getFnParams();
    fun typeName = d.typeName();
    fun retTypeName = d.retTypeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}

nonterm DirectDeclarator : DeclaratorBase {
  // for arrays
  fundecl bool hasSize() const;             // true if a size is specified
  fun hasSize = false;
  fundecl int getSize(Env &env) const;      // get declared size
  fun getSize { xfailure("can't call getSize"); }

  -> n:PQVarName {
    action isFunction := 0;
    action isName := 1;

    // declarator names can't be qualified with "::" (this resolves an
    // ambiguity with constructs like "Foo::Foo() {}")
    condition n.colonColon == 0;

    fun typeName = "";

    fun getDeclName = n.getDeclName();
    fun getDeclType {
      // having carried the type info along, we finally reach the
      // name of interest; return the final, collected type
      return type;
    }
  }

  // function type declarator; the return type comes from the type
  // specifier that preceeds this
  -> d:DirectDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt  {
  // ^^^ name of fn ^^^     ^^^^^^^^^^ arguments ^^^^^^^^^^     ^^^^^ const? ^^^^^^
    action isFunction := d.isName? 1 : d.isFunction;
    action isName := 0;

    fun getFnParams = &args;
    fun typeName = "(function)";
    fun retTypeName = d.typeName();

    fun getDeclType {
      // build a container for the function type
      FunctionType *fnType =
        env.makeFunctionType(type /*return type*/, q.getCVFlags());

      // fill in the details about arguments
      args.getArgTypes(env, fnType);

      // continue on down
      return d.getDeclType(env, fnType);
    }
  }

  // arrays
  formGroup {
    // Q: is there such a thing as returning an array, and could
    // this syntax declare one?  looks like yes...
    action isFunction := 0;
    action isName := 0;

    fun getDeclType {
      Type *arrType;
      if (hasSize()) {
        arrType = env.makeArrayType(type, getSize(env));    // known size
      }
      else {
        arrType = env.makeArrayType(type);                  // unknown size
      }

      return d.getDeclType(env, arrType);
    }

    // array of specified size
    -> d:DirectDeclarator "[" sz:ConstantExpression "]" {
      fun hasSize = true;
      fun getSize = sz.intEval(env);
      fun typeName = stringc << d.typeName() << "[" << sz.unparseString() << "]";
    }

    // array of unspecified size
    -> d:DirectDeclarator "[" "]" {
      fun typeName = stringc << d.typeName() << "[]";
    }
  }

  // precedence grouping
  -> "(" d:Declarator ")"  {
    action isFunction := d.isFunction;
    action isName := d.isName;

    fun getFnParams = d.getFnParams();
    fun typeName = d.typeName();
    fun retTypeName = d.retTypeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}


nonterm PtrOperator : HasCVFlags {
  // return which of the two "pointer" operators this is
  fundecl PtrOper getPtrOper() const;

  // c++ std mentions something with "::" as well, I don't know what that means
  -> "*" q:CVQualifierSeqOpt {
    fun getCVFlags = q.getCVFlags();
    fun getPtrOper = PO_POINTER;
  }

  -> "&" {
    fun getCVFlags = CV_NONE;
    fun getPtrOper = PO_REFERENCE;
  }
}


nonterm CVQualifierSeqOpt : HasCVFlags {
  -> empty              { fun getCVFlags = CV_NONE; }
  -> s:CVQualifierSeq   { fun getCVFlags = s.getCVFlags(); }
}

nonterm CVQualifierSeq : HasTypeName, HasCVFlags {
  -> q:CVQualifier                    { fun getCVFlags = q.getCVFlags(); }
  -> q:CVQualifier s:CVQualifierSeq   { fun getCVFlags = (CVFlags)(q.getCVFlags() | s.getCVFlags()); }
}

nonterm CVQualifier : HasTypeName, HasCVFlags {
  -> "const"            { fun getCVFlags = CV_CONST; }
  -> "volatile"         { fun getCVFlags = CV_VOLATILE; }
}


// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
// old -- why seq??  TypeId -> TypeSpecifierSeq AbstractDeclarator
nonterm TypeId -> TypeSpecifier AbstractDeclarator ;

nonterm TypeSpecifierSeq -> TypeSpecifier | TypeSpecifier TypeSpecifierSeq ;

                                                               
// note: the semantic functions in AbstractDeclarator are
// essentially duplicated code from Declarator ...
nonterm AbstractDeclarator : HasTypeName, HasDeclType {
  -> p:PtrOperator d:AbstractDeclarator {
    fun typeName = stringc << "*" << d.typeName();
    
    fun getDeclType =
      d.getDeclType(env, env.makePtrOperType(
        p.getPtrOper(), p.getCVFlags(), type));
  }

  -> d:DirectAbstractDeclarator {
    fun typeName = d.typeName();
    fun getDeclType = d.getDeclType(env, type);
  }
}

nonterm DirectAbstractDeclarator : HasTypeName, HasDeclType {
  fun typeName = d.typeName();

  // this is where abstract declarators differ from regular declarators;
  // for a declarator, this rule is "-> PQVarName"
  -> empty {
    fun typeName = "";
    fun getDeclType = type;
  }

  // function
  -> d:DirectAbstractDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt {
    fun getDeclType {
      FunctionType *fnType = 
        env.makeFunctionType(type /*return type*/, q.getCVFlags());
      args.getArgTypes(env, fnType);
      return d.getDeclType(env, fnType);
    }
  }

  -> d:DirectAbstractDeclarator "[" sz:ConstantExpression "]" {     // array of specified size
    fun getDeclType =
      d.getDeclType(env, env.makeArrayType(type, sz.intEval(env)));
  }

  -> d:DirectAbstractDeclarator "[" "]" {                        // array of unspecified size
    fun getDeclType =
      d.getDeclType(env, env.makeArrayType(type));
  }

  -> "(" d:AbstractDeclarator ")" {                              // precedence grouping
    fun getDeclType = d.getDeclType(env, type);
  }
}


nonterm HasPrintSig {
  // print to cout some part of the function signature
  fundecl void printSig() const;
}


// -- parameters in declarations --
nonterm HasArgTypes {
  // accumulate the types of the arguments and store them in 'fnType'
  fundecl void getArgTypes(Env &env, FunctionType *fnType) const;
}

nonterm ParameterDeclarationClause : HasPrintSig, HasArgTypes {
  -> p:ParameterDeclarationList {            // some args
    fun printSig { p.printSig(); }
    fun getArgTypes { p.getArgTypes(env, fnType); }
  }
  -> empty {                                 // no args
    fun printSig {}
    fun getArgTypes {}
  }
  -> "..." {                                 // all args are optional
    fun printSig { cout << "..."; }
    fun getArgTypes { fnType->acceptsVarargs = true; }
  }

  formGroup {
    fun printSig { p.printSig(); cout << ", ..."; }
    fun getArgTypes {
      p.getArgTypes(env, fnType);
      fnType->acceptsVarargs = true;
    }

    -> p:ParameterDeclarationList "..." ;      // args plus optionally more
    -> p:ParameterDeclarationList "," "..." ;  // same; alternative syntax
  }
}

nonterm ParameterDeclarationList : HasPrintSig, HasArgTypes {
  -> d:ParameterDeclaration {
    fun printSig { cout << d.typeName(); }
    fun getArgTypes { d.getArgTypes(env, fnType); }
  }

  -> list:ParameterDeclarationList "," d:ParameterDeclaration {
    fun printSig {
      list.printSig();
      cout << ", " << d.typeName();
    }
    fun getArgTypes {
      list.getArgTypes(env, fnType);
      d.getArgTypes(env, fnType);
    }
  }
}

nonterm ParameterDeclaration : HasTypeName, HasArgTypes {
  fundecl bool hasName() const;
  fundecl string getDeclName() const;

  fun typeName = stringc << s.typeName() << d.typeName();

  fun getArgTypes {
    // type
    Type const *specType = s.getType(env);
    Type const *fullType = d.getDeclType(env, specType);

    // check that there are no modifiers.. this could also be
    // done with attributes, and it's a toss-up in my mind now
    // which is the superior approach
    DeclFlags flags = s.getDeclFlags();
    if (flags != DF_NONE) {
      reportError(env, "modifiers not allowed in parameter declarations");
    }

    Parameter *param = new Parameter(fullType);
    if (hasName()) {
      param->name = getDeclName();
    }
    //if (hasDefaultArg()) {
    //  // these are nontrivial to handle, so for now I do nothing
    //}

    fnType->addParam(param);
  }

  formGroup {
    fun hasName = true;
    fun getDeclName = d.getDeclName();

    -> s:DeclSpecifier d:Declarator ;
    -> s:DeclSpecifier d:Declarator "=" AssignmentExpression ;
  }

  formGroup {
    fun hasName = false;
    fun getDeclName { xfailure("can't call me"); }

    -> s:DeclSpecifier d:AbstractDeclarator ;
    -> s:DeclSpecifier d:AbstractDeclarator "=" AssignmentExpression ;
  }
}

// -- function definition --
nonterm FunctionDefinition : Checkable, HasPrintSig {
  // I am wary of letting the declspecifier be optional, because it seems
  // to me that may introduce more ambiguities.. but it truly is missing
  // in ctors and dtors; so my idea now is to only permit it when the
  // declarator declares a function type (can't be more specific since there
  // aren't good syntactic clues for ctors)

  // all declarators must be of function type
  condition d.isFunction == 1;

  // this works for all the productions

  // return type      name/params   body
  -> r:DeclSpecifier  d:Declarator  b:FunctionBody {
    fun printSig {
      cout << d.getDeclName() << ": returns "
           << r.typeName() << d.retTypeName() << ", arg types: ";

      ParameterDeclarationClause_Node const *pdc = d.getFnParams();
      xassert(pdc);    // otherwise isFunction had to be 0
      pdc->printSig();
      cout << endl;
    }

    fun typeCheck {
      // typecheck the signature
      Type const *type = d.getDeclType(env, (r.getType(env)));
      
      // must be a function type, otherwise the parser has
      // screwed up (in particular the 'isFunction' attribute)
      xassert(type->isFunctionType());
      FunctionType const *fnType = &type->asFunctionTypeC();

      // add the function decl to the original environment
      DeclFlags flags = r.getDeclFlags();   // inline, virtual, etc.
      string name = d.getDeclName();
      declareVariable(env, name, flags, fnType);

      // add the formals to the new environment we'll create for
      // the function body
      Env newEnv(&env);
      FOREACH_OBJLIST(Parameter, fnType->params, iter) {
        Parameter const *param = iter.data();
        if (!param->name.isempty()) {
          // would really like to be doing this in the context
          // of the tree node that actually defined the name...
          declareVariable(newEnv, param->name, DF_NONE, param->type);
        }
      }

      // typecheck the body
      b.typeCheck(newEnv);
    }
  }

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  FunctionBody          // {c,d}tor
    { fun printSig { cout << d.getDeclName() << ": ctor or dtor\n"; } }

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  ":" MemInitializerList FunctionBody   // ctor
    { fun printSig { cout << d.getDeclName() << ": ctor with init list\n"; } }
}

nonterm FunctionBody : Checkable -> s:CompoundStatement {
  fun typeCheck { s.typeCheck(env); }
}

nonterm ExplicitOpt -> "explicit" | empty ;


// ------ A.8 Classes ------
// I'm going to use the "class" terminology throughout, even though
// C only has "struct" and "union"
nonterm ClassSpecifier : HasType ->
  k:ClassKeyword n:ClassNameOpt base:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}"
{
  fun getType {
    // get preliminary info
    CompoundType::Keyword keyword = k.getKeyword();
    string name = n.getName();    // could be ""

    // TODO: the rules below are wrong since they don't allow
    // something to be redeclared inside a nested scope

    // construct the vessel to carry additional stuff
    CompoundType *compound = env.lookupCompound(name);
    if (compound && !compound->incomplete) {
      throwError(stringc << "already declared: " << name);
    }
    if (compound && compound->keyword != keyword) {
      throwError(stringc << "declared as different kind of compound: " << name);
    }
    if (!compound) {
      compound = env.lookupOrMakeCompound(name, keyword);
      xassert(compound);
    }
    compound->incomplete = false;

    // ignore 'base' for now

    // add info about the members
    memb.addMemberInfo(env, compound, 
                       keyword==CompoundType::K_CLASS? 
                         AM_PRIVATE : AM_PUBLIC);

    return env.makeType(compound);
  }
}

nonterm ClassNameOpt {
  fundecl string getName() const;
  -> empty         { fun getName = ""; }
  -> n:ClassName   { fun getName = n.getName(); }
}

nonterm ClassKeyword {
  fundecl CompoundType::Keyword getKeyword() const;
  -> "class"       { fun getKeyword = CompoundType::K_CLASS; }
  -> "struct"      { fun getKeyword = CompoundType::K_STRUCT; }
  -> "union"       { fun getKeyword = CompoundType::K_UNION; }
}


nonterm MemberDeclBase {
  // add info in this subtree to the compound we're building
  fundecl void addMemberInfo(Env &env, CompoundType *compound, AccessMode access) const;

  // for now, just eat it
  fun addMemberInfo {}
}

nonterm MemberDeclarationSeqOpt : MemberDeclBase {
  -> empty ;
  -> MemberDeclaration MemberDeclarationSeqOpt ;
  -> AccessSpecifier ":" MemberDeclarationSeqOpt ;
}

nonterm AccessSpecifier -> "public" | "private" | "protected" ;

nonterm MemberDeclaration : MemberDeclBase {
  -> DeclSpecifier MemberDeclaratorList ";" ;    // member fn or data
  -> FunctionDefinition ";" ;                    // inline fn
  -> FunctionDefinition ;                        // syntactic tweak
  -> ExplicitOpt VirtualOpt d:Declarator ";"     // ctor, dtor, conv op
       { condition d.isFunction == 1; }
  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

nonterm MemberDeclaratorList -> 
  MemberDeclarator | MemberDeclaratorList "," MemberDeclarator ;

nonterm MemberDeclarator -> 
  Declarator | Declarator "=" ConstantExpression ;   // pure; and member inits??


// ------ A.9 Derived classes ------
nonterm BaseClauseOpt -> empty |
                         ":" BaseSpecifierList ;

nonterm BaseSpecifierList -> BaseSpecifier | BaseSpecifierList "," BaseSpecifier ;

nonterm BaseSpecifier -> VirtualOpt AccessSpecifierOpt PQClassName ;
nonterm VirtualOpt -> empty | "virtual" ;
nonterm AccessSpecifierOpt -> empty | AccessSpecifier ;

nonterm PQClassName -> ClassName | Qualifier PQClassName ;


// ------ A.10 Special member functions ------
nonterm ConversionFunctionId -> "operator" ConversionTypeId ;
nonterm ConversionTypeId -> TypeSpecifier ConversionDeclaratorOpt ;
nonterm ConversionDeclaratorOpt -> empty | PtrOperator ConversionDeclaratorOpt ;

nonterm MemInitializerList
  -> MemInitializer | MemInitializer "," MemInitializerList ;

// std has a separate rule for base class ctor call, but that's not
// a useful parsing distinction, so it just creates gratuitous
// ambiguities, and I've eliminated it
nonterm MemInitializer -> L2_NAME "(" ExpressionListOpt ")" ;     // member init


// ------ A.11 Overloading ------
nonterm OperatorFunctionId -> "operator" Operator ;

// the cpp standard is unclear on whether "()" is to be considered a token,
// or whether it is permissible to see it as "(" ")".. I'm using the latter
nonterm Operator {
  -> "new" | "delete" | "new" "[" "]" | "delete" "[" "]" ;
  -> BinaryOperator      /* filter out ".*" later */     ;
  -> AssignmentOperator                                  ;
  -> "!" | "~" | "," | "++" | "--" | "->"                ;
  -> "(" ")" | "[" "]"                                   ;
}


// ------ A.12 Templates ------
//TemplateParameterList -> TemplateParameter
//TemplateParameterList -> TemplateParameterList "," TemplateParameter

//TemplateParameter -> TypeParameter | ParameterDeclaration


nonterm TemplateId -> TemplateName "<" TemplateArgumentList ">" |
                      TemplateName "<" ">" ;

nonterm TemplateArgumentList -> TemplateArgument |
                                TemplateArgumentList "," TemplateArgument ;

nonterm TemplateArgument -> Literal | TypeId ;
// where I have Literal the std has AssignmentExpression...
// std also mentions IdExpression here, which is my PQVarName.....


// ------ A.13 Exception handling ------
nonterm TryBlock : Checkable -> "try" s:CompoundStatement h:HandlerSeq {
  fun typeCheck {
    s.typeCheck(env);
    h.typeCheck(env);
  }
}

nonterm HandlerSeq : Checkable {
  -> h:Handler { fun typeCheck { h.typeCheck(env); } }
  -> h:Handler seq:HandlerSeq {
    fun typeCheck {
      h.typeCheck(env);
      seq.typeCheck(env);
    }
  }
}

nonterm Handler : Checkable -> "catch" "(" d:ExceptionDeclaration ")" 
                               s:CompoundStatement {
  fun typeCheck {
    Env newEnv(&env);     // scope
    d.typeCheck(newEnv);
    s.typeCheck(newEnv);
  }
}

nonterm ExceptionDeclaration : Checkable {
  -> s:TypeSpecifier d:Declarator {          // named exception object
    fun typeCheck {
      Type const *type = d.getDeclType(env, s.getType(env));
      string name = d.getDeclName();
      declareVariable(env, name, DF_NONE, type);
    }
  }

  -> TypeSpecifier AbstractDeclarator     ;  // unnamed exception object
  -> "..."                                ;  // anything
}

nonterm ThrowExpression -> "throw" AssignmentExpression |
                           "throw" ;


// -------------------------------------------------------
epilogue {

#include "trace.h"    // traceAddSys


bool processNode(TreeNode const *n, void*)
{
  if (n->getSymbolC()->name.equals("FunctionDefinition")) {
    FunctionDefinition_Node const *fn = (FunctionDefinition_Node*)n;
    fn->printSig();
  }
  return false;    // continue
}


int main(int argc, char *argv[])
{
  try {
    xBase::logExceptions = false;
    Owner<ParseTree> tree(treeMain(argc, argv));
    
    // use another try to catch ambiguities so we can
    // report them before the tree is destroyed
    try {
      // get tree top
      xassert(tree->getTop()->getSymbolC()->name.equals("TranslationUnit"));
      TranslationUnit_Node *top = (TranslationUnit_Node*)(tree->getTop());

      // simple test: print all function definition signatures
      cout << "------ all function def signatures ------\n";
      top->walkTree(processNode);

      // more complex test: print all declarations
      cout << "------ all declarations ------\n";
      traceAddSys("env-declare");
      Env env;
      top->typeCheck(env);

      return 0;
    }
    catch (XAmbiguity &x) {
      cout << x << endl;
      return 4;
    }
  }
  catch (xBase &x) {
    cout << "died on exception: " << x << endl;
    return 6;
  }
}


} // epilogue
