// cc.gr
// my attempt to implement a grammar for C++

// I'm actually trying to use this single file for both C and C++;
// the C++ grammar should parse C ok


verbatim CCGr [

#include "strtable.h"     // StringRef
#include "cc_type.h"      // type identifiers like ST_CHAR

class CCGr : public UserActions {
  USER_ACTION_FUNCTIONS
  #include "cc.gen.h"
};

UserActions *makeUserActions(StringTable &)
{
  return new CCGr;
}

]


// grab list generated by lexer
terminals {
  include("cc.tok")

  token[int] L2_INT_LITERAL {
    dup(i) [ return i; ]
    del() []
  }
  
  token[float*] L2_FLOAT_LITERAL {
    dup(f) [ return new float(*f); ]
    del(f) [ delete f; ]
  }
  
  token[char] L2_CHAR_LITERAL {
    dup(c) [ return c; ]
    del() []
  }

  token[StringRef] L2_NAME {
    dup(s) [ return s; ]
    del()  []
  }

  token[StringRef] L2_STRING_LITERAL {
    dup(s) [ return s; ]
    del()  []
  }
}


// dummy first rule
nonterm StartSymbol -> TranslationUnit L2_EOF;


// ------------- identifier ambiguity -------------------
// identifiers can play two primary roles, and this is the
// source of problems parsing C and C++

// name of a type; introduced by class, struct, union, enum, typedef
nonterm TypeName -> n:L2_NAME   ;

// name of a variable or function; introduced by a declaration
nonterm VariableName -> n:L2_NAME  ;


// ---------------- higher-level syntax -----------------
// the section labels that follow (like "A.3") are from the
// C++ standard document (should track down a proper reference..)

// ------ A.3 Basic Concepts ------
nonterm TranslationUnit {
  -> empty ;

  -> t:TranslationUnit d:Declaration ;

  // allow assembly at toplevel for gnu compatibility
  -> t:TranslationUnit a:GNUAsmStatement ;

  // gnu extension: allow random semicolons at toplevel
  -> t:TranslationUnit ";" ;
}

// ------ A.4 Expressions ------
nonterm PrimaryExpression {
  -> e:Literal ;

  -> "this" ;

  -> "(" e:Expression ")" ;

  -> e:PQVarName ;

  // GNU extension
  -> "(" s:CompoundStatement ")" ;

  // gnu extension: "constructor expression"
  // (notation for literal struct values)
  // e.g.:
  //   struct Foo { int x; int y; };
  //   struct Foo myfoo;
  //   myfoo = (struct Foo) { 4, 5 };        <-- here
  // which would assign x=4 and y=5 in 'myfoo'
  -> "(" TypeId ")" CompoundInitializer ;
}

nonterm Literal {
  -> i:L2_INT_LITERAL ;
  -> L2_FLOAT_LITERAL ;
  -> StringLiteral ;
  -> c:L2_CHAR_LITERAL ;
}

// gnu: this is to handle gnu's f'd up pseduo-symbols, which
// have the annoying property that they have to concatenate
// with string literals (so I can't just, say, declare them
// to be char* and be done with it)
nonterm StringLiteral {
  -> L2_STRING_LITERAL ;
  -> StringLiteral L2_STRING_LITERAL ;
  -> StringLiteral "__FUNCTION__" ;
  -> StringLiteral "__PRETTY_FUNCTION__" ;
}


// possibly-qualified name; essentially spec's id-expression
// missing: template-id because I don't know what that is
nonterm PQVarName {
  -> n:VariableName ;

  -> OperatorFunctionId ;
  -> ConversionFunctionId ;
  -> "~" TypeName ;
  -> q:Qualifier rhs:PQVarName ;
}

nonterm Qualifier {
  -> "::" ;
  -> TypeName "::" ;
}


nonterm PostfixExpression {
  // array access
  -> a:PostfixExpression "[" e:Expression "]" ;

  // fn call
  -> f:PostfixExpression "(" e:ExpressionListOpt ")" ;

  // field access or deref + field access
  -> p:PostfixExpression "."  n:PQVarName ;
  -> p:PostfixExpression "->" n:PQVarName ;

  -> p:PostfixExpression "++" ;
  -> p:PostfixExpression "--" ;

  // pulled these two because other rules supercede them
  //-> PostfixExpression "." PseudoDestructorName           ; // explicit dtor call
  //-> PostfixExpression "->" PseudoDestructorName          ;

  -> "dynamic_cast"     "<" TypeId ">" "(" e:Expression ")" ;   // casts
  -> "static_cast"      "<" TypeId ">" "(" e:Expression ")" ;
  -> "reinterpret_cast" "<" TypeId ">" "(" e:Expression ")" ;
  -> "const_cast"       "<" TypeId ">" "(" e:Expression ")" ;

  // removed for now since I don't know much about them
  //-> "typeid" "(" Expression ")"                          ;   // RTTI
  //-> "typeid" "(" TypeId ")"                              ;
}


nonterm ExpressionList {
  -> a:AssignmentExpression ;
  -> e:ExpressionList "," a:AssignmentExpression ;
}

nonterm ExpressionListOpt {
  -> empty ;
  -> e:ExpressionList ;
}

// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName
//PseudoDestructorName -> Qualifier PseudoDestructorName

nonterm UnaryExpression {
  -> e:PostfixExpression ;

  -> "++" e:CastExpression ;
  -> "--" e:CastExpression ;

  // size of expression
  -> "sizeof" e:UnaryExpression ;

  -> e:DeleteExpression ;

  // dereference
  -> "*" e:CastExpression ;

  // other unary operators
  -> "&" e:CastExpression ;
  -> "+" e:CastExpression ;
  -> "-" e:CastExpression ;
  -> "!" e:CastExpression ;
  -> "~" e:CastExpression ;

  -> "sizeof" "(" t:TypeId ")" ;               // size of type

  -> NewExpression ;
}


// for now, no new-placement or "::" in front
// I've changed the syntax slightly to correct what I think is a mistake
// (my syntax allows array of ptr to fn, whereas std syntax doesn't -- TOVERIFY)
nonterm NewExpression {
  -> "new" TypeSpecifier NewDeclaratorOpt NewInitializerOpt ;
  -> "new" "(" TypeId ")" NewDeclaratorOpt NewInitializerOpt ;
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]")?  ("[" ConstExpression "]")*
nonterm NewDeclaratorOpt {
  -> empty ;
  -> PtrOperator NewDeclaratorOpt ;
  -> DirectNewDeclarator ;        // commit to at least one "[" ... "]"
}
nonterm DirectNewDeclarator {
  -> "[" Expression "]" ;
  -> DirectNewDeclarator "[" ConstantExpression "]" ;
}

nonterm NewInitializerOpt {
  -> empty ;
  -> "(" ExpressionListOpt ")" ;
}

// omitting possibility of initial "::"
nonterm DeleteExpression {
  -> "delete" e:CastExpression ;
  -> "delete" "[" "]" e:CastExpression ;
}

nonterm CastExpression {
  -> e:UnaryExpression ;
  -> "(" t:TypeId ")" e:CastExpression ;
}

// ++++ binary operator expression ++++
// primary expressions
nonterm BinaryExpression {
  -> e:CastExpression ;

  -> left:BinaryExpression "*"  right:BinaryExpression ;
  -> left:BinaryExpression "/"  right:BinaryExpression ;
  -> left:BinaryExpression "%"  right:BinaryExpression ;
  -> left:BinaryExpression "+"  right:BinaryExpression ;
  -> left:BinaryExpression "-"  right:BinaryExpression ;
  -> left:BinaryExpression "<<" right:BinaryExpression ;
  -> left:BinaryExpression ">>" right:BinaryExpression ;
  -> left:BinaryExpression "<"  right:BinaryExpression ;
  -> left:BinaryExpression ">"  right:BinaryExpression ;
  -> left:BinaryExpression "<=" right:BinaryExpression ;
  -> left:BinaryExpression ">=" right:BinaryExpression ;
  -> left:BinaryExpression "==" right:BinaryExpression ;
  -> left:BinaryExpression "!=" right:BinaryExpression ;
  -> left:BinaryExpression "&"  right:BinaryExpression ;
  -> left:BinaryExpression "^"  right:BinaryExpression ;
  -> left:BinaryExpression "|"  right:BinaryExpression ;

  -> left:BinaryExpression "&&" right:BinaryExpression ;
  -> left:BinaryExpression "||" right:BinaryExpression ;
}


nonterm ConditionalExpression {
  -> e:BinaryExpression ;

  -> cond:BinaryExpression "?" th:Expression ":" el:AssignmentExpression ;

  // wtf?  gnu...
  // linux driver code has "expr ? : expr" ...
  // according to Marat, "e1 ? : e2" is the same as "e1 ? e1 : e2",
  // except that e1 is only evaluated once
  -> cond:BinaryExpression "?" ":" el:AssignmentExpression ;
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm AssignmentExpression {
  -> e1:BinaryExpression "=" e2:AssignmentExpression ;

  -> e1:BinaryExpression op:AssignmentOperator e2:AssignmentExpression ;
}

nonterm AssignmentOperator {
  -> "*="  ;
  -> "/="  ;
  -> "%="  ;
  -> "+="  ;
  -> "-="  ;
  -> ">>=" ;
  -> "<<=" ;
  -> "&="  ;
  -> "^="  ;
  -> "|="  ;
}


// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
// update: now that I'm doing translation too, the difference
// in the meanings is great enough that I think they should be
// separate, as they are
nonterm Expression {
  -> ae:AssignmentExpression ;

  -> e:Expression "," ae:AssignmentExpression ;
}

nonterm ExpressionOpt {
  -> empty ;
  -> e:Expression ;
}

// this is an expression with the additional requirement that
// it be entirely evaluable to an int at compile time
// (the name exists simply to help document that fact; the grammar
// cannot enforce it)
nonterm ConstantExpression -> e:ConditionalExpression ;


// ------ A.5 Statements ------
// labeled-statement
nonterm Statement {
  -> n:L2_NAME ":" s:Statement ;

  // had to remove the statement because I found linux kernel
  // code that has "case:" immediately followed by "}"
  // TODO: revise grammar syntax so I can have both, and simply
  // prefer the one with a statement..
  -> "case" e:ConstantExpression ":" /*s:Statement*/ ;

  // gnu extension
  -> "case" low:ConstantExpression "..." high:ConstantExpression ":" ;

  -> "default" ":" s:Statement ;

  // expression-statement
  -> s:ExpressionStatement ;

  // compound-statement
  -> s:CompoundStatement ;

  // selection-statement
  -> "if" "(" e:Condition ")" s:Statement ;

  // if-then-else preferred over if-then when ambiguous
  // (so far unimplemented! (TODO))
  -> "if" "(" e:Condition ")" s1:Statement "else" s2:Statement ;

  -> "switch" "(" e:Condition ")" s:Statement ;

  -> "while" "(" e:Condition ")" s:Statement ;

  -> "do" s:Statement "while" "(" e:Expression ")" ";" ;

  // this is a special-purpose rule intended for use with (unexpanded)
  // macros that, internally, contain a for loop; it is *not* part of
  // the C or C++ languages!
  //-> L2_NAME "(" e:ExpressionList ")" s:CompoundStatement {
  //  fun typeCheck = NULL;       // TODO: implement?  eliminate?
  //}

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" s1:ForInitStatement c:ConditionOpt ";" e:ExpressionOpt ")" s2:Statement ;

  -> "break" ";" ;

  -> "continue" ";" ;

  -> "return" e:Expression ";" ;

  -> "return" ";" ;

  -> "goto" n:L2_NAME ";" ;

  // declaration-statement
  -> s:BlockDeclaration ;

  // try-block
  -> s:TryBlock ;

  // GNU extensions
  -> GNUAsmStatement ;
}

nonterm ExpressionStatement {
  -> ";" ;
  -> e:Expression ";" ;
}

nonterm CompoundStatement {
  -> "{" seq:StatementSeqOpt "}" ;
}

nonterm StatementSeqOpt {
  -> empty ;
  -> seq:StatementSeqOpt s:Statement ;
}

// the guard of e.g. an 'if' statement
nonterm Condition {
  -> e:Expression ;
  
  // C++ allows variable declarations in some interesting places...
  -> spec:TypeSpecifier decl:Declarator "=" e:AssignmentExpression ;
}

nonterm ConditionOpt {
  // an empty condition in a for loop is interpreted as true
  -> empty ;

  -> c:Condition ;
}

nonterm ForInitStatement {
  -> s:ExpressionStatement ;
  -> s:SimpleDeclaration ;
}


// ----- A.6 Declarations ------
nonterm DeclarationSeqOpt {
  -> empty ;
  -> seq:DeclarationSeqOpt d:Declaration ;
}

nonterm Declaration {
  -> d:BlockDeclaration ;
  -> d:FunctionDefinition ;
  //-> TemplateDeclaration ;
  -> d:LinkageSpecification ;
}

// C++ has other alternatives..
nonterm BlockDeclaration {
  -> d:SimpleDeclaration ;
}

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm SimpleDeclaration {
  //e.g.: int                x                     ;
  -> spec:DeclSpecifier list:InitDeclaratorListOpt ";" ;

  // gnu; specifically for linux printk declaration
  -> GNUAttribute decl:SimpleDeclaration ;
}


// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

nonterm DeclSpecifier {
  -> "inline" m:DeclModifier s:TypeSpecifier ;
  -> m:DeclModifier "inline" s:TypeSpecifier ;

  -> m:DeclModifier s:TypeSpecifier ;

  -> "inline" s:TypeSpecifier ;
  -> s:TypeSpecifier ;
}

// my analysis (informal and ad-hoc) indicates that none of these can
// be used together; "inline" is pulled out because it can be used
// with "virtual", "static", "friend", and possibly "extern"; I
// consider all this preferable to just allowing a "word soup"
nonterm DeclModifier {
  -> "virtual"     ;
  -> "friend"      ;
  -> "mutable"     ;
  -> "typedef"     ;
  -> "auto"        ;
  -> "register"    ;
  -> "static"      ;
  -> "extern"      ;
}


nonterm TypeSpecifier {
  -> s:SimpleTypeSpecifier ;          // int

  -> s:SimpleCVTypeSpecifier ;        // unsigned const char  (not good style, IMO)

  -> s:ElaboratedTypeSpecifier ;      // class foo  or  enum bar

  -> s:ClassSpecifier ;               // class { ... }
  -> s:EnumSpecifier ;                // enum { ... }

  -> q:CVQualifier s:TypeSpecifier ;  // const int
  -> s:TypeSpecifier q:CVQualifier ;  // int const

  // yet another attempt to find a good place for this
  -> s:TypeSpecifier GNUAttribute ;
}


nonterm ElaboratedTypeSpecifier {
  -> k:ClassKeyword n:L2_NAME ;

  -> "enum" n:L2_NAME ;
}


// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here; I do not
nonterm SimpleTypeSpecifier {
  // the existence of this production is part of why parsing C is hard
  -> n:PQTypeName ;

  -> "char"                     [ return ST_CHAR; ]
  -> "unsigned" "char"          [ return ST_UNSIGNED_CHAR; ]
  -> "signed" "char"            [ return ST_SIGNED_CHAR; ]
  -> "bool"                     [ return ST_BOOL; ]
  -> "unsigned"                 [ return ST_UNSIGNED_INT; ]
  -> "unsigned" "int"           [ return ST_UNSIGNED_INT; ]
  -> "signed"                   [ return ST_INT; ]
  -> "signed" "int"             [ return ST_INT; ]
  -> "int"                      [ return ST_INT; ]
  -> "unsigned" "short" "int"   [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short"         [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "long" "int"    [ return ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long"          [ return ST_UNSIGNED_LONG_INT; ]
  -> "signed" "long" "int"      [ return ST_LONG_INT; ]
  -> "signed" "long"            [ return ST_LONG_INT; ]
  -> "long" "int"               [ return ST_LONG_INT; ]
  -> "long"                     [ return ST_LONG_INT; ]
  -> "signed" "long" "long"     [ return ST_LONG_LONG; ]
  -> "long" "long"              [ return ST_LONG_LONG; ]
  -> "unsigned" "long" "long"   [ return ST_UNSIGNED_LONG_LONG; ]
  -> "signed" "short" "int"     [ return ST_SHORT_INT; ]
  -> "signed" "short"           [ return ST_SHORT_INT; ]
  -> "short" "int"              [ return ST_SHORT_INT; ]
  -> "short"                    [ return ST_SHORT_INT; ]
  -> "wchar_t"                  [ return ST_WCHAR_T; ]
  -> "float"                    [ return ST_FLOAT; ]
  -> "double"                   [ return ST_DOUBLE; ]
  -> "long" "double"            [ return ST_LONG_DOUBLE; ]
  -> "void"                     [ return ST_VOID; ]
}


// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm PQTypeName {
  -> n:TypeName ;
  -> TemplateId ;
  -> Qualifier n:PQTypeName ;
}

// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll probably merge them at some point
nonterm SimpleCVTypeSpecifier {
  -> "unsigned" q:CVQualifierSeq "char"         [ return ST_UNSIGNED_CHAR; ]
  -> "signed" q:CVQualifierSeq "char"           [ return ST_SIGNED_CHAR; ]
  -> "unsigned" q:CVQualifierSeq "int"          [ return ST_UNSIGNED_INT; ]
  -> "signed" q:CVQualifierSeq "int"            [ return ST_INT; ]
  -> "unsigned" q:CVQualifierSeq "short" "int"  [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" "short" q:CVQualifierSeq "int"  [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "short"        [ return ST_UNSIGNED_SHORT_INT; ]
  -> "unsigned" q:CVQualifierSeq "long" "int"   [ return ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" "long" q:CVQualifierSeq "int"   [ return ST_UNSIGNED_LONG_INT; ]
  -> "unsigned" q:CVQualifierSeq "long"         [ return ST_UNSIGNED_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "int"     [ return ST_LONG_INT; ]
  -> "signed" "long" q:CVQualifierSeq "int"     [ return ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long"           [ return ST_LONG_INT; ]
  -> "long" q:CVQualifierSeq "int"              [ return ST_LONG_INT; ]
  -> "signed" q:CVQualifierSeq "long" "long"    [ return ST_LONG_LONG; ]
  -> "unsigned" q:CVQualifierSeq "long" "long"  [ return ST_UNSIGNED_LONG_LONG; ]
  -> "signed" q:CVQualifierSeq "short" "int"    [ return ST_SHORT_INT; ]
  -> "signed" "short" q:CVQualifierSeq "int"    [ return ST_SHORT_INT; ]
  -> "signed" q:CVQualifierSeq "short"          [ return ST_SHORT_INT; ]
  -> "short" q:CVQualifierSeq "int"             [ return ST_SHORT_INT; ]
  -> "long" q:CVQualifierSeq "double"           [ return ST_LONG_DOUBLE; ]
}


nonterm EnumSpecifier {
  -> "enum" "{" list:EnumeratorListOpt "}" ;
  -> "enum" n:L2_NAME "{" list:EnumeratorListOpt "}" ;
}


nonterm EnumeratorList {
  -> def:EnumeratorDefinition ;
  -> list:EnumeratorList "," def:EnumeratorDefinition ;
}

nonterm EnumeratorListOpt {
  -> empty ;

  -> list:EnumeratorList ;
  -> list:EnumeratorList "," ;     // GNU extension (??)
}


nonterm EnumeratorDefinition {
  -> name:L2_NAME ;
  -> name:L2_NAME "=" expr:ConstantExpression ;
}


nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

nonterm LinkageSpecification {
  -> "extern" L2_STRING_LITERAL "{" d:DeclarationSeqOpt "}" ;
  -> "extern" L2_STRING_LITERAL d:Declaration ;
}

// ------ A.7 Declarators ------
// -- declarator --
// a declarator is the "x" in a declaration like "int x"

nonterm InitDeclaratorList {
  -> d:InitDeclarator ;
  -> list:InitDeclaratorList "," d:InitDeclarator ;
}

nonterm InitDeclaratorListOpt {
  -> empty ;
  -> list:InitDeclaratorList ;
}


nonterm InitDeclarator {
  -> d:Declarator ;                     // (int)  x

  -> d:Declarator i:Initializer ;       // (int)  x = 5
}

nonterm Initializer {
  -> "=" i:InitializerClause ;

  // this causes an ambiguity with
  //   int fileno(FILE *f);
  // because it could be multiplication.. handling it isn't that
  // hard, but for now let's just take out this rule
  //-> "(" ExpressionList ")" ;          // ctor args
}

nonterm InitializerClause {
  -> e:AssignmentExpression ;           // scalar
  -> c:CompoundInitializer ;            // array/structure initializer
}


// gnu extensions: labeled elements in initializers
// (*potentially* labeled)
nonterm LabeledInitializerClause {
  // no label
  -> init:InitializerClause ;

  // initialize a specific element of the array
  -> "[" ConstantExpression "]" "=" InitializerClause ;

  // initialize a range (inclusive) of elements of the array
  -> "[" ConstantExpression "..." ConstantExpression "]" "=" InitializerClause ;

  // intialize a named element of a structure
  -> "." PQVarName "=" InitializerClause ;

  // initialize a field of a specific element of the array
  -> "[" ConstantExpression "]" "." PQVarName "=" InitializerClause ;
}

nonterm CompoundInitializer {
  // array/structure initializer
  -> "{" list:InitializerList CommaOpt "}" ;

  // zero whatever it is
  -> "{" "}" ;
}

// useful syntactic quirk
nonterm CommaOpt {
  -> empty ;
  -> "," ;
}


nonterm InitializerList {
  -> init:LabeledInitializerClause ;
  -> list:InitializerList "," init:LabeledInitializerClause ;
}


nonterm Declarator {
  // (PtrOperator)* DirectDeclarator
  -> p:PtrOperator d:Declarator ;

  // I'm still looking for the right place to put GNUAttribute ...
  -> d:DirectDeclarator GNUAttribute ;       // GNU extension
  -> d:DirectDeclarator ;
}

nonterm DirectDeclarator {
  -> n:PQVarName ;

  // function  declarator; the return type comes from the type
  // specifier that preceeds this
  -> d:DirectDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt  ;
  // ^^^ name of fn ^^^     ^^^^^^^^^^ arguments ^^^^^^^^^^     ^^^^^ const? ^^^^^^

  // array of specified size
  -> d:DirectDeclarator "[" sz:ConstantExpression "]" ;

  // array of unspecified size
  -> d:DirectDeclarator "[" "]" ;

  // precedence grouping
  -> "(" d:Declarator ")"  ;
}


nonterm PtrOperator {
  // c++ std mentions something with "::" as well, I don't know what that means
  -> "*" q:CVQualifierSeqOpt ;

  -> "&" ;
}


nonterm CVQualifierSeqOpt {
  -> empty ;
  -> s:CVQualifierSeq ;
}

nonterm CVQualifierSeq {
  -> q:CVQualifier ;
  -> q:CVQualifier s:CVQualifierSeq ;
}

nonterm CVQualifier {
  -> "const" ;
  -> "volatile" ;
}


// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
nonterm TypeId {
  -> spec:TypeSpecifier decl:AbstractDeclarator ;

  // gnu extension
  -> "__typeof__" "(" e:Expression ")" ;
}

nonterm AbstractDeclarator {
  -> p:PtrOperator d:AbstractDeclarator ;

  -> d:DirectAbstractDeclarator ;
}

nonterm DirectAbstractDeclarator {
  // this is where abstract declarators differ from regular declarators;
  // for a declarator, this rule is "-> PQVarName"
  -> empty ;

  // function
  -> d:DirectAbstractDeclarator "(" args:ParameterDeclarationClause ")" q:CVQualifierSeqOpt ;

  -> d:DirectAbstractDeclarator "[" sz:ConstantExpression "]" ;     // array of specified size

  -> d:DirectAbstractDeclarator "[" "]" ;                        // array of unspecified size

  -> "(" d:AbstractDeclarator ")" ;                              // precedence grouping
}


nonterm ParameterDeclarationClause {
  -> p:ParameterDeclarationList ;            // some args
  -> empty ;                                 // no args
  -> "..." ;                                 // all args are optional
  -> p:ParameterDeclarationList "..." ;      // args plus optionally more
  -> p:ParameterDeclarationList "," "..." ;  // same; alternative syntax
}

nonterm ParameterDeclarationList {
  -> d:ParameterDeclaration ;
  -> list:ParameterDeclarationList "," d:ParameterDeclaration ;
}

nonterm ParameterDeclaration {
    -> s:DeclSpecifier d:Declarator ;
    -> s:DeclSpecifier d:Declarator "=" AssignmentExpression ;

    -> s:DeclSpecifier d:AbstractDeclarator ;
    -> s:DeclSpecifier d:AbstractDeclarator "=" AssignmentExpression ;
}

// -- function definition --
nonterm FunctionDefinition {
  // I am wary of letting the declspecifier be optional, because it seems
  // to me that may introduce more ambiguities.. but it truly is missing
  // in ctors and dtors; so my idea now is to only permit it when the
  // declarator declares a function type (can't be more specific since there
  // aren't good syntactic clues for ctors)

  // return type      name/params   body
  -> r:DeclSpecifier  d:Declarator  b:FunctionBody ;

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  FunctionBody ;         // {c,d}tor

  // return type      name/params   body
  -> ExplicitOpt      d:Declarator  ":" MemInitializerList FunctionBody ;  // ctor
}

nonterm FunctionBody -> s:CompoundStatement ;

nonterm ExplicitOpt {
  -> "explicit" ;
  -> empty ;
}


// ------ A.8 Classes ------
// I'm going to use the "class" terminology throughout, even though
// C only has "struct" and "union"
nonterm ClassSpecifier ->
  k:ClassKeyword n:ClassNameOpt base:BaseClauseOpt "{" memb:MemberDeclarationSeqOpt "}" ;

nonterm ClassNameOpt {
  -> empty         ;
  -> n:L2_NAME     ;
}

nonterm ClassKeyword {
  -> "class"       ;
  -> "struct"      ;
  -> "union"       ;
}


nonterm MemberDeclarationSeqOpt {
  -> empty ;

  -> decl:MemberDeclaration list:MemberDeclarationSeqOpt ;

  -> AccessSpecifier ":" MemberDeclarationSeqOpt ;
}

nonterm AccessSpecifier {
  -> "public" ;
  -> "private" ;
  -> "protected" ;
}

nonterm MemberDeclaration {
  -> spec:DeclSpecifier list:MemberDeclaratorList ";" ;    // member fn or data

  -> FunctionDefinition ";" ;                    // inline fn
  -> FunctionDefinition ;                        // syntactic tweak
  -> ExplicitOpt VirtualOpt d:Declarator ";" ;   // ctor, dtor, conv op

  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

// very similar to InitDeclaratorList
nonterm MemberDeclaratorList {
  -> d:MemberDeclarator ;

  -> list:MemberDeclaratorList "," d:MemberDeclarator ;
}

nonterm MemberDeclarator {
  -> d:Declarator ;

  -> Declarator "=" ConstantExpression ;   // pure; and member inits??
  -> ":" ConstantExpression ;              // unnamed bitfield
  -> ":" ConstantExpression GNUAttribute ;

  -> n:L2_NAME ":" e:ConstantExpression GNUAttribute ;
  -> n:L2_NAME ":" e:ConstantExpression ;      // named bitfield
}


// ------ A.9 Derived classes ------
nonterm BaseClauseOpt {
  -> empty ;
  -> ":" BaseSpecifierList ;
}

nonterm BaseSpecifierList {
  -> BaseSpecifier ;
  -> BaseSpecifierList "," BaseSpecifier ;
}

nonterm BaseSpecifier -> VirtualOpt AccessSpecifierOpt PQClassName ;
nonterm VirtualOpt {
  -> empty ;
  -> "virtual" ;
}
nonterm AccessSpecifierOpt {
  -> empty ;
  -> AccessSpecifier ;
}

nonterm PQClassName {
  -> TypeName ;
  -> Qualifier PQClassName ;
}


// ------ A.10 Special member functions ------
nonterm ConversionFunctionId -> "operator" ConversionTypeId ;
nonterm ConversionTypeId -> TypeSpecifier ConversionDeclaratorOpt ;
nonterm ConversionDeclaratorOpt {
  -> empty ;
  -> PtrOperator ConversionDeclaratorOpt ;
}

nonterm MemInitializerList {
  -> MemInitializer ;
  -> MemInitializer "," MemInitializerList ;
}

// std has a separate rule for base class ctor call, but that's not
// a useful parsing distinction, so it just creates gratuitous
// ambiguities, and I've eliminated it
nonterm MemInitializer -> L2_NAME "(" ExpressionListOpt ")" ;     // member init


// ------ A.11 Overloading ------
nonterm OperatorFunctionId -> "operator" Operator ;

nonterm Operator {
  -> "new" ;
  -> "delete" ;
  -> "new" "[" "]" ;
  -> "delete" "[" "]" ;

  -> "*"  ;
  -> "/"  ;
  -> "%"  ;
  -> "+"  ;
  -> "-"  ;
  -> "<<" ;
  -> ">>" ;
  -> "<"  ;
  -> ">"  ;
  -> "<=" ;
  -> ">=" ;
  -> "==" ;
  -> "!=" ;
  -> "&"  ;
  -> "^"  ;
  -> "|"  ;
  -> "&&" ;
  -> "||" ;

  -> AssignmentOperator   ;

  -> "!" ;
  -> "~" ;
  -> "," ;
  -> "++" ;
  -> "--" ;
  -> "->" ;
  -> "(" ")" ;      // Q: verify that cpp standard says that "()" is not one token
  -> "[" "]" ;
}


// ------ A.12 Templates ------
//TemplateParameterList -> TemplateParameter
//TemplateParameterList -> TemplateParameterList "," TemplateParameter

//TemplateParameter -> TypeParameter | ParameterDeclaration


nonterm TemplateId {
  -> TypeName "<" TemplateArgumentList ">" ;
  -> TypeName "<" ">" ;
}

nonterm TemplateArgumentList {
  -> TemplateArgument ;
  -> TemplateArgumentList "," TemplateArgument ;
}

nonterm TemplateArgument {
  // where I have Literal the std has AssignmentExpression...
  // std also mentions IdExpression here, which is my PQVarName.....
  -> Literal ;
  -> TypeId ;
}


// ------ A.13 Exception handling ------
nonterm TryBlock -> "try" s:CompoundStatement h:HandlerSeq ;

nonterm HandlerSeq {
  -> h:Handler ;
  -> h:Handler seq:HandlerSeq ;
}

nonterm Handler
  -> "catch" "(" d:ExceptionDeclaration ")" s:CompoundStatement ;

nonterm ExceptionDeclaration {
  -> s:TypeSpecifier d:Declarator ;          // named exception object

  -> TypeSpecifier AbstractDeclarator     ;  // unnamed exception object
  -> "..."                                ;  // anything
}

nonterm ThrowExpression {
  -> "throw" ;
  -> "throw" e:AssignmentExpression ;
}


// ------------------- GNU extensions -------------------
// just enough to get past them ..

// all operators/punctuators except "(" and ")"
nonterm GNUExprOp {
  -> "[" ;
  -> "]" ;
  -> "->" ;
  -> "::" ;
  -> "." ;
  -> "!" ;
  -> "~" ;
  -> "+" ;
  -> "-" ;
  -> "++" ;
  -> "--" ;
  -> "&" ;
  -> "*" ;
  -> ".*" ;
  -> "->*" ;
  -> "/" ;
  -> "%" ;
  -> "<<" ;
  -> ">>" ;
  -> "<" ;
  -> "<=" ;
  -> ">" ;
  -> ">=" ;
  -> "==" ;
  -> "!=" ;
  -> "^" ;
  -> "|" ;
  -> "&&" ;
  -> "||" ;
  -> "?" ;
  -> ":" ;
  -> "=" ;
  -> "*=" ;
  -> "/=" ;
  -> "%=" ;
  -> "+=" ;
  -> "-=" ;
  -> "&=" ;
  -> "^=" ;
  -> "|=" ;
  -> "<<=" ;
  -> ">>=" ;
  -> "," ;
  -> "..." ;
  -> ";" ;
  -> "{" ;
  -> "}" ;
}

// all of them, I guess..
nonterm GNUExprKeyword {
  -> "asm" ;
  -> "auto" ;
  -> "break" ;
  -> "bool" ;
  -> "case" ;
  -> "catch" ;
  -> "cdecl" ;
  -> "char" ;
  -> "class" ;
  -> "const" ;
  -> "const_cast" ;
  -> "continue" ;
  -> "default" ;
  -> "delete" ;
  -> "do" ;
  -> "double" ;
  -> "dynamic_cast" ;
  -> "else" ;
  -> "enum" ;
  -> "explicit" ;
  -> "extern" ;
  -> "float" ;
  -> "for" ;
  -> "friend" ;
  -> "goto" ;
  -> "if" ;
  -> "inline" ;
  -> "int" ;
  -> "long" ;
  -> "mutable" ;
  -> "new" ;
  -> "operator" ;
  -> "pascal" ;
  -> "private" ;
  -> "protected" ;
  -> "public" ;
  -> "register" ;
  -> "reinterpret_cast" ;
  -> "return" ;
  -> "short" ;
  -> "signed" ;
  -> "sizeof" ;
  -> "static" ;
  -> "static_cast" ;
  -> "struct" ;
  -> "switch" ;
  -> "template" ;
  -> "this" ;
  -> "throw" ;
  -> "try" ;
  -> "typedef" ;
  -> "typeid" ;
  -> "union" ;
  -> "unsigned" ;
  -> "virtual" ;
  -> "void" ;
  -> "volatile" ;
  -> "wchar_t" ;
  -> "while" ;
  -> "__typeof__" ;
}

nonterm GNUAttribute -> "__attribute__" "(" "(" GNUExprSeq ")" ")";

// recognize grouping only
nonterm GNUExprSeq {
  -> empty ;
  -> GNUExpr GNUExprSeq ;
}

nonterm GNUExpr {
  -> "(" GNUExprSeq ")" ;
  -> L2_NAME ;
  -> GNUExprOp ;
  -> GNUExprKeyword ;
  -> L2_INT_LITERAL ;
  -> L2_STRING_LITERAL ;
}

nonterm GNUAsmStatement {
  -> "asm" "(" GNUExprSeq ")" ";" ;
  -> "asm" "volatile" "(" GNUExprSeq ")" ";" ;
}
