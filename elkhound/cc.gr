// cc.gr
// my attempt to implement a grammar for C++

// I'm actually trying to use this single file for both C and C++;
// the C++ grammar should parse C ok, but also by filtering out all
// the lines with "C++" on them, you should get just the C rules


// grab list generated by lexer
terminals {
  include("cc.tok")
}


// start symbol
nonterm StartSymbol -> TranslationUnit L2_EOF;


// ------------- identifier ambiguity -------------------
// identifiers can play a number of roles, and this is the
// source of problems parsing C and C++
// (here, "variable" means variable or function; it names
// an object that exists at runtime)
nonterm TypedefName -> L2_NAME   ;
nonterm EnumName -> L2_NAME      ;
nonterm EnumValueName -> L2_NAME ;     // called 'enumerator' in spec
nonterm ClassName -> L2_NAME     ;
nonterm TemplateName -> L2_NAME  ;                                                                 // C++
nonterm VariableName -> L2_NAME  ;
nonterm LabelName -> L2_NAME     ;


// ---------------- higher-level syntax -----------------
// ------ A.3 Basic Concepts ------
nonterm TranslationUnit -> empty | Declaration TranslationUnit;

// ------ A.4 Expressions ------
nonterm PrimaryExpression -> Literal | "this" | "(" Expression ")" | PQVarName ;

nonterm Literal -> L2_INT_LITERAL | L2_FLOAT_LITERAL |
                   L2_STRING_LITERAL | L2_CHAR_LITERAL ;


// 'colonColon' attribute of PQVarName and Qualifier: set to 1 when "::" is
// the leftmost token in the tree matched; this is important because
// declarators aren't allowed to have the bare "::" qualifier


// possibly-qualified name; essentially spec's id-expression
// missing: template-id because I don't know what that is
nonterm PQVarName {
  attr colonColon;        // true if a bare "::" is in front

  -> VariableName           { action colonColon := 0; }
  // C++-begin
  -> OperatorFunctionId     { action colonColon := 0; }                          // C++
  -> ConversionFunctionId   { action colonColon := 0; }                          // C++
  -> "~" ClassName          { action colonColon := 0; }                          // C++
  -> q:Qualifier rhs:PQVarName  {                                                // C++
    // this PQVarName is preceeded by :: if the Qualifier is                     // C++
    action colonColon := q.colonColon;                                           // C++
                                                                                 // C++
    // can't put any more qualifiers on to left of ::                            // C++
    condition rhs.colonColon == 0;                                               // C++
  }                                                                              // C++
  // C++-end
}

// C++-begin
nonterm Qualifier {
  attr colonColon;     // true for leading "::"

  -> "::"              { action colonColon := 1; }                               // C++
  -> ClassName "::"    { action colonColon := 0; }                               // C++
}
// C++-end


nonterm PostfixExpression {
  -> PrimaryExpression                           ;
  -> PostfixExpression "[" Expression "]"        ;   // array
  -> PostfixExpression "(" ExpressionListOpt ")" ;   // fn call
  -> PostfixExpression "." PQVarName             ;   // field access
  -> PostfixExpression "->" PQVarName            ;   // deref + field access
  -> PostfixExpression "++"                      ;
  -> PostfixExpression "--"                      ;

  // C++-begin
  // pulled these two because other rules supercede them
  //-> PostfixExpression "." PseudoDestructorName           ; // explicit dtor call  // C++
  //-> PostfixExpression "->" PseudoDestructorName          ;                   // C++
  -> "dynamic_cast"     "<" TypeId ">" "(" Expression ")" ;   // casts          // C++
  -> "static_cast"      "<" TypeId ">" "(" Expression ")" ;                     // C++
  -> "reinterpret_cast" "<" TypeId ">" "(" Expression ")" ;                     // C++
  -> "const_cast"       "<" TypeId ">" "(" Expression ")" ;                     // C++
  -> "typeid" "(" Expression ")"                          ;   // RTTI           // C++
  -> "typeid" "(" TypeId ")"                              ;                     // C++
  // C++-end
}

nonterm ExpressionList -> AssignmentExpression |
                          ExpressionList "," AssignmentExpression ;
nonterm ExpressionListOpt -> empty | ExpressionList ;
 
// I am pulling these out since PQVarName can be ~class
//PseudoDestructorName -> "~" ClassName                                                     // C++
//PseudoDestructorName -> Qualifier PseudoDestructorName                                    // C++

nonterm UnaryExpression {
  -> PostfixExpression             ;
  -> "++" CastExpression           ;
  -> "--" CastExpression           ;
  -> UnaryOperator CastExpression  ;
  -> "sizeof" UnaryExpression      ;       // size of expression
  -> "sizeof" "(" TypeId ")"       ;       // size of type
  -> NewExpression                 ;                                         // C++
  -> DeleteExpression              ;                                         // C++
}

nonterm UnaryOperator -> "*" | "&" | "+" | "-" | "!" | "~" ;

// for now, no new-placement or "::" in front
// I've changed the syntax slightly to correct what I think is a mistake
// (my syntax allows array of ptr to fn, whereas std syntax doesn't -- TOVERIFY)
nonterm NewExpression {
  -> "new" TypeSpecifier NewDeclaratorOpt NewInitializerOpt ;                  // C++
  -> "new" "(" TypeId ")" NewDeclaratorOpt NewInitializerOpt ;                 // C++
}

// NewDeclaratorOpt is, as a regular expression:
//   (PtrOperator)*  ("[" Expression "]")?  ("[" ConstExpression "]")*
nonterm NewDeclaratorOpt -> empty |                                                       // C++
                            PtrOperator NewDeclaratorOpt |                                // C++
                            DirectNewDeclarator ;        // commit to at least one "[" ... "]"    // C++
nonterm DirectNewDeclarator -> "[" Expression "]" |                                       // C++
                               DirectNewDeclarator "[" ConstantExpression "]" ;           // C++

nonterm NewInitializerOpt -> empty | "(" ExpressionListOpt ")" ;                          // C++

// omitting possibility of initial "::"
nonterm DeleteExpression -> "delete" CastExpression          |                            // C++
                            "delete" "[" "]" CastExpression  ;                            // C++

nonterm CastExpression -> UnaryExpression | "(" TypeId ")" CastExpression ;

// ++++ binary operator expression ++++
// primary expressions
nonterm BinaryExpression {
  attr prec;                  // precedence of binding (topmost) operator in expression

  -> CastExpression {
    action  prec := 100;      // higher precedence than anything else
  }

  -> left:BinaryExpression op:BinaryOperator right:BinaryExpression {
    action  prec := op.prec;

    condition  this.prec <= left.prec;             // precedence
    condition  this.prec <= right.prec;            // more precedence
    condition  op.leftAssoc == 1 ?
                 this.prec < right.prec :          // left associative
                 this.prec < left.prec;            // right associative
  }
}

// an operator in a binary expression
nonterm BinaryOperator {
  attr prec;             // precedence of operator; higher value binds more tightly
  attr leftAssoc;        // 1 means left-associative, 0 means right-associative

  // all have left precedence by default; can override individually
  action  leftAssoc := 1;

  // highest precedence
  formGroup { action prec:=60;   -> "*" | "/" | "%"           ;   }
  formGroup { action prec:=56;   -> "+" | "-"                 ;   }
  formGroup { action prec:=52;   -> "<<"| ">>"                ;   }
  formGroup { action prec:=48;   -> "<" | ">" | "<="| ">="    ;   }
  formGroup { action prec:=44;   -> "=="| "!="                ;   }
  formGroup { action prec:=40;   -> "&"                       ;   }
  formGroup { action prec:=36;   -> "^"                       ;   }
  formGroup { action prec:=32;   -> "|"                       ;   }
  formGroup { action prec:=28;   -> "&&"                      ;   }
  formGroup { action prec:=24;   -> "||"                      ;   }
  // lowest precedence
}
// ---- end of binary operator expression ----


nonterm ConditionalExpression {
  -> BinaryExpression ;
  -> BinaryExpression "?" Expression ":" AssignmentExpression ;
}

// why is conditional not allowed on left side of = ?  can I confirm
// that in another language spec?  clearly both alternatives would have
// to be like-typed lvalues, but...
nonterm AssignmentExpression {
  -> ConditionalExpression ;
  -> BinaryExpression AssignmentOperator AssignmentExpression ;
  -> ThrowExpression ;                                                  // C++
}

nonterm AssignmentOperator -> "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>=" |
                              "<<=" | "&=" | "^=" | "|=" ;

// this is the same definition as ExpressionList, and perhaps it
// makes sense to collapse them?  the meaning of ',' is quite
// different in the two cases.. does that matter?
nonterm Expression -> AssignmentExpression | Expression "," AssignmentExpression ;
nonterm ExpressionOpt -> empty | Expression ;

// this is an expression with the additional requirement that
// it be entirely evaluable at compile time
// (which is essentially a type property)
nonterm ConstantExpression -> ConditionalExpression ;

// ------ A.5 Statements ------
// labeled-statement
nonterm Statement {
  -> LabelName ":" Statement ;
  -> "case" ConstantExpression ":" Statement ;
  -> "default" ":" Statement ;

  // expression-statement
  -> ExpressionStatement ;

  // compound-statement
  -> CompoundStatement ;

  // selection-statement
  -> "if" "(" Condition ")" Statement ;
  -> "if" "(" Condition ")" Statement "else" Statement ;     // preferred earlier when ambiguous
  -> "switch" "(" Condition ")" Statement ;

  // iteration-statement
  -> "while" "(" Condition ")" Statement ;
  -> "do" Statement "while" "(" Expression ")" ";" ;

  // this is a special-purpose rule intended for use with (unexpanded)
  // macros that, internally, contain a for loop; it is *not* part of
  // the C or C++ languages!
  -> L2_NAME "(" ExpressionList ")" CompoundStatement ;

  // I might like to rework this so both semicolons appear here instead
  // of buried in ForInitStatement.  this is also a good rule to use
  // inline alternatives
  -> "for" "(" ForInitStatement ConditionOpt ";" ExpressionOpt ")" Statement ;

  // jump-statement
  -> "break" ";" ;
  -> "continue" ";" ;
  -> "return" Expression ";" ;
  -> "return" ";" ;
  -> "goto" LabelName ";" ;

  // declaration-statement
  -> BlockDeclaration ;

  // try-block
  -> TryBlock ;                                                                    // C++
}

nonterm ExpressionStatement -> Expression ";" | ";" ;

nonterm CompoundStatement -> "{" StatementSeqOpt "}" ;
nonterm StatementSeqOpt -> empty | StatementSeqOpt Statement ;

nonterm Condition -> Expression | TypeSpecifierSeq Declarator "=" AssignmentExpression ;
nonterm ConditionOpt -> empty | Condition ;

nonterm ForInitStatement -> ExpressionStatement | SimpleDeclaration ;




// ----- A.6 Declarations ------
nonterm DeclarationSeqOpt -> empty | DeclarationSeqOpt Declaration ;

nonterm Declaration {
  -> BlockDeclaration ;
  -> FunctionDefinition ;
  //-> TemplateDeclaration ;                                                       // C++
  -> LinkageSpecification ;
}

// C++ has other alternatives..
nonterm BlockDeclaration -> SimpleDeclaration ;

// is the DeclSpecifierSeq optional for implicit-int??
//   no, it's for constructors, destructors, and conversion operators,
//   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
// ok, why is the InitDeclaratorList optional?
//   for declaring classes and enums
nonterm SimpleDeclaration -> DeclSpecifier InitDeclaratorListOpt ";" ;
         // e.g.:            int           x                     ;

// old:
//DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
//CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
// now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
// the TypeId in a cast expression to contain a "const"

nonterm DeclSpecifier ->
  "inline" DeclModifierOpt TypeSpecifier |                                  // C++
   DeclModifierOpt TypeSpecifier ;

// my analysis (informal and ad-hoc) indicates that none of these can
// be used together; "inline" is pulled out because it can be used with
// "virtual", "static", "friend", and possibly "extern"
nonterm DeclModifierOpt -> empty |
  "virtual" | "friend" | "mutable" |                                      // C++
  "typedef" | "auto" | "register" | "static" | "extern";

nonterm TypeSpecifier {
  -> SimpleTypeSpecifier       ;  // int
  -> SimpleCVTypeSpecifier     ;  // unsigned const char  (not good style, IMO)
  -> ClassSpecifier            ;  // class { ... }
  -> EnumSpecifier             ;  // enum { ... }
  -> ElaboratedTypeSpecifier   ;  // class foo  or  enum bar
  -> CVQualifier TypeSpecifier ;  // const int
  -> TypeSpecifier CVQualifier ;  // int const
}

nonterm ElaboratedTypeSpecifier -> ClassKeyword L2_NAME | 
                                   "enum" L2_NAME ;

// this list comes from Table 7 (p.109) of the C++ standard
// NOTE: this deviates from the language spec, which allows other
// decl-specifiers to mix with the tokens here; I do not
nonterm SimpleTypeSpecifier {
  -> PQTypeName               ;   // <-- this is part of why parsing C is hard
  -> "char"                   ;   // char
  -> "unsigned" "char"        ;   // unsigned char
  -> "signed" "char"          ;   // signed char
  -> "bool"                   ;   // bool
  -> "unsigned"               ;   // unsigned int
  -> "unsigned" "int"         ;   // unsigned int
  -> "signed"                 ;   // int
  -> "signed" "int"           ;   // int
  -> "int"                    ;   // int
  -> "unsigned" "short" "int" ;   // unsigned short int
  -> "unsigned" "short"       ;   // unsigned short int
  -> "unsigned" "long" "int"  ;   // unsigned long int
  -> "unsigned" "long"        ;   // unsigned long int
  -> "signed" "long" "int"    ;   // long int
  -> "signed" "long"          ;   // long int
  -> "long" "int"             ;   // long int
  -> "long"                   ;   // long int
  -> "signed" "short" "int"   ;   // short int
  -> "signed" "short"         ;   // short int
  -> "short" "int"            ;   // short int
  -> "short"                  ;   // short int
  -> "wchar_t"                ;   // wchar_t
  -> "float"                  ;   // float
  -> "double"                 ;   // double
  -> "long" "double"          ;   // long double
  -> "void"                   ;   // void
}

// I had been separating these into typedef/enum/class names, but
// the parser can never distinguish, so the grammar shouldn't suggest
// that it can
nonterm PQTypeName {
  -> L2_NAME ;
  -> TemplateId ;                           // C++
  -> Qualifier PQTypeName ;                 // C++
}

// the C++ standard allows "const" and "volatile" to be arbitrarily
// interleaved with the words of a simple-type-specifier.. so I've
// created this set of alternative type specifiers which have at
// least one CV qualifier buried in them
//
// technically, I'm still missing things like
//   unsigned const short volatile int
// but yikes, I pity the fool with such code!
//
// I really should just fold these into the above, but my dislike for
// the interleaving thing makes me try to keep the above decls more
// or less "pure".. but I'll merge them at some point
nonterm SimpleCVTypeSpecifier {
  -> "unsigned" CVQualifierSeq "char"              ;   // unsigned char
  -> "signed" CVQualifierSeq "char"                ;   // signed char
  -> "unsigned" CVQualifierSeq "int"               ;   // unsigned int
  -> "signed" CVQualifierSeq "int"                 ;   // int
  -> "unsigned" CVQualifierSeq "short" "int"       ;   // unsigned short int
  -> "unsigned" "short" CVQualifierSeq "int"       ;   // unsigned short int
  -> "unsigned" CVQualifierSeq "short"             ;   // unsigned short int
  -> "unsigned" CVQualifierSeq "long" "int"        ;   // unsigned long int
  -> "unsigned" "long" CVQualifierSeq "int"        ;   // unsigned long int
  -> "unsigned" CVQualifierSeq "long"              ;   // unsigned long int
  -> "signed" CVQualifierSeq "long" "int"          ;   // long int
  -> "signed" "long" CVQualifierSeq "int"          ;   // long int
  -> "signed" CVQualifierSeq "long"                ;   // long int
  -> "long" CVQualifierSeq "int"                   ;   // long int
  -> "signed" CVQualifierSeq "short" "int"         ;   // short int
  -> "signed" "short" CVQualifierSeq "int"         ;   // short int
  -> "signed" CVQualifierSeq "short"               ;   // short int
  -> "short" CVQualifierSeq "int"                  ;   // short int
  -> "long" CVQualifierSeq "double"                ;   // long double
}

nonterm EnumSpecifier -> "enum" "{" EnumeratorListOpt "}" |
                         "enum" EnumName "{" EnumeratorListOpt "}" ;

nonterm EnumeratorList -> EnumeratorDefinition |
                          EnumeratorList "," EnumeratorDefinition ;
nonterm EnumeratorListOpt -> empty | EnumeratorList ;

nonterm EnumeratorDefinition -> EnumValueName |
                                EnumValueName "=" ConstantExpression ;

nonterm AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";" ;

nonterm LinkageSpecification -> 
  "extern" L2_STRING_LITERAL "{" DeclarationSeqOpt "}" |
  "extern" L2_STRING_LITERAL Declaration ;

// ------ A.7 Declarators ------
// -- declarator --
// declarator: the "x" in a declaration like "int x"

nonterm InitDeclaratorList -> InitDeclarator |
                              InitDeclaratorList "," InitDeclarator ;
nonterm InitDeclaratorListOpt -> empty | InitDeclaratorList ;

nonterm InitDeclarator -> Declarator |                   // (int)  x
                          Declarator Initializer ;       // (int)  x = 5

nonterm Initializer -> "=" InitializerClause |
                       "(" ExpressionList ")" ;          // ctor args                               // C++

nonterm InitializerClause {
  -> AssignmentExpression        ;   // scalar
  -> "{" InitializerList "}"     ;   // array initializer
  -> "{" InitializerList "," "}" ;   // useful syntactic quirk
  -> "{" "}"                     ;   // ?  does this mean the array is zeroed?
}

nonterm InitializerList -> InitializerClause |
                           InitializerList "," InitializerClause ;


nonterm Declarator {
  // attribute 'isFunction' of Declarator and DirectDeclarator:
  // if the type of the thing declared is a function (not a ptr to
  // a function, or an array of fns...), this is 1, otherwise 0;
  // it is used to do some disambiguation later on, where functions
  // are allowed to not have return types (DeclSpecifiers), but
  // other declarations must have types
  attr isFunction;

  // (PtrOperator)* DirectDeclarator
  -> PtrOperator Declarator            { action isFunction := 0; }
  -> d:DirectDeclarator                { action isFunction := d.isFunction; }
}

nonterm DirectDeclarator {
  attr isFunction;    // see above

  -> n:PQVarName {
    action isFunction := 0;

    // declarator names can't be qualified with "::" (this resolves an
    // ambiguity with constructs like "Foo::Foo() {}")
    condition n.colonColon == 0;
  }
                                                                            
  // function type declarator; the return type comes from the type
  // specifier that preceeds this
  -> DirectDeclarator "(" ParameterDeclarationClause ")" CVQualifierSeqOpt
  // ^^ name of fn ^^     ^^^^^^^ arguments ^^^^^^^^     ^^^^ const? ^^^^^
    { action isFunction := 1; }

  // array of specified size
  -> DirectDeclarator "[" ConstantExpression "]"
    { action isFunction := 0; }

  // array of unspecified size
  -> DirectDeclarator "[" "]"
    { action isFunction := 0; }

  // precedence grouping
  -> "(" d:Declarator ")"
    { action isFunction := d.isFunction; }
}

nonterm PtrOperator {
  // c++ std mentions something with "::" as well, I don't know what that means
  -> "*" CVQualifierSeqOpt ;
  -> "&" ;                                                   // C++
}

nonterm CVQualifierSeqOpt -> empty | CVQualifierSeq ;
nonterm CVQualifierSeq -> CVQualifier | CVQualifier CVQualifierSeq ;
nonterm CVQualifier -> "const" | "volatile" ;

// -- type-id --
// a type-id is like a declaration of one thing, but without the variable name;
// it is, for example, what appears inside the parens of a typecast
// old -- why seq??  TypeId -> TypeSpecifierSeq AbstractDeclarator
nonterm TypeId -> TypeSpecifier AbstractDeclarator ;

nonterm TypeSpecifierSeq -> TypeSpecifier | TypeSpecifier TypeSpecifierSeq ;

// this introduces extra ambiguities (like "int (x)" -- integer or fn with
// name omitted?), so I'm going to back to a duplicated structure
nonterm AbstractDeclarator -> PtrOperator AbstractDeclarator | 
                              DirectAbstractDeclarator ;

nonterm DirectAbstractDeclarator {
  // this is where abstract declarators differ from regular declarators;
  // for a declarator, this rule is "-> PQVarName"
  -> empty ;                                      

  -> DirectAbstractDeclarator "(" ParameterDeclarationClause ")" CVQualifierSeqOpt ; // fn
  -> DirectAbstractDeclarator "[" ConstantExpression "]" ;     // array of specified size
  -> DirectAbstractDeclarator "[" "]" ;                        // array of unspecified size
  -> "(" AbstractDeclarator ")" ;                              // precedence grouping
}


// -- parameters in declarations --
nonterm ParameterDeclarationClause {
  -> ParameterDeclarationList ;           // some args
  -> empty ;                              // no args
  -> ParameterDeclarationList "..." ;     // args plus optionally more
  -> ParameterDeclarationList "," "..." ; // same; alternative syntax
  -> "..." ;                              // all args are optional
}

nonterm ParameterDeclarationList -> ParameterDeclaration |
                                    ParameterDeclarationList "," ParameterDeclaration ;

nonterm ParameterDeclaration {
  -> DeclSpecifier Declarator ;
  -> DeclSpecifier Declarator "=" AssignmentExpression ;
  -> DeclSpecifier AbstractDeclarator ;
  -> DeclSpecifier AbstractDeclarator "=" AssignmentExpression ;
}

// -- function definition --
nonterm FunctionDefinition {
  // I am wary of letting the declspecifier be optional, because it seems
  // to me that may introduce more ambiguities.. but it truly is missing
  // in ctors and dtors; so my idea now is to only permit it when the
  // declarator declares a function type (can't be more specific since there
  // aren't good syntactic clues for ctors)
                              
  // all declarators must be of function type
  condition d.isFunction == 1;

  // return type      name/params   body
  -> DeclSpecifier    d:Declarator  FunctionBody ;

  -> ExplicitOpt      d:Declarator  FunctionBody ;        // {c,d}tor  // C++

  -> ExplicitOpt      d:Declarator  ":" MemInitializerList FunctionBody ; // ctor      // C++
}

nonterm FunctionBody -> CompoundStatement ;

nonterm ExplicitOpt -> "explicit" | empty ;                                            // C++


// ------ A.8 Classes ------
// I'm going to use the "class" terminology throughout, even though
// C only has "struct" and "union"
nonterm ClassSpecifier -> ClassHead "{" MemberDeclarationSeqOpt "}" ;

nonterm ClassHead -> ClassKeyword ClassNameOpt BaseClauseOpt ;
nonterm ClassNameOpt -> empty | ClassName ;
nonterm ClassKeyword -> "class" | "struct" | "union" ;

nonterm MemberDeclarationSeqOpt {
  -> empty ;
  -> MemberDeclaration MemberDeclarationSeqOpt ;
  -> AccessSpecifier ":" MemberDeclarationSeqOpt ;                   // C++
}

nonterm AccessSpecifier -> "public" | "private" | "protected" ;      // C++

nonterm MemberDeclaration {
  -> DeclSpecifier MemberDeclaratorList ";" ;    // member fn or data       // C++
  -> FunctionDefinition ";" ;                    // inline fn               // C++
  -> FunctionDefinition ;                        // syntactic tweak         // C++
  -> ExplicitOpt VirtualOpt d:Declarator ";"     // ctor, dtor, conv op     // C++
       { condition d.isFunction == 1; }                                     // C++
  // note above that "explicit" and "virtual" can't be mixed because the former
  // is for ctors only and the latter can't be used with ctors (so a later stage
  // of processing will filter it out)
}

nonterm MemberDeclaratorList -> 
  MemberDeclarator | MemberDeclaratorList "," MemberDeclarator ;

nonterm MemberDeclarator -> 
  Declarator | Declarator "=" ConstantExpression ;   // pure; and member inits??       // C++


// ------ A.9 Derived classes ------
nonterm BaseClauseOpt -> empty |
                         ":" BaseSpecifierList ;                                          // C++

nonterm BaseSpecifierList -> BaseSpecifier | BaseSpecifierList "," BaseSpecifier ;        // C++

nonterm BaseSpecifier -> VirtualOpt AccessSpecifierOpt PQClassName ;                      // C++
nonterm VirtualOpt -> empty | "virtual" ;                                                 // C++
nonterm AccessSpecifierOpt -> empty | AccessSpecifier ;                                   // C++

nonterm PQClassName -> ClassName | Qualifier PQClassName ;                                // C++


// ------ A.10 Special member functions ------
nonterm ConversionFunctionId -> "operator" ConversionTypeId ;                             // C++
nonterm ConversionTypeId -> TypeSpecifier ConversionDeclaratorOpt ;                       // C++
nonterm ConversionDeclaratorOpt -> empty | PtrOperator ConversionDeclaratorOpt ;          // C++

nonterm MemInitializerList                                                                // C++
  -> MemInitializer | MemInitializer "," MemInitializerList ;                             // C++

// std has a separate rule for base class ctor call, but that's not
// a useful parsing distinction, so it just creates gratuitous
// ambiguities, and I've eliminated it
nonterm MemInitializer -> L2_NAME "(" ExpressionListOpt ")" ;     // member init          // C++


// ------ A.11 Overloading ------
nonterm OperatorFunctionId -> "operator" Operator ;                                       // C++

// the cpp standard is unclear on whether "()" is to be considered a token,
// or whether it is permissible to see it as "(" ")".. I'm using the latter
nonterm Operator {
  -> "new" | "delete" | "new" "[" "]" | "delete" "[" "]" ;                          // C++
  -> BinaryOperator      /* filter out ".*" later */     ;                          // C++
  -> AssignmentOperator                                  ;                          // C++
  -> "!" | "~" | "," | "++" | "--" | "->"                ;                          // C++
  -> "(" ")" | "[" "]"                                   ;                          // C++
}


// ------ A.12 Templates ------
//TemplateParameterList -> TemplateParameter                                               // C++
//TemplateParameterList -> TemplateParameterList "," TemplateParameter                     // C++

//TemplateParameter -> TypeParameter | ParameterDeclaration                                // C++


nonterm TemplateId -> TemplateName "<" TemplateArgumentList ">" |                         // C++
                      TemplateName "<" ">" ;                                              // C++

nonterm TemplateArgumentList -> TemplateArgument |                                        // C++
                                TemplateArgumentList "," TemplateArgument ;               // C++

nonterm TemplateArgument -> Literal | TypeId ;                                            // C++
// where I have Literal the std has AssignmentExpression...
// std also mentions IdExpression here, which is my PQVarName.....


// ------ A.13 Exception handling ------
nonterm TryBlock -> "try" CompoundStatement HandlerSeq ;                                  // C++

nonterm HandlerSeq -> Handler | Handler HandlerSeq ;                                      // C++

nonterm Handler -> "catch" "(" ExceptionDeclaration ")" CompoundStatement ;               // C++

nonterm ExceptionDeclaration {
  -> TypeSpecifier Declarator ;          // named exception object       // C++
  -> TypeSpecifier AbstractDeclarator ;  // unnamed exception object     // C++
  -> "..."                            ;  // anything                     // C++
}

nonterm ThrowExpression -> "throw" AssignmentExpression |                                 // C++
                           "throw" ;                                                      // C++


// ---------------- token sequence ambiguity resolution ---------------------
// this section contains token sequences that are known to produce
// ambiguities, but where the correct interpretation is almost always
// something in particular; this section is all heuristic, and therefore
// should not be considered a definitive part of the language def (and
// it can be disabled by a flag to the parser)

// this is one of the classic C ambiguities; but since no one would
// declare a variable with syntax like "int (x);", it's pretty safe
// to assume this is a fn call
//%tokSeqAmb  ExpressionStatement  ->  L2_NAME "(" L2_NAME ")" ";"

// update: after implementing the mechanism to do this in general, I found
// it really didn't apply (at least as limited as it currently is) beyond
// the single special case above
