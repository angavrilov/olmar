# cc.gr
# my attempt to implement a grammar for C++

# I'm actually trying to use this single file for both C and C++;
# the C++ grammar should parse C ok, but also by filtering out all
# the lines with "C++" on them, you should get just the C rules


# ------ tokens -------
# this list generated automatically by the lexer
#      canonical name      code   alias
#      ------------------  ----   ----------
%token L2_EOF                 0
%token L2_NAME                1
%token L2_INT_LITERAL         2
%token L2_FLOAT_LITERAL       3
%token L2_STRING_LITERAL      4
%token L2_CHAR_LITERAL        5
%token L2_ASM                 6   "asm"
%token L2_AUTO                7   "auto"
%token L2_BREAK               8   "break"
%token L2_BOOL                9   "bool"
%token L2_CASE               10   "case"
%token L2_CATCH              11   "catch"
%token L2_CDECL              12   "cdecl"
%token L2_CHAR               13   "char"
%token L2_CLASS              14   "class"
%token L2_CONST              15   "const"
%token L2_CONST_CAST         16   "const_cast"
%token L2_CONTINUE           17   "continue"
%token L2_DEFAULT            18   "default"
%token L2_DELETE             19   "delete"
%token L2_DO                 20   "do"
%token L2_DOUBLE             21   "double"
%token L2_DYNAMIC_CAST       22   "dynamic_cast"
%token L2_ELSE               23   "else"
%token L2_ENUM               24   "enum"
%token L2_EXPLICIT           25   "explicit"
%token L2_EXTERN             26   "extern"
%token L2_FLOAT              27   "float"
%token L2_FOR                28   "for"
%token L2_FRIEND             29   "friend"
%token L2_GOTO               30   "goto"
%token L2_IF                 31   "if"
%token L2_INLINE             32   "inline"
%token L2_INT                33   "int"
%token L2_LONG               34   "long"
%token L2_MUTABLE            35   "mutable"
%token L2_NEW                36   "new"
%token L2_OPERATOR           37   "operator"
%token L2_PASCAL             38   "pascal"
%token L2_PRIVATE            39   "private"
%token L2_PROTECTED          40   "protected"
%token L2_PUBLIC             41   "public"
%token L2_REGISTER           42   "register"
%token L2_REINTERPRET_CAST   43   "reinterpret_cast"
%token L2_RETURN             44   "return"
%token L2_SHORT              45   "short"
%token L2_SIGNED             46   "signed"
%token L2_SIZEOF             47   "sizeof"
%token L2_STATIC             48   "static"
%token L2_STATIC_CAST        49   "static_cast"
%token L2_STRUCT             50   "struct"
%token L2_SWITCH             51   "switch"
%token L2_TEMPLATE           52   "template"
%token L2_THIS               53   "this"
%token L2_THROW              54   "throw"
%token L2_TRY                55   "try"
%token L2_TYPEDEF            56   "typedef"
%token L2_TYPEID             57   "typeid"
%token L2_UNION              58   "union"
%token L2_UNSIGNED           59   "unsigned"
%token L2_VIRTUAL            60   "virtual"
%token L2_VOID               61   "void"
%token L2_VOLATILE           62   "volatile"
%token L2_WCHAR_T            63   "wchar_t"
%token L2_WHILE              64   "while"
%token L2_LPAREN             65   "("
%token L2_RPAREN             66   ")"
%token L2_LBRACKET           67   "["
%token L2_RBRACKET           68   "]"
%token L2_ARROW              69   "->"
%token L2_COLONCOLON         70   "::"
%token L2_DOT                71   "."
%token L2_BANG               72   "!"
%token L2_TILDE              73   "~"
%token L2_PLUS               74   "+"
%token L2_MINUS              75   "-"
%token L2_PLUSPLUS           76   "++"
%token L2_MINUSMINUS         77   "--"
%token L2_AND                78   "&"
%token L2_STAR               79   "*"
%token L2_DOTSTAR            80   ".*"
%token L2_ARROWSTAR          81   "->*"
%token L2_SLASH              82   "/"
%token L2_PERCENT            83   "%"
%token L2_LEFTSHIFT          84   "<<"
%token L2_RIGHTSHIFT         85   ">>"
%token L2_LESSTHAN           86   "<"
%token L2_LESSEQ             87   "<="
%token L2_GREATERTHAN        88   ">"
%token L2_GREATEREQ          89   ">="
%token L2_EQUALEQUAL         90   "=="
%token L2_NOTEQUAL           91   "!="
%token L2_XOR                92   "^"
%token L2_OR                 93   "|"
%token L2_ANDAND             94   "&&"
%token L2_OROR               95   "||"
%token L2_QUESTION           96   "?"
%token L2_COLON              97   ":"
%token L2_EQUAL              98   "="
%token L2_STAREQUAL          99   "*="
%token L2_SLASHEQUAL        100   "/="
%token L2_PERCENTEQUAL      101   "%="
%token L2_PLUSEQUAL         102   "+="
%token L2_MINUSEQUAL        103   "-="
%token L2_ANDEQUAL          104   "&="
%token L2_XOREQUAL          105   "^="
%token L2_OREQUAL           106   "|="
%token L2_LEFTSHIFTEQUAL    107   "<<="
%token L2_RIGHTSHIFTEQUAL   108   ">>="
%token L2_COMMA             109   ","
%token L2_ELLIPSIS          110   "..."
%token L2_SEMICOLON         111   ";"
%token L2_LBRACE            112   "{"
%token L2_RBRACE            113   "}"
# ------ end of tokens ------



# start symbol
StartSymbol -> TranslationUnit L2_EOF


# ------------- identifier ambiguity -------------------
# identifiers can play a number of roles, and this is the
# source of problems parsing C and C++
# (here, "variable" means variable or function; it names
# an object that exists at runtime)
TypedefName -> L2_NAME
EnumName -> L2_NAME
EnumValueName -> L2_NAME      # called 'enumerator' in spec
ClassName -> L2_NAME
TemplateName -> L2_NAME                                                                   # C++
VariableName -> L2_NAME
LabelName -> L2_NAME


# ---------------- higher-level syntax -----------------
# ------ A.3 Basic Concepts ------
TranslationUnit -> empty | Declaration TranslationUnit

# ------ A.4 Expressions ------
PrimaryExpression -> Literal | "this" | "(" Expression ")" | PQVarName

Literal -> L2_INT_LITERAL | L2_FLOAT_LITERAL | L2_STRING_LITERAL | L2_CHAR_LITERAL


# 'colonColon' attribute of PQVarName and Qualifier: set to 1 when "::" is
# the leftmost token in the tree matched; this is important because
# declarators aren't allowed to have the bare "::" qualifier


# possibly-qualified name; essentially spec's id-expression
# missing: template-id because I don't know what that is
PQVarName -> VariableName
  %action { PQVarName.colonColon := 0 }                                                   
PQVarName -> OperatorFunctionId                                                           # C++
  %action { PQVarName.colonColon := 0 }                                                   # C++
PQVarName -> ConversionFunctionId                                                         # C++
  %action { PQVarName.colonColon := 0 }                                                   # C++
PQVarName -> "~" ClassName                                                                # C++
  %action { PQVarName.colonColon := 0 }                                                   # C++
PQVarName.lhs -> Qualifier PQVarName.rhs                                                  # C++
  %action { PQVarName.lhs.colonColon := Qualifier.colonColon }                            # C++
    # the PQVarName is preceeded by :: if the Qualifier is
  %condition { (== PQVarName.rhs.colonColon 0) }                                          # C++
    # can't put any more qualifiers on to left of ::

Qualifier -> "::"                                                                         # C++
  %action { Qualifier.colonColon := 1 }                                                   # C++
Qualifier -> ClassName "::"                                                               # C++
  %action { Qualifier.colonColon := 0 }                                                   # C++


PostfixExpression -> PrimaryExpression
PostfixExpression -> PostfixExpression "[" Expression "]"           # array
PostfixExpression -> PostfixExpression "(" ExpressionListOpt ")"    # fn call
PostfixExpression -> PostfixExpression "." PQVarName                # field access
PostfixExpression -> PostfixExpression "->" PQVarName               # deref + field access
PostfixExpression -> PostfixExpression "++"
PostfixExpression -> PostfixExpression "--"
#PostfixExpression -> PostfixExpression "." PseudoDestructorName            # explicit dtor call  C++
#PostfixExpression -> PostfixExpression "->" PseudoDestructorName                          # C++
PostfixExpression -> "dynamic_cast" "<" TypeId ">" "(" Expression ")"      # casts        # C++
PostfixExpression -> "static_cast" "<" TypeId ">" "(" Expression ")"                      # C++
PostfixExpression -> "reinterpret_cast" "<" TypeId ">" "(" Expression ")"                 # C++
PostfixExpression -> "const_cast" "<" TypeId ">" "(" Expression ")"                       # C++
PostfixExpression -> "typeid" "(" Expression ")"                           # RTTI         # C++
PostfixExpression -> "typeid" "(" TypeId ")"                                              # C++

ExpressionList -> AssignmentExpression | ExpressionList "," AssignmentExpression
ExpressionListOpt -> empty | ExpressionList
 
# I am pulling these out since PQVarName can be ~class
#PseudoDestructorName -> "~" ClassName                                                     # C++
#PseudoDestructorName -> Qualifier PseudoDestructorName                                    # C++

UnaryExpression -> PostfixExpression
UnaryExpression -> "++" CastExpression
UnaryExpression -> "--" CastExpression
UnaryExpression -> UnaryOperator CastExpression
UnaryExpression -> "sizeof" UnaryExpression             # size of expression
UnaryExpression -> "sizeof" "(" TypeId ")"              # size of type
UnaryExpression -> NewExpression                                                          # C++
UnaryExpression -> DeleteExpression                                                       # C++

UnaryOperator -> "*" | "&" | "+" | "-" | "!" | "~"

# for now, no new-placement or "::" in front
# I've changed the syntax slightly to correct what I think is a mistake
# (my syntax allows array of ptr to fn, whereas std syntax doesn't)
NewExpression -> "new" TypeSpecifier NewDeclaratorOpt NewInitializerOpt                   # C++
NewExpression -> "new" "(" TypeId ")" NewDeclaratorOpt NewInitializerOpt                  # C++

# NewDeclaratorOpt is, as a regular expression:
#   (PtrOperator)*  ("[" Expression "]")?  ("[" ConstExpression "]")*
NewDeclaratorOpt -> empty                                                                 # C++
NewDeclaratorOpt -> PtrOperator NewDeclaratorOpt                                          # C++
NewDeclaratorOpt -> DirectNewDeclarator           # commit to at least one "[" ... "]"    # C++
DirectNewDeclarator -> "[" Expression "]"                                                 # C++
DirectNewDeclarator -> DirectNewDeclarator "[" ConstantExpression "]"                     # C++

NewInitializerOpt -> empty                                                                # C++
NewInitializerOpt -> "(" ExpressionListOpt ")"                                            # C++

# omitting possibility of initial "::"
DeleteExpression -> "delete" CastExpression                                               # C++
DeleteExpression -> "delete" "[" "]" CastExpression                                       # C++

CastExpression -> UnaryExpression | "(" TypeId ")" CastExpression

# ++++ binary operator expression ++++
BinaryExpression -> CastExpression
  %action { BinaryExpression.prec := 100 }

BinaryExpression.result -> BinaryExpression.left BinaryOperator BinaryExpression.right
  %action { BinaryExpression.result.prec := BinaryOperator.prec }
  %condition { (<= BinaryExpression.result.prec BinaryExpression.left.prec) }         # precedence
  %condition { (<= BinaryExpression.result.prec BinaryExpression.right.prec) }        # more precedence
  %condition { (if (== BinaryOperator.leftAssoc 1) (< BinaryExpression.result.prec BinaryExpression.right.prec) (< BinaryExpression.result.prec BinaryExpression.left.prec)) }
    # associativity
  %condition { (|| (!= BinaryOperator.leftAssoc 2) (< BinaryExpression.result.prec BinaryExpression.right.prec)) }
    # for nonassoc (2), the first associativity condition will make sure that
    # result.prec < left.prec, so the 2nd associativity condition ensures
    # result.prec < right.prec

BinaryOperator -> ".*" | "->*"                                                            # C++
  %action { BinaryOperator.prec := 64 }                                                   # C++
  %action { BinaryOperator.leftAssoc := 1 }                                               # C++

BinaryOperator -> "*" | "/" | "%"
  %action { BinaryOperator.prec := 60 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "+" | "-"
  %action { BinaryOperator.prec := 56 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "<<" | ">>"
  %action { BinaryOperator.prec := 52 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "<" | ">" | "<=" | ">="
  %action { BinaryOperator.prec := 48 }
  %action { BinaryOperator.leftAssoc := 2 }      # 2 means nonassociative

BinaryOperator -> "==" | "!="
  %action { BinaryOperator.prec := 44 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "&"
  %action { BinaryOperator.prec := 40 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "^"
  %action { BinaryOperator.prec := 36 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "|"
  %action { BinaryOperator.prec := 32 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "&&"
  %action { BinaryOperator.prec := 28 }
  %action { BinaryOperator.leftAssoc := 1 }

BinaryOperator -> "||"
  %action { BinaryOperator.prec := 24 }
  %action { BinaryOperator.leftAssoc := 1 }

# ---- end of binary operator expression ----


ConditionalExpression -> BinaryExpression
ConditionalExpression -> BinaryExpression "?" Expression ":" AssignmentExpression

# why is conditional not allowed on left side of = ?  can I confirm
# that in another language spec?  clearly both alternatives would have
# to be like-typed lvalues, but...
AssignmentExpression -> ConditionalExpression
AssignmentExpression -> BinaryExpression AssignmentOperator AssignmentExpression
AssignmentExpression -> ThrowExpression                                                   # C++

AssignmentOperator -> "=" | "*=" | "/=" | "%=" | "+=" | "-=" | ">>="
AssignmentOperator -> "<<=" | "&=" | "^=" | "|="

# this is the same definition as ExpressionList, and perhaps it
# makes sense to collapse them?  the meaning of ',' is quite
# different in the two cases.. does that matter?
Expression -> AssignmentExpression | Expression "," AssignmentExpression
ExpressionOpt -> empty | Expression

# this is an expression with the additional requirement that
# it be entirely evaluable at compile time
# (which is essentially a type property)
ConstantExpression -> ConditionalExpression

# ------ A.5 Statements ------
# labeled-statement
Statement -> LabelName ":" Statement
Statement -> "case" ConstantExpression ":" Statement
Statement -> "default" ":" Statement

# expression-statement
Statement -> ExpressionStatement
ExpressionStatement -> Expression ";" | ";"

# compound-statement
Statement -> CompoundStatement
CompoundStatement -> "{" StatementSeqOpt "}"
StatementSeqOpt -> empty | StatementSeqOpt Statement

# selection-statement
Statement -> "if" "(" Condition ")" Statement
Statement -> "if" "(" Condition ")" Statement "else" Statement      # preferred earlier when ambiguous
Statement -> "switch" "(" Condition ")" Statement

Condition -> Expression
Condition -> TypeSpecifierSeq Declarator "=" AssignmentExpression
ConditionOpt -> empty | Condition

# iteration-statement
Statement -> "while" "(" Condition ")" Statement
Statement -> "do" Statement "while" "(" Expression ")" ";"

# this is a special-purpose rule intended for use with (unexpanded)
# macros that, internally, contain a for loop; it is *not* part of
# the C or C++ languages!
Statement -> L2_NAME "(" ExpressionList ")" CompoundStatement

# I might like to rework this so both semicolons appear here instead
# of buried in ForInitStatement.  this is also a good rule to use
# inline alternatives
Statement -> "for" "(" ForInitStatement ConditionOpt ";" ExpressionOpt ")" Statement
ForInitStatement -> ExpressionStatement | SimpleDeclaration

# jump-statement
Statement -> "break" ";"
Statement -> "continue" ";"
Statement -> "return" Expression ";"
Statement -> "return" ";"
Statement -> "goto" LabelName ";"

# declaration-statement
Statement -> BlockDeclaration

# try-block
Statement -> TryBlock                                                                     # C++

# ----- A.6 Declarations ------
DeclarationSeqOpt -> empty | DeclarationSeqOpt Declaration

Declaration -> BlockDeclaration
Declaration -> FunctionDefinition
#Declaration -> TemplateDeclaration                                                        # C++
Declaration -> LinkageSpecification

# C++ has other alternatives..
BlockDeclaration -> SimpleDeclaration

# is the DeclSpecifierSeq optional for implicit-int??
#   no, it's for constructors, destructors, and conversion operators,
#   all of which are C++ only, so the DeclSpecifierSeq is now mandatory
# ok, why is the InitDeclaratorList optional?
#   for declaring classes and enums
SimpleDeclaration -> DeclSpecifier InitDeclaratorListOpt ";"
  # e.g.:            int           x                     ;

# old:
#DeclSpecifier -> StorageClassOpt CVQualifiersOpt TypeSpecifier
#CVQualifiersOpt -> "const" CVQualifiersOpt | "volatile" CVQualifiersOpt | empty
# now I'm folding CVQualifier into TypeSpecifier; in particular, this allows
# the TypeId in a cast expression to contain a "const"

DeclSpecifier -> "inline" DeclModifierOpt TypeSpecifier                                   # C++
DeclSpecifier -> DeclModifierOpt TypeSpecifier

# my analysis (informal and ad-hoc) indicates that none of these can
# be used together; "inline" is pulled out because it can be used with
# "virtual", "static", "friend", and possibly "extern"
DeclModifierOpt -> "typedef" | "auto" | "register" | "static" | "extern" | empty
DeclModifierOpt -> "virtual" | "friend" | "mutable"                                       # C++

TypeSpecifier -> SimpleTypeSpecifier         # int
TypeSpecifier -> SimpleCVTypeSpecifier       # unsigned const char  (not good style, IMO)
TypeSpecifier -> ClassSpecifier              # class { ... }
TypeSpecifier -> EnumSpecifier               # enum { ... }
TypeSpecifier -> ElaboratedTypeSpecifier     # class foo  or  enum bar
TypeSpecifier -> CVQualifier TypeSpecifier   # const int
TypeSpecifier -> TypeSpecifier CVQualifier   # int const

ElaboratedTypeSpecifier -> ClassKeyword L2_NAME
ElaboratedTypeSpecifier -> "enum" L2_NAME

# this list comes from Table 7 (p.109) of the C++ standard
# NOTE: this deviates from the language spec, which allows other
# decl-specifiers to mix with the tokens here; I do not
SimpleTypeSpecifier -> PQTypeName                   # <-- this is part of why parsing C is hard
SimpleTypeSpecifier -> "char"                       # char
SimpleTypeSpecifier -> "unsigned" "char"            # unsigned char
SimpleTypeSpecifier -> "signed" "char"              # signed char
SimpleTypeSpecifier -> "bool"                       # bool
SimpleTypeSpecifier -> "unsigned"                   # unsigned int
SimpleTypeSpecifier -> "unsigned" "int"             # unsigned int
SimpleTypeSpecifier -> "signed"                     # int
SimpleTypeSpecifier -> "signed" "int"               # int
SimpleTypeSpecifier -> "int"                        # int
SimpleTypeSpecifier -> "unsigned" "short" "int"     # unsigned short int
SimpleTypeSpecifier -> "unsigned" "short"           # unsigned short int
SimpleTypeSpecifier -> "unsigned" "long" "int"      # unsigned long int
SimpleTypeSpecifier -> "unsigned" "long"            # unsigned long int
SimpleTypeSpecifier -> "signed" "long" "int"        # long int
SimpleTypeSpecifier -> "signed" "long"              # long int
SimpleTypeSpecifier -> "long" "int"                 # long int
SimpleTypeSpecifier -> "long"                       # long int
SimpleTypeSpecifier -> "signed" "short" "int"       # short int
SimpleTypeSpecifier -> "signed" "short"             # short int
SimpleTypeSpecifier -> "short" "int"                # short int
SimpleTypeSpecifier -> "short"                      # short int
SimpleTypeSpecifier -> "wchar_t"                    # wchar_t
SimpleTypeSpecifier -> "float"                      # float
SimpleTypeSpecifier -> "double"                     # double
SimpleTypeSpecifier -> "long" "double"              # long double
SimpleTypeSpecifier -> "void"                       # void

# I had been separating these into typedef/enum/class names, but
# the parser can never distinguish, so the grammar shouldn't suggest
# that it can
PQTypeName -> L2_NAME
PQTypeName -> TemplateId                            # C++
PQTypeName -> Qualifier PQTypeName                  # C++

# the C++ standard allows "const" and "volatile" to be arbitrarily
# interleaved with the words of a simple-type-specifier.. so I've
# created this set of alternative type specifiers which have at
# least one CV qualifier buried in them
#
# technically, I'm still missing things like
#   unsigned const short volatile int
# but yikes I pity the fool with such code!
#
# I really should just fold these into the above, but my dislike for
# the interleaving thing makes me try to keep the above decls more
# or less "pure".. but I'll merge them at some point
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "char"                  # unsigned char
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "char"                    # signed char
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "int"                   # unsigned int
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "int"                     # int
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "short" "int"           # unsigned short int
SimpleCVTypeSpecifier -> "unsigned" "short" CVQualifierSeq "int"           # unsigned short int
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "short"                 # unsigned short int
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "long" "int"            # unsigned long int
SimpleCVTypeSpecifier -> "unsigned" "long" CVQualifierSeq "int"            # unsigned long int
SimpleCVTypeSpecifier -> "unsigned" CVQualifierSeq "long"                  # unsigned long int
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "long" "int"              # long int
SimpleCVTypeSpecifier -> "signed" "long" CVQualifierSeq "int"              # long int
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "long"                    # long int
SimpleCVTypeSpecifier -> "long" CVQualifierSeq "int"                       # long int
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "short" "int"             # short int
SimpleCVTypeSpecifier -> "signed" "short" CVQualifierSeq "int"             # short int
SimpleCVTypeSpecifier -> "signed" CVQualifierSeq "short"                   # short int
SimpleCVTypeSpecifier -> "short" CVQualifierSeq "int"                      # short int
SimpleCVTypeSpecifier -> "long" CVQualifierSeq "double"                    # long double


EnumSpecifier -> "enum" "{" EnumeratorListOpt "}"
EnumSpecifier -> "enum" EnumName "{" EnumeratorListOpt "}"

EnumeratorList -> EnumeratorDefinition
EnumeratorList -> EnumeratorList "," EnumeratorDefinition
EnumeratorListOpt -> empty | EnumeratorList

EnumeratorDefinition -> EnumValueName
EnumeratorDefinition -> EnumValueName "=" ConstantExpression

AsmDefinition -> "asm" "(" L2_STRING_LITERAL ")" ";"

LinkageSpecification -> "extern" L2_STRING_LITERAL "{" DeclarationSeqOpt "}"
LinkageSpecification -> "extern" L2_STRING_LITERAL Declaration

# ------ A.7 Declarators ------
# -- declarator --
# declarator: the "x" in a declaration like "int x"

InitDeclaratorList -> InitDeclarator
InitDeclaratorList -> InitDeclaratorList "," InitDeclarator
InitDeclaratorListOpt -> empty | InitDeclaratorList

InitDeclarator -> Declarator                    # (int)  x
InitDeclarator -> Declarator Initializer        # (int)  x = 5

Initializer -> "=" InitializerClause
Initializer -> "(" ExpressionList ")"           # ctor args                               # C++

InitializerClause -> AssignmentExpression           # scalar
InitializerClause -> "{" InitializerList "}"        # array initializer
InitializerClause -> "{" InitializerList "," "}"    # useful syntactic quirk
InitializerClause -> "{" "}"                        # ?  does this mean the array is zeroed?

InitializerList -> InitializerClause
InitializerList -> InitializerList "," InitializerClause


# attribute 'isFunction' of Declarator and DirectDeclarator:
# if the type of the thing declared is a function (not a ptr to
# a function, or an array of fns...), this is 1, otherwise 0;
# it is used to do some disambiguation later on, where functions
# are allowed to not have return types (DeclSpecifiers), but
# other declarations must have types


# (PtrOperator)* DirectDeclarator
Declarator.lhs -> PtrOperator Declarator
  %action { Declarator.lhs.isFunction := 0 }
Declarator.lhs -> DirectDeclarator
  %action { Declarator.lhs.isFunction := DirectDeclarator.isFunction }

DirectDeclarator.lhs -> PQVarName
  %action { DirectDeclarator.lhs.isFunction := 0 }
  %condition { (== PQVarName.colonColon 0) }
    # declarator names can't be qualified with "::" (this resolves an
    # ambiguity with constructs like "Foo::Foo() {}")
DirectDeclarator.lhs -> DirectDeclarator "(" ParameterDeclarationClause ")" CVQualifierSeqOpt  # fn
  #                     ^^ name of fn ^^     ^^^^^^^ arguments ^^^^^^^^     ^^^^ const? ^^^^^
  # the return type comes from the type specifier that preceeds this
  %action { DirectDeclarator.lhs.isFunction := 1 }
DirectDeclarator.lhs -> DirectDeclarator "[" ConstantExpression "]"      # array of specified size
  %action { DirectDeclarator.lhs.isFunction := 0 }
DirectDeclarator.lhs -> DirectDeclarator "[" "]"                         # array of unspecified size
  %action { DirectDeclarator.lhs.isFunction := 0 }
DirectDeclarator.lhs -> "(" Declarator ")"                               # precedence grouping
  %action { DirectDeclarator.lhs.isFunction := Declarator.isFunction }

PtrOperator -> "*" CVQualifierSeqOpt
PtrOperator -> "&"                                                                        # C++
# c++ std mentions something with "::" as well, I don't know what that means

CVQualifierSeqOpt -> empty | CVQualifier CVQualifierSeqOpt
CVQualifierSeq -> CVQualifier | CVQualifier CVQualifierSeq
CVQualifier -> "const" | "volatile"

# -- type-id --
# a type-id is like a declaration of one thing, but without the variable name;
# it is, for example, what appears inside the parens of a typecast
# old -- why seq??  TypeId -> TypeSpecifierSeq AbstractDeclarator
TypeId -> TypeSpecifier AbstractDeclarator

TypeSpecifierSeq -> TypeSpecifier | TypeSpecifier TypeSpecifierSeq

# this introduces extra ambiguities (like "int (x)" -- integer or fn with
# name omitted?), so I'm going to back to a duplicated structure
AbstractDeclarator -> PtrOperator AbstractDeclarator | DirectAbstractDeclarator

DirectAbstractDeclarator -> empty            # this is for type-ids
DirectAbstractDeclarator -> DirectAbstractDeclarator "(" ParameterDeclarationClause ")" CVQualifierSeqOpt  # fn
DirectAbstractDeclarator -> DirectAbstractDeclarator "[" ConstantExpression "]"      # array of specified size
DirectAbstractDeclarator -> DirectAbstractDeclarator "[" "]"                         # array of unspecified size
DirectAbstractDeclarator -> "(" AbstractDeclarator ")"                               # precedence grouping


# -- parameters in declarations --
ParameterDeclarationClause -> ParameterDeclarationList            # some args
ParameterDeclarationClause -> empty                               # no args
ParameterDeclarationClause -> ParameterDeclarationList "..."      # args plus optionally more
ParameterDeclarationClause -> ParameterDeclarationList "," "..."  # same; alternative syntax
ParameterDeclarationClause -> "..."                               # all args are optional

ParameterDeclarationList -> ParameterDeclaration
ParameterDeclarationList -> ParameterDeclarationList "," ParameterDeclaration

# here's a place my abstract-declarator = declarator stuff pays off; the
# original spec had four alternatives, since parameters don't have to be
# named
# UPDATE: but now I've split them...
ParameterDeclaration -> DeclSpecifier Declarator
ParameterDeclaration -> DeclSpecifier Declarator "=" AssignmentExpression
ParameterDeclaration -> DeclSpecifier AbstractDeclarator
ParameterDeclaration -> DeclSpecifier AbstractDeclarator "=" AssignmentExpression


# -- function definition --            
# I am wary of letting the declspecifier be optional, because it seems
# to me that may introduce more ambiguities.. but it truly is missing
# in ctors and dtors; so my idea now is to only permit it when the
# declarator declares a function type (can't be more specific since there
# aren't good syntactic clues for ctors)
#                     return type      name/params body
FunctionDefinition -> DeclSpecifier    Declarator  FunctionBody
FunctionDefinition ->   ExplicitOpt    Declarator  FunctionBody                         # {c,d}tor  # C++
  %condition { (== Declarator.isFunction 1) }                                                       # C++
FunctionDefinition ->   ExplicitOpt    Declarator ":" MemInitializerList FunctionBody   # ctor      # C++
  %condition { (== Declarator.isFunction 1) }                                                       # C++

FunctionBody -> CompoundStatement

ExplicitOpt -> "explicit" | empty                                                         # C++


# ------ A.8 Classes ------
# I'm going to use the "class" terminology throughout, even though
# C only has "struct" and "union"
ClassSpecifier -> ClassHead "{" MemberDeclarationSeqOpt "}"

ClassHead -> ClassKeyword ClassNameOpt BaseClauseOpt
ClassNameOpt -> empty | ClassName
ClassKeyword -> "class" | "struct" | "union"

MemberDeclarationSeqOpt -> empty
MemberDeclarationSeqOpt -> MemberDeclaration MemberDeclarationSeqOpt
MemberDeclarationSeqOpt -> AccessSpecifier ":" MemberDeclarationSeqOpt                    # C++

AccessSpecifier -> "public" | "private" | "protected"                                     # C++

MemberDeclaration -> DeclSpecifier MemberDeclaratorList ";"     # member fn or data       # C++
MemberDeclaration -> FunctionDefinition ";"                     # inline fn               # C++
MemberDeclaration -> FunctionDefinition                         # syntactic tweak         # C++
MemberDeclaration -> ExplicitOpt VirtualOpt Declarator ";"      # ctor, dtor, conv op     # C++
  %condition { (== Declarator.isFunction 1) }                                             # C++
  # note above that "explicit" and "virtual" can't be mixed because the former
  # is for ctors only and the latter can't be used with ctors


MemberDeclaratorList -> MemberDeclarator | MemberDeclaratorList "," MemberDeclarator

MemberDeclarator -> Declarator
MemberDeclarator -> Declarator "=" ConstantExpression    # pure; and member inits??       # C++


# ------ A.9 Derived classes ------
BaseClauseOpt -> empty
BaseClauseOpt -> ":" BaseSpecifierList                                                    # C++

BaseSpecifierList -> BaseSpecifier | BaseSpecifierList "," BaseSpecifier                  # C++

BaseSpecifier -> VirtualOpt AccessSpecifierOpt PQClassName                                # C++
VirtualOpt -> empty | "virtual"                                                           # C++
AccessSpecifierOpt -> empty | AccessSpecifier                                             # C++

PQClassName -> ClassName                                                                  # C++
PQClassName -> Qualifier PQClassName                                                      # C++


# ------ A.10 Special member functions ------
ConversionFunctionId -> "operator" ConversionTypeId                                       # C++
ConversionTypeId -> TypeSpecifier ConversionDeclaratorOpt                                 # C++
ConversionDeclaratorOpt -> empty | PtrOperator ConversionDeclaratorOpt                    # C++

MemInitializerList -> MemInitializer                                                      # C++
MemInitializerList -> MemInitializer "," MemInitializerList                               # C++

# std has a separate rule for base class ctor call, but that's not
# a useful parsing distinction, so it just creates gratuitous
# ambiguities, and I've eliminated it
MemInitializer -> L2_NAME "(" ExpressionListOpt ")"            # member init              # C++


# ------ A.11 Overloading ------
OperatorFunctionId -> "operator" Operator                                                 # C++

# the cpp standard is unclear on whether "()" is to be considered a token,
# or whether it is permissible to see it as "(" ")".. I'm using the latter
Operator -> "new" | "delete" | "new" "[" "]" | "delete" "[" "]"                           # C++
Operator -> BinaryOperator            # filter out ".*" later                             # C++
Operator -> AssignmentOperator                                                            # C++
Operator -> "!" | "~" | "," | "++" | "--" | "->"                                          # C++
Operator -> "(" ")" | "[" "]"                                                             # C++


# ------ A.12 Templates ------
#TemplateParameterList -> TemplateParameter                                               # C++
#TemplateParameterList -> TemplateParameterList "," TemplateParameter                     # C++

#TemplateParameter -> TypeParameter | ParameterDeclaration                                # C++


TemplateId -> TemplateName "<" TemplateArgumentList ">"                                   # C++
TemplateId -> TemplateName "<" ">"                                                        # C++

TemplateArgumentList -> TemplateArgument                                                  # C++
TemplateArgumentList -> TemplateArgumentList "," TemplateArgument                         # C++

TemplateArgument -> Literal                                                               # C++
TemplateArgument -> TypeId                                                                # C++
# where I have Literal the std has AssignmentExpression...
# std also mentions IdExpression here, which is my PQVarName.....


# ------ A.13 Exception handling ------
TryBlock -> "try" CompoundStatement HandlerSeq                                            # C++

HandlerSeq -> Handler | Handler HandlerSeq                                                # C++

Handler -> "catch" "(" ExceptionDeclaration ")" CompoundStatement                         # C++

ExceptionDeclaration -> TypeSpecifier Declarator           # named exception object       # C++
ExceptionDeclaration -> TypeSpecifier AbstractDeclarator   # unnamed exception object     # C++
ExceptionDeclaration -> "..."                              # anything                     # C++

ThrowExpression -> "throw" AssignmentExpression                                           # C++
ThrowExpression -> "throw"                                                                # C++


# ---------------- token sequence ambiguity resolution ---------------------
# this section contains token sequences that are known to produce
# ambiguities, but where the correct interpretation is almost always
# something in particular; this section is all heuristic, and therefore
# should not be considered a definitive part of the language def (and
# it can be disabled by a flag to the parser)
                                    
# this is one of the classic C ambiguities; but since no one would
# declare a variable with syntax like "int (x);", it's pretty safe
# to assume this is a fn call
%tokSeqAmb  ExpressionStatement  ->  L2_NAME "(" L2_NAME ")" ";"

