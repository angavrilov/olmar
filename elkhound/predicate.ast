// predicate.ast
// abstract syntax of predicates that can be passed to Simplify

verbatim {
  #include "cc_flags.h"         // BinaryOp
  #include "absval.ast.gen.h"   // AbsValue, AbsValueVisitor

  class stringBuilder;          // str.h

  enum RelationOp {
    RE_EQUAL,       // ==
    RE_NOTEQUAL,    // !=
    RE_LESS,        // <
    RE_GREATER,     // >
    RE_LESSEQ,      // <=
    RE_GREATEREQ,   // >=
    NUM_RELATIONOPS
  };

  extern char const * const relationOpNames[NUM_RELATIONOPS];
  string toString(RelationOp op);
  RelationOp binOpToRelation(BinaryOp op);

  // syntactic sugar for constructing conjunctions
  class Predicate;
  Predicate *P_and2(Predicate *p1, Predicate *p2);    // p1,p2 owner pointers
  Predicate *P_or2(Predicate *p1, Predicate *p2);
  
  // visitor interface
  class PredicateVisitor {
  public:
    // return true to continue recursing or false to stop visiting children
    virtual bool visitPredicate(Predicate const *pred);
  };

  class ValuePredicateVisitor : public PredicateVisitor, public AbsValueVisitor
  {};

  void walkPredicate(PredicateVisitor &vis, Predicate const *pred);
  void walkValuePredicate(ValuePredicateVisitor &vis, Predicate const *pred);
}

impl_verbatim {
  // for debugPrint; AbsValue doesn't have a convenient toString,
  // and the printing interface isn't really set up to call its
  // debugPrint method
  string toString(AbsValue const *v)
    { return stringc << (void*)v; }
}


class Predicate {                    
  // build an s-exp (symbolic expression) out of this predicate
  public string toSexpString() const;
  pure_virtual void toSexp(stringBuilder &sb) const;

  // --------------- "literals" --------------
  // true or false
  -> P_lit(bool b);

  // propositional variable
  // (leaving out for now since I don't seem to need it)

  // arithmetic relation; perhaps I want to allow generalized
  // predicate symbols (but would Simplify accept them?)
  -> P_relation(AbsValue const *e1, RelationOp op, AbsValue const *e2);

  // distinction: leaving out for now

  // negation of a predicate
  -> P_not(Predicate p);

  // ---------------- "boolean functions" --------------
  -> P_and(ASTList<Predicate> conjuncts);
  -> P_or(ASTList<Predicate> disjuncts);
  -> P_impl(Predicate premise, Predicate conclusion);
  -> P_iff(Predicate p1, Predicate p2);

  // quantification: not yet

  // ordering: not yet
  // labelled predicates: not yet
}


impl_verbatim {
  #include "str.h"                // stringBuilder
  #include "absval.ast.gen.h"     // AbsValue

  char const * const relationOpNames[NUM_RELATIONOPS] = {
    "==",
    "!=",
    "<",
    ">",
    "<=",
    ">="
  };

  string toString(RelationOp op)
  {
    xassert((unsigned)op < NUM_RELATIONOPS);
    return string(relationOpNames[op]);
  }

  RelationOp binOpToRelation(BinaryOp op)
  {
    xassert(op >= BIN_EQUAL && op <= BIN_GREATEREQ);
    return (RelationOp)op;
  }

  Predicate *P_and2(Predicate *p1, Predicate *p2)
  {
    P_and *p = new P_and(NULL);
    p->conjuncts.append(p1);
    p->conjuncts.append(p2);
    return p;
  }

  Predicate *P_or2(Predicate *p1, Predicate *p2)
  {
    P_or *p = new P_or(NULL);
    p->disjuncts.append(p1);
    p->disjuncts.append(p2);
    return p;
  }


  string Predicate::toSexpString() const
  {
    stringBuilder sb;
    toSexp(sb);
    return sb;
  }

  // -------------------- toSexp -------------------------
  void P_lit::toSexp(stringBuilder &sb) const
  {
    if (b) {
      sb << "TRUE";
    }
    else {
      sb << "FALSE";
    }
  }

  void P_relation::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "EQ", "NEQ", "<", ">", "<=", ">="
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_RELATIONOPS);

    sb << "(" << names[op] << " ";
    e1->toSexp(sb);
    sb << " ";
    e2->toSexp(sb);
    sb << ")";
  }

  void P_not::toSexp(stringBuilder &sb) const
  {
    sb << "(NOT ";
    p->toSexp(sb);
    sb << ")";
  }

  void P_and::toSexp(stringBuilder &sb) const
  {
    sb << "(AND";
    FOREACH_ASTLIST(Predicate, conjuncts, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void P_or::toSexp(stringBuilder &sb) const
  {
    sb << "(OR";
    FOREACH_ASTLIST(Predicate, disjuncts, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void P_impl::toSexp(stringBuilder &sb) const
  {
    sb << "(IMPLIES ";
    premise->toSexp(sb);
    sb << " ";
    conclusion->toSexp(sb);
    sb << ")";
  }

  void P_iff::toSexp(stringBuilder &sb) const
  {
    sb << "(IFF ";
    p1->toSexp(sb);
    sb << " ";
    p2->toSexp(sb);
    sb << ")";
  }


  // -------------- visitor ---------------
  bool PredicateVisitor::visitPredicate(Predicate const *pred)
  {
    return true;
  }

  void walkPredicate(PredicateVisitor &vis, Predicate const *pred)
  {
    if (!vis.visitPredicate(pred)) {
      return;
    }

    ASTSWITCHC(Predicate, pred) {
      ASTCASEC(P_not, n) {
        walkPredicate(vis, n->p);
      }

      ASTNEXTC(P_and, a) {
        FOREACH_ASTLIST(Predicate, a->conjuncts, iter) {
          walkPredicate(vis, iter.data());
        }
      }

      ASTNEXTC(P_or, o) {
        FOREACH_ASTLIST(Predicate, o->disjuncts, iter) {
          walkPredicate(vis, iter.data());
        }
      }

      ASTNEXTC(P_impl, i) {
        walkPredicate(vis, i->premise);
        walkPredicate(vis, i->conclusion);
      }

      ASTNEXTC(P_iff, i) {
        walkPredicate(vis, i->p1);
        walkPredicate(vis, i->p2);
      }

      ASTENDCASEC
    }
  }


  class VPVisitThunk : public PredicateVisitor {
    ValuePredicateVisitor &innerVis;
  public:                   
    VPVisitThunk(ValuePredicateVisitor &i) : innerVis(i) {}
    virtual bool visitPredicate(Predicate const *pred);
  };

  bool VPVisitThunk::visitPredicate(Predicate const *pred)
  {
    if (!innerVis.visitPredicate(pred)) {
      return false;
    }

    if (pred->isP_relation()) {
      P_relation const *r = pred->asP_relationC();
      walkAbsValue(innerVis, r->e1);
      walkAbsValue(innerVis, r->e2);
    }

    return true;
  }

  void walkValuePredicate(ValuePredicateVisitor &vis, Predicate const *pred)
  {
    VPVisitThunk thunk(vis);
    walkPredicate(thunk, pred);
  }
}
