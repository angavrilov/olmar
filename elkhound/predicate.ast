// predicate.ast
// abstract syntax of predicates that can be passed to Simplify
// NOTE: everywhere in this interface, Predicate* are owner pointers (unless const)

verbatim {
  #include "cc_flags.h"         // BinaryOp
  #include "absval.ast.gen.h"   // AbsValue, AbsValueVisitor

  class stringBuilder;          // str.h

  enum RelationOp {
    RE_EQUAL,       // ==
    RE_NOTEQUAL,    // !=
    RE_LESS,        // <
    RE_GREATER,     // >
    RE_LESSEQ,      // <=
    RE_GREATEREQ,   // >=
    NUM_RELATIONOPS
  };

  extern char const * const relationOpNames[NUM_RELATIONOPS];
  string toString(RelationOp op);
  RelationOp binOpToRelation(BinaryOp op);

  // syntactic sugar for constructing predicates
  class Predicate;
  Predicate *P_and2(Predicate *p1, Predicate *p2);    // p1,p2 owner pointers
  Predicate *P_or2(Predicate *p1, Predicate *p2);

  // construct and, or, or implies, depending on 'op'
  Predicate *P_combinator(BinaryOp op, Predicate *p1, Predicate *p2);

  Predicate *P_equal(AbsValue const *e1, AbsValue const *e2);
  Predicate *P_notEqual(AbsValue const *e1, AbsValue const *e2);
  Predicate *P_negate(Predicate *p);    // will strip outer P_not if exists

  Predicate *P_forall(ASTList<AVvar> *variables, Predicate *body);
  Predicate *P_exists(ASTList<AVvar> *variables, Predicate *body);

  // visitor interface
  class PredicateVisitor {
  public:
    // return true to continue recursing or false to stop visiting children
    virtual bool visitPredicate(Predicate const *pred);
  };

  class ValuePredicateVisitor : public PredicateVisitor, public AbsValueVisitor
  {};

  void walkPredicate(PredicateVisitor &vis, Predicate const *pred);
  void walkValuePredicate(ValuePredicateVisitor &vis, Predicate const *pred);

  // does 'pred' refer to 'av' anywhere?
  bool predicateRefersToAV(Predicate const *pred, AbsValue const *av);
}

impl_verbatim {
  // for debugPrint; AbsValue doesn't have a convenient toString,
  // and the printing interface isn't really set up to call its
  // debugPrint method
  string toString(AbsValue const *v)
    { return stringc << (void*)v; }
}


class Predicate {                    
  // build an s-exp (symbolic expression) out of this predicate
  public string toSexpString() const;
  pure_virtual void toSexp(stringBuilder &sb) const;

  // --------------- "literals" --------------
  // true or false
  -> P_lit(bool b);

  // propositional variable
  // (leaving out for now since I don't seem to need it)

  // arithmetic relation; perhaps I want to allow generalized
  // predicate symbols (but would Simplify accept them?)
  -> P_relation(AbsValue const *e1, RelationOp op, AbsValue const *e2);

  // distinction: like O(n^2) disequalities
  -> P_distinct(ASTList<AbsValue> terms);

  // negation of a predicate
  -> P_not(Predicate p);

  // ---------------- "boolean functions" --------------
  -> P_and(ASTList<Predicate> conjuncts);
  -> P_or(ASTList<Predicate> disjuncts);
  -> P_impl(Predicate premise, Predicate conclusion);
  -> P_iff(Predicate p1, Predicate p2);

  // quantification
  -> P_quantifier(ASTList<AVvar> variables, Predicate body, bool forall);

  // named predicates, uninterpreted by Simplify
  -> P_named(StringRef name, ASTList<AbsValue> args);

  // ordering: not yet
  // labeled predicates: not yet
}


impl_verbatim {
  #include "str.h"                // stringBuilder
  #include "absval.ast.gen.h"     // AbsValue

  char const * const relationOpNames[NUM_RELATIONOPS] = {
    "==",
    "!=",
    "<",
    ">",
    "<=",
    ">="
  };

  string toString(RelationOp op)
  {
    xassert((unsigned)op < NUM_RELATIONOPS);
    return string(relationOpNames[op]);
  }

  RelationOp binOpToRelation(BinaryOp op)
  {
    xassert(isRelational(op));
    return (RelationOp)op;
  }

  Predicate *P_and2(Predicate *p1, Predicate *p2)
  {
    // flatten some structures; this helps the presentation when
    // displaying messages to the user
    if (p1->isP_and()) {
      p1->asP_and()->conjuncts.append(p2);
      return p1;
    }
    else if (p2->isP_and()) {
      p2->asP_and()->conjuncts.prepend(p1);
      return p2;
    }

    P_and *p = new P_and(NULL);
    p->conjuncts.append(p1);
    p->conjuncts.append(p2);
    return p;
  }

  Predicate *P_or2(Predicate *p1, Predicate *p2)
  {
    P_or *p = new P_or(NULL);
    p->disjuncts.append(p1);
    p->disjuncts.append(p2);
    return p;
  }

  Predicate *P_combinator(BinaryOp op, Predicate *lhs, Predicate *rhs)
  {
    switch (op) {
      default:          xfailure("bad combinator op code");
      case BIN_AND:     return P_and2(lhs, rhs);
      case BIN_OR:      return P_or2(lhs, rhs);
      case BIN_IMPLIES: return new P_impl(lhs, rhs);
    }
  }

  Predicate *P_equal(AbsValue const *e1, AbsValue const *e2)
  {
    return new P_relation(e1, RE_EQUAL, e2);
  }

  Predicate *P_notEqual(AbsValue const *e1, AbsValue const *e2)
  {
    return new P_relation(e1, RE_NOTEQUAL, e2);
  }

  Predicate *P_negate(Predicate *pred)
  {
    if (pred->isP_not()) {
      // strip the outer not, instead of adding another, for
      // presentation-to-user reasons
      Predicate *ret = pred->asP_not()->p;
      pred->asP_not()->p = NULL;     // prevent it from deleting p
      delete pred;
      return ret;
    }
    else {
      return new P_not(pred);
    }
  }

  Predicate *P_forall(ASTList<AVvar> *variables, Predicate *body)
  {
    return new P_quantifier(variables, body, true /*forall*/);
  }

  Predicate *P_exists(ASTList<AVvar> *variables, Predicate *body)
  {
    return new P_quantifier(variables, body, false /*forall*/);
  }


  string Predicate::toSexpString() const
  {
    stringBuilder sb;
    toSexp(sb);
    return sb;
  }

  // -------------------- toSexp -------------------------
  void P_lit::toSexp(stringBuilder &sb) const
  {
    if (b) {
      sb << "TRUE";
    }
    else {
      sb << "FALSE";
    }
  }

  void P_relation::toSexp(stringBuilder &sb) const
  {
    static char const * const names[] = {
      "EQ", "NEQ", "<", ">", "<=", ">="
    };
    STATIC_ASSERT(TABLESIZE(names) == NUM_RELATIONOPS);

    sb << "(" << names[op] << " ";
    e1->toSexp(sb);
    sb << " ";
    e2->toSexp(sb);
    sb << ")";
  }

  void P_distinct::toSexp(stringBuilder &sb) const
  {
    sb << "(DISTINCT";
    FOREACH_ASTLIST(AbsValue, terms, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void P_not::toSexp(stringBuilder &sb) const
  {
    sb << "(NOT ";
    p->toSexp(sb);
    sb << ")";
  }

  void P_and::toSexp(stringBuilder &sb) const
  {
    sb << "(AND";
    FOREACH_ASTLIST(Predicate, conjuncts, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void P_or::toSexp(stringBuilder &sb) const
  {
    sb << "(OR";
    FOREACH_ASTLIST(Predicate, disjuncts, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }

  void P_impl::toSexp(stringBuilder &sb) const
  {
    sb << "(IMPLIES ";
    premise->toSexp(sb);
    sb << " ";
    conclusion->toSexp(sb);
    sb << ")";
  }

  void P_iff::toSexp(stringBuilder &sb) const
  {
    sb << "(IFF ";
    p1->toSexp(sb);
    sb << " ";
    p2->toSexp(sb);
    sb << ")";
  }

  void quantifiedToSexp(stringBuilder &sb, char const *name,
    ASTList<AVvar> const &variables, Predicate const *body)
  {
    sb << "(" << name << " (";
    FOREACH_ASTLIST(AVvar, variables, iter) {
      sb << iter.data()->name << " ";
    }
    sb << ") ";
    body->toSexp(sb);
    sb << ")";
  }

  void P_quantifier::toSexp(stringBuilder &sb) const
  {
    quantifiedToSexp(sb, forall? "FORALL" : "EXISTS", variables, body);
  }

  void P_named::toSexp(stringBuilder &sb) const
  {
    sb << "(" << name;
    FOREACH_ASTLIST(AbsValue, args, iter) {
      sb << " ";
      iter.data()->toSexp(sb);
    }
    sb << ")";
  }


  // -------------- visitor ---------------
  bool PredicateVisitor::visitPredicate(Predicate const *pred)
  {
    return true;
  }

  void walkPredicate(PredicateVisitor &vis, Predicate const *pred)
  {
    if (!vis.visitPredicate(pred)) {
      return;
    }

    ASTSWITCHC(Predicate, pred) {
      ASTCASEC(P_not, n) {
        walkPredicate(vis, n->p);
      }

      ASTNEXTC(P_and, a) {
        FOREACH_ASTLIST(Predicate, a->conjuncts, iter) {
          walkPredicate(vis, iter.data());
        }
      }

      ASTNEXTC(P_or, o) {
        FOREACH_ASTLIST(Predicate, o->disjuncts, iter) {
          walkPredicate(vis, iter.data());
        }
      }

      ASTNEXTC(P_impl, i) {
        walkPredicate(vis, i->premise);
        walkPredicate(vis, i->conclusion);
      }

      ASTNEXTC(P_iff, i) {
        walkPredicate(vis, i->p1);
        walkPredicate(vis, i->p2);
      }

      ASTNEXTC(P_quantifier, fa) {
        walkPredicate(vis, fa->body);
      }

      ASTENDCASECD
    }
  }


  class VPVisitThunk : public PredicateVisitor {
    ValuePredicateVisitor &innerVis;
  public:
    VPVisitThunk(ValuePredicateVisitor &i) : innerVis(i) {}
    virtual bool visitPredicate(Predicate const *pred);
  };

  bool VPVisitThunk::visitPredicate(Predicate const *pred)
  {
    if (!innerVis.visitPredicate(pred)) {
      return false;
    }

    ASTSWITCHC(Predicate, pred) {
      ASTCASEC(P_relation, r) {
        walkAbsValue(innerVis, r->e1);
        walkAbsValue(innerVis, r->e2);
      }
      ASTNEXTC(P_distinct, d) {
        FOREACH_ASTLIST(AbsValue, d->terms, iter) {
          walkAbsValue(innerVis, iter.data());
        }
      }
      ASTENDCASECD
    }

    return true;
  }

  void walkValuePredicate(ValuePredicateVisitor &vis, Predicate const *pred)
  {
    VPVisitThunk thunk(vis);
    walkPredicate(thunk, pred);
  }
  
  
  class VPVisit_predicateRefers : public ValuePredicateVisitor {
  public:
    AbsValue const *avOfInterest;
    bool foundReference;
  public:
    VPVisit_predicateRefers(AbsValue const *v)
      : avOfInterest(v),
        foundReference(false)
    {}
    virtual bool visitAbsValue(AbsValue const *value);
  };

  bool VPVisit_predicateRefers::visitAbsValue(AbsValue const *value)
  {
    if (foundReference || value == avOfInterest) {
      foundReference = true;
      return false;   // stop
    }
    else {
      return true;    // keep recursing
    }
  }

  bool predicateRefersToAV(Predicate const *pred, AbsValue const *av)
  {
    VPVisit_predicateRefers vis(av);
    walkValuePredicate(vis, pred);
    return vis.foundReference;
  }
}
