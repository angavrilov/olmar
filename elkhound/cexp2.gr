// cexp2.gr
// subgrammar for C expressions; experimental syntax

terminals {
  // grab the lexer's token list
  include("cc.tok")
}


// stuff that goes at top of cexp2.h
prologue {
  #include "objlist.h"     // ObjList
  #include "lexer2.h"      // Lexer2Token
  #include "ccwrite.h"     // NonterminalInfo

  class Bindings {
  private:  // data
    struct Entry {
      string name;
      int value;
    public:
      Entry(char const *n, int v)
        : name(n), value(v) {}
      ~Entry();
    };
    ObjList<Entry> blist;

  public:
    Bindings();
    ~Bindings();
    
    void add(char const *name, int val);
    int lookup(char const *name) const;
  };
}


// dummy first rule
nonterm StartSymbol -> Input L2_EOF ;


// first some bindings, then an expression
nonterm Input -> defs:VarDefList ";" e:Expr {
  // return value of total expression
  fundecl int eval() const;

  fun eval {
    // gather the bindings from the definitions
    Bindings bindings;
    defs.gatherBindings(bindings);

    // use them to evaluate
    return e.eval(bindings);
  }
  
  // another idea:
  /*
  -> seq:(def:VarDef+) ";" e:Expr {
    fun eval {
      Bindings bindings;
      FOREACH(seq) {
        // this would require.. hmmm.. maybe list of list of children?
        // or emit another kind of nonterminal?  ...
        def.gatherBindings(bindings);
      }

      return e.eval(bindings);
    }
  }
  */
}


// list of variable bindings
nonterm VarDefList {
  // collect new bindings and put them in 'bindings'
  fundecl void gatherBindings(Bindings &bindings) const;

  -> def:VarDef {
    fun gatherBindings {
      def.gatherBindings(bindings);
    }
  }

  -> def:VarDef "," defs:VarDefList {
    fun gatherBindings {
      def.gatherBindings(bindings);
      defs.gatherBindings(bindings);
    }
  }
}

nonterm VarDef -> n:L2_NAME "=" e:Expr {
  fundecl void gatherBindings(Bindings &bindings) const;

  fun gatherBindings {
    string name = n.strValue;

    // Expr contains constants only
    Bindings empty;
    int val = e.eval(empty);
    
    // add result to global bindings list
    bindings.add(name, val);
  }
}


// primary expressions
nonterm Expr {
  attr prec;              // precedence of binding (topmost) operator in expression

  // return the value of this expression, in the given
  // binding environment
  fundecl int eval(Bindings const &bindings) const;

  // variables and literals have higher precedence than anything else
  action  prec := 100;

  -> name:L2_NAME {
    fun eval {
      return bindings.lookup(name.strValue);
    }
  }

  -> num:L2_INT_LITERAL {
    fun eval = num.intValue;
  }

  -> left:Expr op:Binop right:Expr {
    action  prec := op.prec;

    condition  this.prec <= left.prec;             // precedence
    condition  this.prec <= right.prec;            // more precedence
    condition  op.leftAssoc == 1 ?
                 this.prec < right.prec :          // left associative
                 this.prec < left.prec;            // right associative

    /* DOES NOT WORK
    // want to return:
    //   <0 if t1 is preferred
    //    0 if they are not comparable
    //   >0 if t2 is preferred
    treeCompare(t1,t2) =
      // if their precedences differ, then we prefer
      // tree with the *lower* precedence (because then
      // we get higher-precedence operators lower in the
      // tree, i.e. more tightly bound)
      t1.op.prec != t2.op.prec? (t1.op.prec - t2.op.prec) :

      // if their associativities differ, we can't further
      // compare them
      t1.op.leftAssoc != t2.op.leftAssoc? 0 :

      // if they are left-associative, we prefer the tree
      // with the larger left subtree
      t1.op.leftAssoc == 1? t2.left.numGroundTerms - t1.left.numGroundTerms :

      // otherwise, they're right associative, so we prefer
      // larger right subtrees
      t2.right.numGroundTerms - t1.right.numGroundTerms ;
    */


    fun eval {
      int L = left.eval(bindings);
      int R = right.eval(bindings);
      int ret = op.eval(L, R);
      cout << L << " " << op.opSpelling() << " " << R
           << " = " << ret << endl;
      return ret;
    }
  }
}


// an operator in a binary expression
nonterm Binop {
  attr prec;             // precedence of operator; higher value binds more tightly
  attr leftAssoc;        // 1 means left-associative, 0 means right-associative

  // evaluate, given left and right operands
  fundecl int eval(int left, int right) const;

  // give me the spelling of the L2 token for the operator
  fundecl char const *opSpelling() const;
  fun opSpelling = l2Tok2String(getOnlyChildToken(0).type);

  // all have left precedence by default; can override individually
  action  leftAssoc := 1;

  // highest precedence
  formGroup {
    action prec:=60;
    -> "*"     { fun eval = left * right; }
    -> "/"     { fun eval = left / right; }
    -> "%"     { fun eval = left % right; }
  }

  formGroup {
    action prec:=56;
    -> "+"    { fun eval = left + right; }
    -> "-"    { fun eval = left - right; }
  }

  formGroup {
    action prec:=52;
    -> "<<"   { fun eval = left << right; }
    -> ">>"   { fun eval = left >> right; }
  }

  formGroup {
    action prec:=48;
    -> "<"    { fun eval = left < right; }
    -> ">"    { fun eval = left > right; }
    -> "<="   { fun eval = left <= right; }
    -> ">="   { fun eval = left >= right; }
  }

  formGroup {
    action prec:=44;
    -> "=="   { fun eval = left == right; }
    -> "!="   { fun eval = left != right; }
  }

  -> "&" {
    action prec:=40;
    fun eval = left & right;
  }

  -> "^" {
    action prec:=36;
    fun eval = left ^ right;
  }

  -> "|" {
    action prec:=32;
    fun eval = left | right;
  }

  -> "&&" {
    action prec:=28;
    fun eval = left && right;
  }

  -> "||" {
    action prec:=24;
    fun eval = left || right;
  }
  // lowest precedence
}

              
// stuff that goes at the end of cexp2.cc
epilogue {
  #include "glr.h"       // GLR
  #include "cexp2.h"     // Input_Node, Bindings
  #include "trace.h"     // TRACE_ARGS

  #include <iostream.h>  // cout


  // ------------ Bindings -----------------
  Bindings::Entry::~Entry()
  {}

  Bindings::Bindings()
  {}

  Bindings::~Bindings()
  {}


  void Bindings::add(char const *name, int val)
  {
    blist.prepend(new Entry(name, val));
  }

  int Bindings::lookup(char const *name) const
  {          
    int ret = 0;
    FOREACH_OBJLIST(Entry, blist, iter) {
      if (iter.data()->name.equals(name)) {
        ret = iter.data()->value;
        break;
      }
    }

    // be lax
    cout << "lookup " << name << ": " << ret << endl;
    return ret;
  }


  // ----------------- main ------------------
  int main(int argc, char *argv[])
  {
    char const *progName = argv[0];
    TRACE_ARGS();
    traceAddSys("progress");

    if (argc != 3) {
      cout << "usage: " << progName << " [options] grammar-file input-file\n"
              "  options:\n"
              "    -tr <sys>:  turn on tracing for the named subsystem\n"
              ;
      return 0;
    }

    // parse
    GLR g;
    Lexer2 lexer2;
    g.glrParseFrontEnd(lexer2, argv[1], argv[2]);

    // get tree
    TreeNode const *top = g.getParseTree();
    xassert(top->getSymbolC()->name.equals("Input"));
    Input_Node const *in = (Input_Node const*)top;

    // semantically analyze
    int val = in->eval();
    cout << "evaluation result: " << val << endl;

    return 0;
  }
}
