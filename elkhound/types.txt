
Author: Scott McPeak, October 2000


Info on how C/C++ types are represented
=======================================


C/C++ Declaration Syntax
------------------------

In C/C++ (hereafter, just "C"), a declaration (which binds a name to a
type) breaks down like this:

                           Declaration
                         /             \
            DeclSpecifier               Declarator
           /   |         \             /          \
  modifiers   CV*   atomic-type    PtrOperator*    one-of
      |        |    (see below)       |           /  |   \
  inline,   const,       |         "*" CV*, or   /   |    \
  virtual,  volatile     |         "&"          /    |     \
  friend,              char,                   /     |      \
  etc.                 int,              PQVarName   |  Declarator[sz?]
                       class {},                     |
                       etc.               Declarator (args..) CV*

(The actual grammar is slightly more complicated to enforce the
desired precedence; above is its abstract structure.  Also, the
CV* in DeclSpecifier can actually be distributed throughout the
words of the atomic-type if it's a simple type.. ug.)

The atomic types (my terminology) are either "simple types" like char
and int, or a user-defined compound type: class, struct, union, or
enum.  They are atomic in the sense that there are no modifiers or
operators that can be stripped away ("unsigned" doesn't count -- it
just names a different atomic type; it's effect is not orthogonal to
the thing it modifies).

The PQVarName is the base case of the recursive Declarator structure.
The other parts of that tree recursively build more complex types from
simpler types.  For example, adding a "*" makes a ptr-to-blah from a
blah.

(C's syntax is .. nonideal.  If the above isn't clear, I suggest
working some example declarations, breaking them down using the
structure above.  It takes a bit of thought to really pin down the
relationships.)


How I choose to represent C types
---------------------------------

Types are objects stored in environments.  Environments are nested
within one another, to model scoping rules.  There is one toplevel
environment.

First, there is an AtomicType class.  There is one AtomicType object
for every predefined C type, such as char or int or long double.
(Again, modifiers like "unsigned" are folded into the atomic type, and
whatever relationships (such as coercion) that may exist between
atomic types are dealt with separately.)  These predefined types all
live in the toplevel environment.

When a user-defined compound such as a class is encountered, an
AtomicType object is created and placed into the current environment.
This AtomicType may or may not be associated with a name (if it is
not, it is considered "anonymous").

When a declaration is encountered, a Type object is built.  There are
four kinds of Type object structures (distinguished by a tag field).
Below, unadorned * means pointer while "*" means the pointer operator.

  AtomicType*, CV         // an atomic type, possibly const or volatile
  Type*, ("*" CV | "&")   // pointer or reference type
  Type*, args, CV         // function type; first Type is return type
  Type*, array_size?      // array type; optional size specifier

The function type has a list of arguments, which are Parameter
objects, which include the types of the arguments.

Every Type object created in the process of constructing a final Type
to be associated with a name is stored in the current environment.
Types then contain pointers to other Types or to AtomicTypes.  This
memory management strategy makes it easy to simply throw away an
entire environment including its stored intermediate Types, when we're
done with the environment.

Thus, the semantic functions that manipulate types, generally do so by
first requesting a new Type object from the environment (which stores
that pointer before returning it) and then working with the pointer as
necessary.

