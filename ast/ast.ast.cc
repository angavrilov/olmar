// ast.ast.cc
// *** DO NOT EDIT ***
// automatically generated by astgen, from ast.ast

#include "ast.ast.h"      // this module


// ------------------ ASTSpecFile -------------------
// *** DO NOT EDIT ***
ASTSpecFile::~ASTSpecFile()
{
  forms.deleteAll();
}

void ASTSpecFile::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(ASTSpecFile);

  PRINT_LIST(ToplevelForm, forms);
}

void ASTSpecFile::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(ASTSpecFile);

  XMLPRINT_LIST(ToplevelForm, forms);
  XMLPRINT_FOOTER(ASTSpecFile);
}

ASTSpecFile *ASTSpecFile::clone() const
{
  ASTSpecFile *ret = new ASTSpecFile(
    cloneASTList(forms)
  );
  return ret;
}


// ------------------ ToplevelForm -------------------
// *** DO NOT EDIT ***
ToplevelForm::~ToplevelForm()
{
}

char const * const ToplevelForm::kindNames[ToplevelForm::NUM_KINDS] = {
  "TF_verbatim",
  "TF_impl_verbatim",
  "TF_class",
  "TF_option",
  "TF_enum",
};

void ToplevelForm::debugPrint(ostream &os, int indent) const
{
}

void ToplevelForm::xmlPrint(ostream &os, int indent) const
{
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_verbatim, TF_VERBATIM)

TF_verbatim::~TF_verbatim()
{
}

void TF_verbatim::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_verbatim);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(code);
}

void TF_verbatim::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(TF_verbatim);

  ToplevelForm::xmlPrint(os, indent);

  XMLPRINT_STRING(code);
  XMLPRINT_FOOTER(TF_verbatim);

}

TF_verbatim *TF_verbatim::clone() const
{
  TF_verbatim *ret = new TF_verbatim(
    code
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_impl_verbatim, TF_IMPL_VERBATIM)

TF_impl_verbatim::~TF_impl_verbatim()
{
}

void TF_impl_verbatim::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_impl_verbatim);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(code);
}

void TF_impl_verbatim::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(TF_impl_verbatim);

  ToplevelForm::xmlPrint(os, indent);

  XMLPRINT_STRING(code);
  XMLPRINT_FOOTER(TF_impl_verbatim);

}

TF_impl_verbatim *TF_impl_verbatim::clone() const
{
  TF_impl_verbatim *ret = new TF_impl_verbatim(
    code
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_class, TF_CLASS)

TF_class::~TF_class()
{
  delete super;
  ctors.deleteAll();
}

void TF_class::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_class);

  ToplevelForm::debugPrint(os, indent);

  PRINT_SUBTREE(super);
  PRINT_LIST(ASTClass, ctors);
}

void TF_class::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(TF_class);

  ToplevelForm::xmlPrint(os, indent);

  XMLPRINT_SUBTREE(super);
  XMLPRINT_LIST(ASTClass, ctors);
  XMLPRINT_FOOTER(TF_class);

}

TF_class *TF_class::clone() const
{
  TF_class *ret = new TF_class(
    super? super->clone() : NULL,
    cloneASTList(ctors)
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_option, TF_OPTION)

TF_option::~TF_option()
{
  while (args.isNotEmpty()) {
    args.removeFirst();
  }
}

void TF_option::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_option);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(name);
  PRINT_LIST(string, args);
}

void TF_option::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(TF_option);

  ToplevelForm::xmlPrint(os, indent);

  XMLPRINT_STRING(name);
  XMLPRINT_LIST(string, args);
  XMLPRINT_FOOTER(TF_option);

}

TF_option *TF_option::clone() const
{
  TF_option *ret = new TF_option(
    name,
    shallowCloneASTList(args)
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_enum, TF_ENUM)

TF_enum::~TF_enum()
{
  enumerators.deleteAll();
}

void TF_enum::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_enum);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(name);
  PRINT_LIST(Enumerator, enumerators);
}

void TF_enum::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(TF_enum);

  ToplevelForm::xmlPrint(os, indent);

  XMLPRINT_STRING(name);
  XMLPRINT_LIST(Enumerator, enumerators);
  XMLPRINT_FOOTER(TF_enum);

}

TF_enum *TF_enum::clone() const
{
  TF_enum *ret = new TF_enum(
    name,
    cloneASTList(enumerators)
  );
  return ret;
}


// ------------------ ASTClass -------------------
// *** DO NOT EDIT ***
ASTClass::~ASTClass()
{
  args.deleteAll();
  decls.deleteAll();
}

void ASTClass::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(ASTClass);

  PRINT_STRING(name);
  PRINT_LIST(CtorArg, args);
  PRINT_LIST(Annotation, decls);
}

void ASTClass::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(ASTClass);

  XMLPRINT_STRING(name);
  XMLPRINT_LIST(CtorArg, args);
  XMLPRINT_LIST(Annotation, decls);
  XMLPRINT_FOOTER(ASTClass);
}

ASTClass *ASTClass::clone() const
{
  ASTClass *ret = new ASTClass(
    name,
    cloneASTList(args),
    cloneASTList(decls)
  );
  return ret;
}


// ------------------ Annotation -------------------
// *** DO NOT EDIT ***
Annotation::~Annotation()
{
}

char const * const Annotation::kindNames[Annotation::NUM_KINDS] = {
  "UserDecl",
  "CustomCode",
};

void Annotation::debugPrint(ostream &os, int indent) const
{
}

void Annotation::xmlPrint(ostream &os, int indent) const
{
}

DEFN_AST_DOWNCASTS(Annotation, UserDecl, USERDECL)

UserDecl::~UserDecl()
{
}

void UserDecl::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(UserDecl);

  Annotation::debugPrint(os, indent);

  PRINT_GENERIC(access);
  PRINT_STRING(code);
}

void UserDecl::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(UserDecl);

  Annotation::xmlPrint(os, indent);

  XMLPRINT_GENERIC(access);
  XMLPRINT_STRING(code);
  XMLPRINT_FOOTER(UserDecl);

}

UserDecl *UserDecl::clone() const
{
  UserDecl *ret = new UserDecl(
    access,
    code
  );
  return ret;
}

DEFN_AST_DOWNCASTS(Annotation, CustomCode, CUSTOMCODE)

CustomCode::~CustomCode()
{
}

void CustomCode::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(CustomCode);

  Annotation::debugPrint(os, indent);

  PRINT_STRING(qualifier);
  PRINT_STRING(code);
}

void CustomCode::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(CustomCode);

  Annotation::xmlPrint(os, indent);

  XMLPRINT_STRING(qualifier);
  XMLPRINT_STRING(code);
  XMLPRINT_FOOTER(CustomCode);

}

CustomCode *CustomCode::clone() const
{
  CustomCode *ret = new CustomCode(
    qualifier,
    code
  );
  return ret;
}


// ------------------ CtorArg -------------------
// *** DO NOT EDIT ***
CtorArg::~CtorArg()
{
}

void CtorArg::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(CtorArg);

  PRINT_BOOL(owner);
  PRINT_STRING(type);
  PRINT_STRING(name);
  PRINT_STRING(defaultValue);
}

void CtorArg::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(CtorArg);

  XMLPRINT_BOOL(owner);
  XMLPRINT_STRING(type);
  XMLPRINT_STRING(name);
  XMLPRINT_STRING(defaultValue);
  XMLPRINT_FOOTER(CtorArg);
}

CtorArg *CtorArg::clone() const
{
  CtorArg *ret = new CtorArg(
    owner,
    type,
    name,
    defaultValue
  );
  return ret;
}


// ------------------ Enumerator -------------------
// *** DO NOT EDIT ***
Enumerator::~Enumerator()
{
}

void Enumerator::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(Enumerator);

  PRINT_STRING(name);
  PRINT_STRING(value);
}

void Enumerator::xmlPrint(ostream &os, int indent) const
{
  XMLPRINT_HEADER(Enumerator);

  XMLPRINT_STRING(name);
  XMLPRINT_STRING(value);
  XMLPRINT_FOOTER(Enumerator);
}

Enumerator *Enumerator::clone() const
{
  Enumerator *ret = new Enumerator(
    name,
    value
  );
  return ret;
}


// *** DO NOT EDIT ***


#include "strutil.h"      // stringToupper

string toString(AccessCtl acc)
{
  char const *arr[] = {
    "public",
    "private",
    "protected",
    "ctor",
    "dtor",
    "pure_virtual"
  };
  STATIC_ASSERT(TABLESIZE(arr) == NUM_ACCESSCTLS);
  xassert((unsigned)acc < NUM_ACCESSCTLS);
  return string(arr[acc]);
}

string ASTClass::classKindName() const
{
  string ret = stringToupper(name);
  if (ret == name) {
    // this simplemindedly avoids collisions with itself, and I think
    // it even avoids collisions with other classes, since if they would
    // collide with this, they'd collide with themselves too, and hence
    // get an extra "KIND_" prepended..
    ret &= "KIND_";
  }
  return ret;
}



