// ast.ast.cc
// *** DO NOT EDIT ***
// automatically generated by astgen, from ast.ast

#include "ast.ast.h"      // this module


// ------------------ ASTSpecFile -------------------
// *** DO NOT EDIT ***
ASTSpecFile::~ASTSpecFile()
{
  forms.deleteAll();
}

void ASTSpecFile::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(ASTSpecFile);

  PRINT_LIST(ToplevelForm, forms);
}


// ------------------ ToplevelForm -------------------
// *** DO NOT EDIT ***
ToplevelForm::~ToplevelForm()
{
}

void ToplevelForm::debugPrint(ostream &os, int indent) const
{
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_verbatim, TF_VERBATIM)

TF_verbatim::~TF_verbatim()
{
}

void TF_verbatim::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_verbatim);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(code);
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_impl_verbatim, TF_IMPL_VERBATIM)

TF_impl_verbatim::~TF_impl_verbatim()
{
}

void TF_impl_verbatim::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_impl_verbatim);

  ToplevelForm::debugPrint(os, indent);

  PRINT_STRING(code);
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_class, TF_CLASS)

TF_class::~TF_class()
{
  delete super;
  ctors.deleteAll();
}

void TF_class::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(TF_class);

  ToplevelForm::debugPrint(os, indent);

  PRINT_SUBTREE(super);
  PRINT_LIST(ASTClass, ctors);
}


// ------------------ ASTClass -------------------
// *** DO NOT EDIT ***
ASTClass::~ASTClass()
{
  args.deleteAll();
  decls.deleteAll();
}

void ASTClass::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(ASTClass);

  PRINT_STRING(name);
  PRINT_LIST(CtorArg, args);
  PRINT_LIST(Annotation, decls);
}


// ------------------ Annotation -------------------
// *** DO NOT EDIT ***
Annotation::~Annotation()
{
}

void Annotation::debugPrint(ostream &os, int indent) const
{
}

DEFN_AST_DOWNCASTS(Annotation, UserDecl, USERDECL)

UserDecl::~UserDecl()
{
}

void UserDecl::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(UserDecl);

  Annotation::debugPrint(os, indent);

  PRINT_GENERIC(access);
  PRINT_STRING(code);
}

DEFN_AST_DOWNCASTS(Annotation, CustomCode, CUSTOMCODE)

CustomCode::~CustomCode()
{
}

void CustomCode::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(CustomCode);

  Annotation::debugPrint(os, indent);

  PRINT_STRING(qualifier);
  PRINT_STRING(code);
}


// ------------------ CtorArg -------------------
// *** DO NOT EDIT ***
CtorArg::~CtorArg()
{
}

void CtorArg::debugPrint(ostream &os, int indent) const
{
  PRINT_HEADER(CtorArg);

  PRINT_BOOL(owner);
  PRINT_STRING(type);
  PRINT_STRING(name);
}


// *** DO NOT EDIT ***


#include "strutil.h"      // stringToupper

string toString(AccessCtl acc)
{
  char const *arr[] = { 
    "public", 
    "private", 
    "protected",
    "ctor",
    "dtor",
    "pure_virtual"
  };              
  STATIC_ASSERT(TABLESIZE(arr) == NUM_ACCESSCTLS);
  xassert((unsigned)acc < NUM_ACCESSCTLS);
  return string(arr[acc]);
}

string ASTClass::kindName() const
{
  string ret = stringToupper(name);
  if (ret == name) {
    // this simplemindedly avoids collisions with itself, and I think
    // it even avoids collisions with other classes, since if they would
    // collide with this, they'd collide with themselves too, and hence
    // get an extra "KIND_" prepended..
    ret &= "KIND_";
  }
  return ret;
}

