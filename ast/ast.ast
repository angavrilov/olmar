// ast.ast            see license.txt for copyright and terms of use
// ast definition for an ast definition

verbatim {
  #include "str.h"         // string
  
  #define GENERATED_AST_PRESENT
}

// the entire specification
class ASTSpecFile (ASTList<ToplevelForm> forms);

class ToplevelForm {
  // code to be copied verbatim into the generated .h file
  -> TF_verbatim(string code);

  // code to be copied verbatim into the generated .cc file
  -> TF_impl_verbatim(string code);

  // a superclass, and a list of subclasses ("constructors")
  -> TF_class(ASTClass super,
              ASTList<ASTClass> ctors) {
       public bool hasChildren() const { return ctors.isNotEmpty(); };
     }
}

// a definition of a grammar terminal or nonterminal
class ASTClass (string name,
                ASTList<CtorArg> args,
                ASTList<Annotation> decls) {
  // the name of the enum constant denoting this ctor, as distinguished
  // from its sibling ctors
  public string kindName() const;
}

verbatim {
  // specifies what kind of userdecl this is; pub/priv/prot are uninterpreted
  // class members with the associated access control; ctor and dtor are
  // code to be inserted into the ctor or dtor, respectively
  enum AccessCtl {
    AC_PUBLIC,      // access
    AC_PRIVATE,     //   control
    AC_PROTECTED,   //     keywords
    AC_CTOR,        // insert into ctor
    AC_DTOR,        // insert into dtor
    AC_PUREVIRT,    // declare pure virtual in superclass, and impl in subclass
    NUM_ACCESSCTLS
  };

  // map the enum value to a string like "public"
  string toString(AccessCtl acc);      // defined in ast.cc
}

// additional user annotations
class Annotation {
  // verbatim declarations, plus an access qualifier, to be
  // copied into the a class declaration
  -> UserDecl (AccessCtl access, string code);

  // verbatim code to be inserted somewhere; exactly where depends
  // on the qualifier string
  -> CustomCode (string qualifier, string code);
}

// something that has to be passed to create a constructor
class CtorArg (bool owner, string type, string name);


// ------------------- extra implementation helpers ------------------
impl_verbatim {

#include "strutil.h"      // stringToupper

string toString(AccessCtl acc)
{
  char const *arr[] = { 
    "public", 
    "private", 
    "protected",
    "ctor",
    "dtor",
    "pure_virtual"
  };              
  STATIC_ASSERT(TABLESIZE(arr) == NUM_ACCESSCTLS);
  xassert((unsigned)acc < NUM_ACCESSCTLS);
  return string(arr[acc]);
}

string ASTClass::kindName() const
{
  string ret = stringToupper(name);
  if (ret == name) {
    // this simplemindedly avoids collisions with itself, and I think
    // it even avoids collisions with other classes, since if they would
    // collide with this, they'd collide with themselves too, and hence
    // get an extra "KIND_" prepended..
    ret &= "KIND_";
  }
  return ret;
}

} // end verbatim_impl
